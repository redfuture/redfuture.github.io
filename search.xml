<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[learning-python阅读笔记]]></title>
    <url>%2F2019%2F01%2F23%2Flearning-python-notes%2F</url>
    <content type="text"><![CDATA[python对象类型介绍python的框架等级python程序可以分解为：模块，语句，表达式和对象 程序由模块构成。 模块包含语句。 语句包含表达式。 表达式建立并处理对象。 使用内建数据类型的好处 内建对象使得程序的编写更为简单 内建对象是其它扩展的基本元素 内建对象通常比自定义数据结构更有效率 内建对象是语言的一个标准部分 python的核心数据类型 数字 1234, 3.1415, 3+4j, 0b111, Decimal(), Fraction() 字符串 &#39;spam&#39;, &quot;Bob&#39;s&quot;, b&#39;a\x01c&#39;, u&#39;sp\xc4m&#39; 列表 [1, [2, &#39;three&#39;], 4.5], list(range(10)) 字典 {&#39;food&#39;: &#39;spam&#39;, &#39;taste&#39;: &#39;yum&#39;}, dict(hours=10) 元组 (1, &#39;spam&#39;, 4, &#39;U&#39;), tuple(&#39;spam&#39;), namedtuple 文件 open(&#39;eggs.txt&#39;), open(r&#39;C:\ham.bin&#39;, &#39;wb&#39;) 集合 set(&#39;abc&#39;), {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;} 其他核心类型：types，none，布尔型 程序单元类型：函数，模块，类。 实现相关的类型：compiled code, stack tracebacks python是动态类型的，也是强类型的语言，一旦创建了对象，它就和操作绑定了。使用变量前必须对其赋值。 python的数字，字符串，元组具有不可变性，创建之后不能改变，但是可以创建一个新的字符串赋给相同的变量名称，旧对象会被清理。 数字整数和浮点数，复数，固定精度的十进制数，有理分数，集合，布尔类型，其他开源的数字扩展（矩阵和向量，扩展精度数字） python3自动提供无穷的整数精度python2中如果整数类型不能容纳的数字需要使用单独的长整型 在python2.7或python3.1之前使用浮点数时可能会出现这种情况：1234&gt;&gt;&gt; 3.1415 * 2 # repr: as code (Pythons &lt; 2.7 and 3.1) 6.2830000000000004 &gt;&gt;&gt; print(3.1415 * 2) # str: user-friendly 6.283 这并不是一个bug，而是显示问题。注意浮点数的输出时的显示问题，python2.7或3.1之前的版本可能会显示出额外的精度，使用print进行输出即可。python2.7和python3.1之后的版本可以更智能的打印浮点数：12&gt;&gt;&gt; 3.1415 * 2 # repr: as code (Pythons &gt;= 2.7 and 3.1) 6.283 python中每个对象都有两种打印方式：完整精度（代码表示）和用户友好的（字符串）格式。所以当有些看起来奇怪的时候，试试使用print打印出来试试。 除了使用表达式python还提供了一个数字模块math和内置函数。12345&gt;&gt;&gt; import math &gt;&gt;&gt; math.pi 3.141592653589793 &gt;&gt;&gt; math.sqrt(85) 9.219544457292887 python的random模块：12345&gt;&gt;&gt; import random &gt;&gt;&gt; random.random() 0.7082048489415967 &gt;&gt;&gt; random.choice([1, 2, 3, 4]) #从一个list中随机选择1 字符串字符串是一个单个字符的序列列表，元组也是序列的一种。 序列的操作：支持索引(正负数索引)，切片，连接（+号），重复（*号） 不可变性：在创建后不能在原地被更改内容。不能覆盖不可变类型对象的值，但是可以使用相同的名字生成一个新的变量。python会负责回收就变量的空间。 python的每个对象都被分为不可变对象和可变对象：核心数据类型中数字，字符串，元组都属于不可变类型，列表，字典和集合都是可变的 如果想使用可更改的文本数据，可以将字符串转换成list或者，2.6/3.0之后的bytearray类型 字符串转换成list:12345&gt;&gt;&gt; S = 'shrubbery' &gt;&gt;&gt; L = list(S) # Expand to a list: [...] &gt;&gt;&gt; L ['s', 'h', 'r', 'u', 'b', 'b', 'e', 'r', 'y'] &gt;&gt;&gt; L[1] = 'c' # Change it in place &gt;&gt;&gt; ''.join(L) # Join with empty delimiter 字符串转换成bytearray，bytearray支持原地修改，但是只支持每个字符最多8bit的宽度（ASCII）123456&gt;&gt;&gt; B = bytearray(b'spam') # A bytes/list hybrid (ahead) &gt;&gt;&gt; B.extend(b'eggs') # 'b' needed in 3.X, not 2.X &gt;&gt;&gt; B # B[i] = ord(c) works here too bytearray(b'spameggs') &gt;&gt;&gt; B.decode() # Translate to normal string 'spameggs' 其他字符串操作函数1234567891011121314151617&gt;&gt;&gt; S = 'Spam' &gt;&gt;&gt; S.find('pa') # Find the offset of a substring in S&gt;&gt;&gt; S.replace('pa', 'XYZ') # Replace occurrences of a string in S with another&gt;&gt;&gt; line = 'aaa,bbb,ccccc,dd' &gt;&gt;&gt; line.split(',') # Split on a delimiter into a list of substrings&gt;&gt;&gt; S = 'spam' &gt;&gt;&gt; S.upper() # Upper- and lowercase conversions 'SPAM' &gt;&gt;&gt; S.isalpha() # Content tests: isalpha, isdigit, etc.&gt;&gt;&gt; line = 'aaa,bbb,ccccc,dd\n' &gt;&gt;&gt; line.rstrip() # Remove whitespace characters on the right side&gt;&gt;&gt; line.rstrip().split(',') # Combine two operations ['aaa', 'bbb', 'ccccc', 'dd'] 字符串还支持formatting 可以作为表达式或方法调用使用： 1234567&gt;&gt;&gt; '%s, eggs, and %s' % ('spam', 'SPAM!') # Formatting expression (all) 'spam, eggs, and SPAM!' &gt;&gt;&gt; '&#123;0&#125;, eggs, and &#123;1&#125;'.format('spam', 'SPAM!') # Formatting method (2.6+, 3.0+) 'spam, eggs, and SPAM!' &gt;&gt;&gt; '&#123;&#125;, eggs, and &#123;&#125;'.format('spam', 'SPAM!') # Numbers optional (2.7+, 3.1+) 格式化数字格式： 1234&gt;&gt;&gt; '&#123;:,.2f&#125;'.format(296999.2567) # Separators, decimal digits '296,999.26' &gt;&gt;&gt; '%.2f | %+05d' % (3.14159, ?42) # Digits, padding, signs '3.14 | ?0042' Python的跨多类型的通用操作通常由内建函数或表达式完成：len(X), X[0]特定类型的操作由方法调用完成(e.g., aString.upper()). 获得帮助 dir()函数，无参数时显示当前上下文中赋值的所有变量。有参数时会显示传入的对象的所有属性列表。其中带双下划线的属性表示支持自定义重载的属性，例如字符串的add方法实际上执行了连接操作： 1234&gt;&gt;&gt; S + 'NI!' 'spamNI!' &gt;&gt;&gt; S.__add__('NI!') 'spamNI!' 但通常情况下不应该直接调用add来使用它。 help函数用来查看某方法的详细信息： 1&gt;&gt;&gt; help(S.replace) help也是pydoc用来从对象抽取文档的有用接口，pydoc可以将文档渲染为HTML格式来显示 dir和help都可以接受类型名或变量名作为参数 其他字符串编码方法使用转义序列：12&gt;&gt;&gt; S = 'A\nB\tC'&gt;&gt;&gt; S = 'A\0B\0C' Unicode字符串 python2中，str类型的字符串处理8bit字符的字符串（包括ASCII文本）和原始字节值，unicode类型的字符串代表Unicode文本，2.6以后才支持python中的bytes类型的文本，但在python2中bytes仍然被按照str类型处理。Python3中，str类型的字符串可以处理Unicode文本，bytes类型的字符串代表原始的字节值(包括媒体文件和encode后的文本)python3中也支持python2中的Unicode文本，python3中按照str类型的字符串处理。 无论python2还是python3中，非unicode字符串都是8bit字节的序列。unicode字符串都是unicode码点的序列，一个码点就是一个字符的识别号码，存储在文件或内存中时可能占用多个字节，根据编码方式决定。 python2和python3都支持bytearray字符串类型，本质上是一个bytes字符串但是支持大多数list对象的可更改操作。 python2和python3都支持转义非ASCII字符的操作： \x 十六进制\u short Unicode\U long Unicode12&gt;&gt;&gt; 'sp\xc4\u00c4\U000000c4m' #python3中式str，python2中是unicode'sp???m' python2中可以混用str字符串和Unicode字符串：12u'x' + b'y' # Works in 2.X (where b is optional and ignored) u'x' + 'y' # Works in 2.X: u'xy' python3中不允许混用str字符串与bytes字符串，除非进行强制转换：1234u'x' + b'y' # Fails in 3.3 (where u is optional and ignored) u'x' + 'y' # Works in 3.3: 'xy' 'x' + b'y'.decode() # Works in 3.X if decode bytes to str: 'xy' 'x'.encode() + b'y' # Works in 3.X if encode str to bytes: b'xy' Unicode处理通常在将文本数据存入文件和从文件读出文本数据时进行：文本被编码成bytes存入文件，从文件读入内存时又被解码为字符。文本被加载后我们通常仅使用解法后的格式进行文本处理。 根据这个模型，python3中文件被按内容分为：文本文件和二进制文件。python2中正常文件内容是str类型的字节，使用专门的codecs模块处理Unicode并且使用unicode类型表示文件内容。 模式匹配使用re模块的方法进行查找，拆分，替换：1234567891011&gt;&gt;&gt; import re &gt;&gt;&gt; match = re.match('Hello[ \t]*(.*)world', 'Hello Python world') &gt;&gt;&gt; match.group(1) 'Python '&gt;&gt;&gt; match = re.match('[/:](.*)[/:](.*)[/:](.*)', '/usr/home:lumberjack') &gt;&gt;&gt; match.groups() ('usr', 'home', 'lumberjack') &gt;&gt;&gt; re.split('[/:]', '/usr/home/lumberjack') ['', 'usr', 'home', 'lumberjack'] 列表 [list]python中最常见的序列，顺序固定的任意类型对象的集合，无固定大小，属于可变数据类型，支持的操作包括： 序列的通用操作123456789101112131415&gt;&gt;&gt; L = [123, 'spam', 1.23] # A list of three different-type objects &gt;&gt;&gt; len(L) # Number of items in the list 3索引，分片等&gt;&gt;&gt; L[0] # Indexing by position 123 &gt;&gt;&gt; L[:-1] # Slicing a list returns a new list [123, 'spam'] &gt;&gt;&gt; L + [4, 5, 6] # Concat/repeat make new lists too [123, 'spam', 1.23, 4, 5, 6] &gt;&gt;&gt; L * 2 [123, 'spam', 1.23, 123, 'spam', 1.23] &gt;&gt;&gt; L # We're not changing the original list [123, 'spam', 1.23] list类型特有的操作1234567891011121314151617&gt;&gt;&gt; L.append('NI')&gt;&gt;&gt; L [123, 'spam', 1.23, 'NI']&gt;&gt;&gt; L.pop(2)1.23 &gt;&gt;&gt; L # "del L[2]" deletes from a list too [123, 'spam', 'NI']&gt;&gt;&gt; M = ['bb', 'aa', 'cc'] &gt;&gt;&gt; M.sort() &gt;&gt;&gt; M ['aa', 'bb', 'cc'] &gt;&gt;&gt; M.reverse() &gt;&gt;&gt; M ['cc', 'bb', 'aa'] 边界检查虽然list没有固定大小，python不允许引用不存在的项目，也不能通过给超出边界的值赋值，不会自动扩展：12345678910&gt;&gt;&gt; L [123, 'spam', 'NI'] &gt;&gt;&gt; L[99] ...error text omitted... IndexError: list index out of range &gt;&gt;&gt; L[99] = 1 ...error text omitted... IndexError: list assignment index out of range 嵌套python的核心数据类型都支持任意深度的嵌套。123456&gt;&gt;&gt; rec = &#123;'name': &#123;'first': 'Bob', 'last': 'Smith'&#125;, 'jobs': ['dev', 'mgr'], 'age': 40.5&#125;&gt;&gt;&gt; rec['jobs'].append('janitor') # Expand Bob's job description in place &gt;&gt;&gt; rec &#123;'age': 40.5, 'jobs': ['dev', 'mgr', 'janitor'], 'name': &#123;'last': 'Smith', 'first': 'Bob'&#125;&#125; python中当一个对象的最后一个引用消失后其内存空间会被立即回收。 列表解析 list comprehension expression12345&gt;&gt;&gt; M [[1, 2, 3], [4, 5, 6], [7, 8, 9]]&gt;&gt;&gt; col2 = [row[1] for row in M] # Collect the items in column 2 &gt;&gt;&gt; col2 [2, 5, 8] 通过对序列中的每个item运行一个表达式来构造一个新的list，一次一个，从左到右。在方括号中编码表示将产生一个list 12345678910&gt;&gt;&gt; [row[1] + 1 for row in M] # Add 1 to each item in column 2&gt;&gt;&gt; [row[1] for row in M if row[1] % 2 == 0] # Filter out odd items&gt;&gt;&gt; diag = [M[i][i] for i in [0, 1, 2]] # Collect a diagonal from matrix &gt;&gt;&gt; diag [1, 5, 9]&gt;&gt;&gt; doubles = [c * 2 for c in 'spam'] # Repeat characters in a string &gt;&gt;&gt; doubles ['ss', 'pp', 'aa', 'mm'] 使用range生成list 123456789&gt;&gt;&gt; list(range(4)) # 0..3 (list() required in 3.X) [0, 1, 2, 3] &gt;&gt;&gt; list(range(?6, 7, 2)) # ?6 to +6 by 2 (need list() in 3.X) [?6, ?4, ?2, 0, 2, 4, 6] &gt;&gt;&gt; [[x ** 2, x ** 3] for x in range(4)] # Multiple values, "if" filters [[0, 0], [1, 1], [4, 8], [9, 27]] &gt;&gt;&gt; [[x, x / 2, x * 2] for x in range(?6, 7, 2) if x &gt; 0] [[2, 1, 4], [4, 2, 8], [6, 3, 12]] 解析的语法不仅可以用来生成新的list，圆括号中的解析语法可以创建一个生成器，根据需求产生结果： 1234567&gt;&gt;&gt; G = (sum(row) for row in M) # Create a generator of row sums &gt;&gt;&gt; next(G) # iter(G) not required here6 &gt;&gt;&gt; next(G) # Run the iteration protocol next() 15 &gt;&gt;&gt; next(G) 24 map内建函数也可以做类似的工作，通过一个函数处理items产生结果，根据请求一次一个 python3中需要使用list()返回所有的值，python2中会自动返回所有结果的一个list 12&gt;&gt;&gt; list(map(sum, M)) # Map sum over items in M 与上例比较[6, 15, 24] python2.7和python3中解析语法可以用来创建集合和字典： 12345&gt;&gt;&gt; &#123;sum(row) for row in M&#125; # Create a set of row sums &#123;24, 6, 15&#125; &gt;&gt;&gt; &#123;i : sum(M[i]) for i in range(3)&#125; # Creates key/value table of row sums &#123;0: 6, 1: 15, 2: 24&#125; 所以python3和python2.7中，列表，集合，字典，生成器都可以由解析创建： 12345678&gt;&gt;&gt; [ord(x) for x in 'spaam'] # List of character ordinals [115, 112, 97, 97, 109] &gt;&gt;&gt; &#123;ord(x) for x in 'spaam'&#125; # Sets remove duplicates &#123;112, 97, 115, 109&#125; &gt;&gt;&gt; &#123;x: ord(x) for x in 'spaam'&#125; # Dictionary keys are unique &#123;'p': 112, 'a': 97, 's': 115, 'm': 109&#125; &gt;&gt;&gt; (ord(x) for x in 'spaam') # Generator of values &lt;generator object &lt;genexpr&gt; at 0x000000000254DAB0&gt; 字典字典不是序列，而是mapping，通过使用key而非相对位置存储对象。字典是python核心数据类型里唯一的mapping类型，是可变对象 mapping类型的操作 字典的定义： 1&gt;&gt;&gt; D = &#123;'food': 'Spam', 'quantity': 4, 'color': 'pink'&#125; 字典的检索： 12&gt;&gt;&gt; D['food'] # Fetch value of key 'food'&gt;&gt;&gt; D['quantity'] += 1 # Add 1 to 'quantity' value 通过给字典中不存在的key条目赋值可以创建该条目： 12&gt;&gt;&gt; D = &#123;&#125; &gt;&gt;&gt; D['name'] = 'Bob' # Create keys by assignment 一些应用情境下，字典被用作查找操作，通过key来索引字典通常是python中编写搜索程序速度最快的选择 其它声明字典的方法： 12&gt;&gt;&gt; bob1 = dict(name='Bob', job='dev', age=40) # Keywords&gt;&gt;&gt; bob2 = dict(zip(['name', 'job', 'age'], ['Bob', 'dev', 40]))# Zipping 相当于两列对应合并生成字典。 注意mapping并不维护key-value对出现的顺序，可能会根据python版本不同而不同 虽然字典可以通过给一个不存在的key赋值创建它，但是试图获取一个不存在的key会产生错误： 1234567&gt;&gt;&gt; D = &#123;'a': 1, 'b': 2, 'c': 3&#125; &gt;&gt;&gt; D['e'] = 99 # Assigning new keys grows dictionaries &gt;&gt;&gt; D &#123;'a': 1, 'c': 3, 'b': 2, 'e': 99&#125;&gt;&gt;&gt; D['f'] # Referencing a nonexistent key is an error ...error text omitted... KeyError: 'f' 此时可以先测试f是否在D中存在： 12&gt;&gt;&gt; if not 'f' in D: # Python's sole selection statement print('missing') 除了in测试还可以使用：get方法或带默认值的条件索引 1234567&gt;&gt;&gt; value = D.get('x', 0) # Index but with a default &gt;&gt;&gt; value 0 &gt;&gt;&gt; value = D['x'] if 'x' in D else 0 # if/else expression form &gt;&gt;&gt; value 0 对字典进行排序: 三步法 1234567891011&gt;&gt;&gt; D = &#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; Ks = list(D.keys()) # Unordered keys list &gt;&gt;&gt; Ks # A list in 2.X, "view" in 3.X: use list() ['a', 'c', 'b']&gt;&gt;&gt; Ks.sort() # Sorted keys list &gt;&gt;&gt; Ks ['a', 'b', 'c']&gt;&gt;&gt; for key in Ks: # Iterate though sorted keys print(key, '=&gt;', D[key])# &lt;== press Enter twice here (3.X print) 在交心的python中，支持sorted内建函数进行自动排序： 12&gt;&gt;&gt; for key in sorted(D): print(key, '=&gt;', D[key]) for循环是对序列（实际上是生成器）进行遍历操作的最佳方式： 12&gt;&gt;&gt; for c in 'spam': print(c.upper()) 迭代和优化for循环和列表解析表达式都是通用的迭代工具，实际上他们都可以工作在任何遵循迭代协议的可迭代对象上。 迭代协议：是指要实现对象的 __iter()__ 和 next() 方法（注意：Python3 要实现 __next__() 方法），其中，__iter()__ 方法返回迭代器对象本身，next() 方法返回容器的下一个元素，在没有后续元素时抛出 StopIteration 异常。一个对象可迭代： 此对象物理地存储在顺序的内存空间中 对象在每一次迭代操作时都生成一个item（一种虚拟的序列） 生成器列表表达式就是这样一个对象：它的所有值并不存储在相邻的内存单元中，但是可以随请求产生值。 python的文件对象被迭代工具使用时也可以一行一行的迭代，文件的内容并不在list里，而是根据迭代工具的需要进行读取。 以前的例子中sorted可以工作在字典上就是因为字典符合迭代协议。 任何列表解析都可以写成相应的循环：1&gt;&gt;&gt; squares = [x ** 2 for x in [1, 2, 3, 4, 5]] 等价于123&gt;&gt;&gt; squares = [] &gt;&gt;&gt; for x in [1, 2, 3, 4, 5]: # This is what a list comprehension does squares.append(x ** 2) # Both run the iteration protocol internally 但是列表解析，map，filter通常比for循环的写法执行速度更快，处理大数据集合时会获得性能提升。 python代码的主要准则是简单和稳定，然后才是性能。python也提供了衡量运行速度的工具time和timeit模块，profile模块用来确定性能瓶颈。 元组类似list，但不能修改，tuples与list一样是序列，但是是不可变类型的。通常被用来表示元素的固定集合。1&gt;&gt;&gt; T = (1, 2, 3, 4) # A 4-item tuple 元组也具备一些自己的方法12345&gt;&gt;&gt; T.index(4) # Tuple methods: 4 appears at offset 3 3 &gt;&gt;&gt; T.count(4) # 4 appears once 1&gt;&gt;&gt; T = (2,) + T[1:] # Make a new tuple for a new value 元组，与列表和字典相似，也支持混合数据类型和嵌套。但是它是不可变的不能增长或缩减。1&gt;&gt;&gt; T = 'spam', 3.0, [11, 22, 33] 文件文件对象是Python操作外部文件的主要接口。 文件对象是一个核心类型但是没有专门用来创建这个对象的语法，内建的open函数接受一个外部文件名和可选的处理模式字符串可以创建一个文件对象。123456&gt;&gt;&gt; f = open('data.txt', 'w') # Make a new file in output mode ('w' is write) &gt;&gt;&gt; f.write('Hello\n') # Write strings of characters to it 6 &gt;&gt;&gt; f.write('world\n') # Return number of items written in Python 3.X 6 &gt;&gt;&gt; f.close() # Close to flush output buffers to disk 无论文件中存储的是什么数据类型，脚本中的文件内容总是一个字符串。1234&gt;&gt;&gt; f = open('data.txt') # 'r' (read) is the default processing mode &gt;&gt;&gt; text = f.read() # Read entire file into a string &gt;&gt;&gt; text 'Hello\nworld\n' 文件对象还提供了很多其他的方法，read接受一个最大读入的字节或字符数量，readline一次读一行。 但是实际上最好的读入文件的方法是不是用read方法，文件对象提供了一个迭代器可以自动的为for循环和其它上下文按行读入：1&gt;&gt;&gt; for line in open('data.txt'): print(line) 二进制文件 python2中使用文件的8bit字节自然表示。python2中字符串会被原封不动的写入到文本文件中，不会自动编码。python3中依赖于平台的Unicode默认编码。Python3中文本文件中的字符串总是会被编码。python3中的文本和二进制文件有严格地区分，文本文件表示其内容会作为str字符串，并且在写入和读出时自动进行unicode编码和解码。而二进制文件的内容是bytes类型的字符串，允许无改变的访问文件内容。 在处理媒体文件，访问C语言创建的数据文件时二进制文件是很有用的。例如python的struct模块可以用来创建或解包二进制数据包1234567&gt;&gt;&gt; import struct &gt;&gt;&gt; packed = struct.pack('&gt;i4sh', 7, b'spam', 8) # Create packed binary data &gt;&gt;&gt; packed # 10 bytes, not objects or text b'\x00\x00\x00\x07spam\x00\x08' &gt;&gt;&gt; file = open('data.bin', 'wb') # Open binary output file &gt;&gt;&gt; file.write(packed) # Write packed binary data 10 &gt;&gt;&gt; file.close() Unicode文本文件如果要访问包含与默认编码不同的非ASCII的Unicode文本的文件时只需要在打开文件时传入一个编码名称的参数。python在读出和写入时会自动使用提供的编码进行编解码。一般情况下自动的编解码正是我们想要的，但如果想一探真正存储在文件中的内容时可以使用二进制模式打开文件。手工进行编解码。python2中的方法几乎相同，Unicode字符串会使用u前缀显示，unicode文本文件必须使用codecs.open打开，这个方法与python3的open一样接受一个编码名称参数。1234567&gt;&gt;&gt; import codecs &gt;&gt;&gt; codecs.open('unidata.txt', encoding='utf8').read() # 2.X: read/decode text u'sp\xc4m' &gt;&gt;&gt; open('unidata.txt', 'rb').read() # 2.X: read raw bytes 'sp\xc3\x84m' &gt;&gt;&gt; open('unidata.txt').read() # 2.X: raw/undecoded too 'sp\xc3\x84m' 其它文件类型的工具open用于大多数的文件操作python还提供多种工具用于：管道，FIFO，sockets，keyed-access files, persistent object shelves, descriptor-based files, relational and object-oriented database interfaces 其它核心类型集合 无序的单一集合，不可变对象： 123456&gt;&gt;&gt; X = set('spam') # Make a set out of a sequence in 2.X and 3.X &gt;&gt;&gt; Y = &#123;'h', 'a', 'm'&#125; # Make a set with set literals in 3.X and 2.7 &gt;&gt;&gt; X, Y # A tuple of two sets without parentheses (&#123;'m', 'a', 'p', 's'&#125;, &#123;'m', 'a', 'h'&#125;) &gt;&gt;&gt; X &amp; Y # Intersection &#123;'m', 'a'&#125; &gt;&gt;&gt; X | Y # Union &#123;'m', 'h', 'a', 'p', 's'&#125; &gt;&gt;&gt; X - Y # Difference 集合常被用作去重操作，寻找差异，不排序的相等比较等： 123456&gt;&gt;&gt; list(set([1, 2, 1, 3, 1])) # Filtering out duplicates (possibly reordered) [1, 2, 3] &gt;&gt;&gt; set('spam') - set('ham') # Finding differences in collections &#123;'p', 's'&#125; &gt;&gt;&gt; set('spam') == set('asmp') # Order-neutral equality tests (== is False) True 支持成员关系测试：12&gt;&gt;&gt; 'p' in set('spam'), 'p' in 'spam', 'ham' in ['eggs', 'spam', 'ham'] (True, True, True) python还新增了一些新的数值类型：小数（固定精度的浮点数），分数python具有布尔类型和None类型12345678&gt;&gt;&gt; 1 &gt; 2, 1 &lt; 2 # Booleans (False, True) &gt;&gt;&gt; bool('spam') # Object's Boolean value True &gt;&gt;&gt; X = None # None placeholder &gt;&gt;&gt; print(X) None python中不建议根据对象的类型进行编码，会降低代码的适应性1234567891011# In Python 2.X: &gt;&gt;&gt; type(L) # Types: type of L is list type object &lt;type 'list'&gt; &gt;&gt;&gt; type(type(L)) # Even types are objects &lt;type 'type'&gt; # In Python 3.X: &gt;&gt;&gt; type(L) # 3.X: types are classes, and vice versa &lt;class 'list'&gt; &gt;&gt;&gt; type(type(L)) # See Chapter 32 for more on class types &lt;class 'type'&gt; 用于测试对象的类型的方法：1234567891011&gt;&gt;&gt; if type(L) == type([]): # Type testing, if you must... print('yes') yes &gt;&gt;&gt; if type(L) == list: # Using the type name print('yes') yes &gt;&gt;&gt; if isinstance(L, list): # Object-oriented tests print('yes') yes 用户自定义的类]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安装，配置]]></title>
    <url>%2F2019%2F01%2F05%2Fhexo-install-config%2F</url>
    <content type="text"><![CDATA[前言在网络上游荡20几年，没有一个稳定的博客空间，很多自己的总结/随笔都是以文本文件的形式存储在本地，主要因为下面几个原因： 感觉大部分的博客空间都随时有消失的可能，免费空间大都有各种限制，没有安全感，不想自己多年的心血白费 大部分博客中的内容的富文本格式不可移植，不能很方便的同步在多个空间 我懒，本地存储虽然low但是使用、搜索、编辑起来还是很方便的 不过如今的网络文章写作已经很不同了，Markdown的流行甚至成了一种标准，主流的博客平台基本都开始支持Markdown格式，这让一次写作多处发布成为了可能，而且Markdown格式的文本在本地也很容易存储、编辑、解析后更已读、能够方便的导出为html,pdf等多种格式分享。很大程度上减轻了维护一个甚至多个博客空间的工作量。 支持Markdown写作的博客有多种选择，比如 在线的：简书，github，博客园，SegmentFault，开源中国，图灵社区等 blog建站系统：hexo，jekyII，wordpress，Ghost，gitblog，CMD Markdown，startblog等 我自己目前的需求是以本地为中心，能够方便的生成静态页面或直接上传Markdown文档后进行多位置的部署，又不想受各博客空间的模板限制，又想稳定方便，所以，自己搭搭建可以说是个很好的选择。在这里，我将介绍我当前博客的搭建方法：使用自己的虚拟主机+Github Page同步发布，基于Hexo框架，采用nexT模板。下面就把自己搭建，配置过程和使用方法进行一个记录。 我自己的博客环境的需求： 能在多台电脑随时写作更新，能在本地查看格式化后内容，能根据内容搜索。 博客空间位于两个位置：自己的虚拟主机和github.io ，可以同步更新。 对于文章可以有选择地复制到其它在线空间。 Hexo安装配置什么是Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo基于Node.js，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub上，是搭建博客的首选框架。 最好的介绍还是上官网链接：https://hexo.io/zh-cn/ 安装我的安装环境是一个刚刚在本地重装好的centos7虚拟机，首先我会用这台主机作为初始空间配置的生成，并运行独立的http服务器。 安装gitHexo, node.js, Hexo主题，后续空间的发布，配置及文章的同步都需要git作为工具。 Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Linux (Ubuntu, Debian)：sudo apt-get install git-core Windows：下载并安装 git. Mac：使用Homebrew, MacPorts：brew install git ;或下载安装程序安装。 由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。 安装Node.js安装 Node.js 的最佳方式是使用nvm。 cURL: 1$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh Wget: 1$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装Node.js： 1$ nvm install stable 或者您也可以下载安装程序来安装。 对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 配置以上Hexo最基本的组件已经全部安装完成，后续可能还会需要其它的依赖组件，在配置过程中用到时再随时安装。 创建一个Hexo运行目录Hexo系统需要一个目录用来初始化生成博客空间所需要的全部文件，我选择在自己home目录下的hexo文件夹： 1$ mkdir ~/hexo 初始化运行目录请执行下列命令，Hexo将会在指定文件夹中新建所需要的文件。 123$ hexo init ~/hexo$ cd ~/hexo$ npm install 新建完成后，文件夹hexo内的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中各文件和目录的作用： _config.yml: 网站的 配置 信息，您可以在此配置大部分的参数。 package.json: 应用程序的信息。一般无需更改。 scaffolds: 模版 文件夹。当新建文章时，Hexo 会根据scaffold来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source: 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes: 主题 文件夹。Hexo 会根据主题来生成静态页面。 执行完初始化，就可以预览一下hexo的初始样貌了，可以在~/hexo目录下执行如下命令: 12$ hexo generate$ hexo server 执行完毕后可以通过浏览器访问http://server-ip:4000/来访问 配置hexo安装nexT主题我个人很喜欢hexo的NexT主题，所以配置过程中一起安装这个主题。NexT主题是托管在github上的，其新的主页地址：https://github.com/theme-next/hexo-theme-next/原地址，此代码库已停止更新：https://github.com/iissnan/hexo-theme-next 安装方法： 12cd ~/hexogit clone https://github.com/theme-next/hexo-theme-next themes/next 修改hexo站点基本配置~/hexo/_config.yml可以在 _config.yml 中修改大部分的配置。以下是我修改的内容： 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述。主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。 author 您的名字，用于显示文章的作者。 language 网站使用的语言，简体中文应设置为zh-Hans，支持的语言列表可参看所用主题的目录：themes/next/languages/ timezone 网站时区。Hexo默认使用您电脑的时区。为增加移植性设定为北京时间：Asia/Shanghai ，参考时区列表。 url 网址，填http://自己网站域名 root 网站根目录，本blog在网站中的目录 theme 当前主题名称，即themes目录下主题目录的名称。我安装了NexT主题，这里设置为 next deploy 部署部分的设置，将在下面章节详述 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 下列参数是可能会用到的，我目前保留了默认值： 参数 描述 默认值 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 default_category 默认分类 uncategorized date_format 日期格式 Hexo 使用 Moment.js 来解析和显示时间。 YYYY-MM-DD time_format 时间格式 H:mm:ss per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 修改NexT主题配置~/hexo/themes/next/_config.yml关于NexT主题的全部详细配置方法见官网：https://theme-next.org/原官网地址，已停止更新：https://theme-next.iissnan.com 我自己对NexT主题配置文件的修改如下： 显示在菜单导航栏中的项目1234567menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive about: /about/ || user sitemap: /sitemap.xml || sitemap categories和tags页面将在后面使用hexo命令创建 主题显示布局，默认为Muse，更改为更简洁的Mist1234#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 修改社交媒体及联系方式123social: GitHub: https://github.com/redfuture || github E-Mail: mailto:redfuture@hotmail.com || envelope 其中第一部分为显示的文字名称，第二部分为链接，第三部分为显示的图标对应的fontawesome icons的名称 添加站点建立时间12footer: since: 2019 添加背景动画1canvas_nest: true 使用night风格的代码高亮显示1highlight_theme: night 至此hexo站点与next主题基本配置完毕。接下来使用hexo命令创建categories和tags页面，并新建一个新的文章。 使用hexo我希望在站点首页的导航菜单栏里添加两个链接： 分类：显示所有文章分类的页面，点击分类后显示这个分类下的所有文章 标签：所有文章使用过的标签页面，点击相应标签可以查看所有有此标签的文章 创建categories和tags页面hexo中创建页面的方式是相同的，使用以下命令：123$ hexo new page categories$ hexo new page tags$ hexo new page about 我同时还创建了一个关于页面，可以添加个人的简历，这个些可以和NexT主题配置文件中menu下面的子项相对应。命令执行后的结果就是在~/hexo/source/目录下分别生成了三个目录：categories，tags，about。每个目录中都有一个index.md。 修改post模板我们有了categories页面及tags页面，希望在以后发布的每篇博客都指定一个分类（Hexo仅支持一篇文章属于一个分类，不能属于多个分类），并设置多个标签。那么可以修改scaffolds/post.md文件，这个文件中的内容在以后每次用命令行创建新文章时会自动复制到新文章的md文件中。将其内容修改成：123456789---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:- defaulttags:- default1- default2--- 发布新文章现在所有都已经准备就绪，可以发布自己的第一篇文章了：1$ hexo new post "title" 命令执行后创建~/hexo/source/_post/title.md ,随后就可以使用熟悉的编辑器编辑title.md了 或者可以先创建一个草稿：1$ hexo new draft "title" 会生成~/hexo/source/_post/title.md，编辑完成后执行1$ hexo publish post "title" 会将文件移动到~/hexo/source/_post/title.md 生成静态页面并部署文章写作完成后可以执行如下命令生成静态页面：12345678$ hexo generate (hexo g) 由当前目录下的配置和文章生成新的博客静态页面$ hexo server (hexo s) 启动本地http server服务，默认在4000端口$ hexo deploy (hexo d) 提交到远程仓库$ hexo new page "xx"(hexo n page) 创建页面 $ hexo new "xx" (hexo n "") 创建文章$ hexo d -g 生成静态并提交到远程仓库$ hexo s -g 生成静态文件并启动本地预览$ hexo clean 如果修改了配置文件，建议先执行这个步骤，将public下的文件全部清除，重新生成 之后就可以在http://localhost:4000/看到刚才发布的文章了。至此hexo基础环境已经搭建完成。 将静态页面部署到github.iogithub为每个用户提供了一个无限容量的静态页面空间：your-github-username.github.io hexo也提供了方便的将自己的博客部署到github.io的功能： 登录自己github，确认已经存在username.github.io代码库，没有的话创建一个（必须以.github.io做后缀）。 生成一对RSA key, 命令如下： 1$ ssh-keygen -t rsa -b 4096 -C "自己的标识" 一路回车，会在~/.ssh/目录下生成两个文件：id_rsa和id_rsa.pub ，id_rsa自己保留好这是私钥。 将上面生成的id_rsa.pub配置到github账户，以便可以免密从自己的代码库check in/out代码。具体参见github帮助文档：Adding a new SSH key to your GitHub account 验证是否添加key成功： 1$ ssh -T git@github.com 修改站点配置文件：~/hexo/_config.yml 1234deploy: type: git repo: git@github.com:username.github.io.git branch: master 安装hexo的git插件 1$ npm install hexo-deployer-git --save 运行命令进行部署： 12$ hexo g$ hexo d 之后就可以在 http://username.github.io 看到自己的博客了。 写作环境博客基本成形了，同时发布在了github.io。但是有一个问题，如何能方便的在任意电脑上都能随时随地的码字更新，修改配置呢？ 建立个性化内容的代码库分析Hexo的文档结构后发现会被我们使用的配置文件和存储文章md文件的目录其实很集中，那么我们可以把这些可能被改变的文件提取出来，单独存放在一个github的代码库，这样每当需要修改配置，或添加新文章时就可以先去代码库checkout，修改，然后checkin了。只要电脑有git客户端和一个markdown编辑器就够了。 在github建立一个新代码库，假设名称为：myblog_site 将本地hexo运行目录中需要保存到github的易变内容提取出来： 12345$ mkdir ~/myblog_site$ mkdir -p ~/myblog_site/themes/next$ cd ~/hexo/$ cp -a _config.yml scaffolds source ~/myblog_site/ #拷贝站点配置，模板，文章目录至代码库目录$ cp themes/next/_config.yml ~/myblog_site/themes/next/ #拷贝NexT主题配置文件至代码库相同路径下 将~/myblog_site/ 初始化为git目录，并于新建立的代码库myblog_site关联，checkin 123456$ cd ~/myblog_site$ git init$ git add *$ git commit -a -m "init blog raw data."$ git remote add origin git@github.com:username/myblog_site.git$ git push -u origin master #将本地代码推送到远程代码库 至此博客的数据代码库建立完成。 在虚拟主机上建立相同的站点 登录虚拟主机，按照上面的步骤完成安装，假设仍然将hexo工作目录放在~/hexo/。 checkout博客的配置和文章数据： 12345678910$ cd$ scp id_rsa.pub ~/.ssh/ #将上面生成的私钥放置在虚拟主机服务器上$ git clone git@github.com:username/myblog_site.git #将配置/文章代码库克隆到本地$ cd ~/hexo/ #进入安装初始化好的博客工作目录$ rm -rf _config.yml scaffolds source themes/next/_config.yml$ ln -s ~/myblog_site/_config.yml # 如下分别将文件链接到代码库中的相同文件/目录$ ln -s ~/myblog_site/scaffolds$ ln -s ~/myblog_site/source$ cd themes/next/$ ln -s ~/myblog_site/themes/next/_config.yml 在虚拟主机上执行静态页面生成与部署： 123$ hexo g$ hexo d$ hexo s &amp; 后续写作过程 在一台新的工作电脑上（已安装git），将myblog_site克隆到本地目录。 使用任意markdown编辑器，编辑/添加文章到相应目录，或修改配置文件。 发布时先checkin到github: 12$ git commit -a -m "comments"$ git push origin master 登录到自己的虚拟主机执行myblog_site的checkout，然后执行静态页面的生成与部署到github.io，同时主机上启动服务。 关于markdown编辑器目前有多种编辑器可供使用,比如markdownpad, 在线的简书编辑器等，我自己更喜欢一些开源，免费，简单可移植的工具。工作中一直在用notepad++这个工具觉得很不错。notepad++也有第三方的plugin可以进行简单的markdown解析预览，虽然效果不是特别好，但是对于日常的文章写作足够用。 notepad++ notepad++ markdown预览插件：MarkdownViewerPlusPlus notepad++ markdown语法高亮插件：Markdown Syntax Highlighting for Notepad++ 以上所有部件均为纯绿色版本，存进自己的U盘，随身携带，即插即用。 完善博客功能添加搜索 进入到站点根目录：cd ~/hexo/ 安装：npm install –save hexo-generator-searchdb 配置： 编辑站点配置文件~/hexo/_config.yml，确保下列内容存在： 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件~/hexo/theme/next/_config.yml，启用本地搜索功能： 123# Local searchlocal_search: enable: true 重新生成。 添加站点地图 进入到站点根目录：cd ~/hexo/ 分别用下面两个命令来安装针对谷歌和百度的插件： 12$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 在站点配置文件中~/hexo/_config.yml中添加如下代码 12345678Plugins:- hexo-generator-baidu-sitemap- hexo-generator-sitemapbaidusitemap: path: baidusitemap.xmlsitemap: path: sitemap.xml 在你的博客根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了 优化SEO最简单的 添加RSS添加fork me on github 在GitHub Ribbons或GitHub Corners选择一款你喜欢的挂饰，拷贝方框内的代码。 将刚刚复制的挂饰代码，添加到hexo/themes/next/layout/_layout.swig文件中，放在下方。 12&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;&lt;a href=&quot;https://github.com/redfuture/&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 添加公益404页面设置阅读全文方式设置侧栏头像文章中使用图片添加评论功能添加访问量统计 静态网页最快接入计算访问量插件:不蒜子 接入方式很简单只需要将如下代码加入到页面中想要显示的位置:123456&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;span id="busuanzi_container_site_pv"&gt;本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次本站访客数&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人次本文总阅读量&lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt;次&lt;/span&gt; 在hexo的next主题中已经集成了不蒜子，使用起来更为方便，只需修改next的主题的配置文件：themes/next/_config.yml123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; page_pv_footer: 由于不蒜子的域名改变，如果使用了旧版本的next主题，还需修改next主题中不蒜子的地址，位于文件themes/next/layout/_third-party/analytics/busuanzi-counter.swig。 1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>skills</tag>
        <tag>github.io</tag>
      </tags>
  </entry>
</search>
