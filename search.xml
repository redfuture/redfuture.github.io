<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[learning-python阅读笔记]]></title>
    <url>%2F2019%2F01%2F23%2Flearning-python-notes%2F</url>
    <content type="text"><![CDATA[python对象类型介绍python的框架等级python程序可以分解为：模块，语句，表达式和对象 程序由模块构成。 模块包含语句。 语句包含表达式。 表达式建立并处理对象。 使用内建数据类型的好处 内建对象使得程序的编写更为简单 内建对象是其它扩展的基本元素 内建对象通常比自定义数据结构更有效率 内建对象是语言的一个标准部分 python的核心数据类型 数字 1234, 3.1415, 3+4j, 0b111, Decimal(), Fraction() 字符串 &#39;spam&#39;, &quot;Bob&#39;s&quot;, b&#39;a\x01c&#39;, u&#39;sp\xc4m&#39; 列表 [1, [2, &#39;three&#39;], 4.5], list(range(10)) 字典 {&#39;food&#39;: &#39;spam&#39;, &#39;taste&#39;: &#39;yum&#39;}, dict(hours=10) 元组 (1, &#39;spam&#39;, 4, &#39;U&#39;), tuple(&#39;spam&#39;), namedtuple 文件 open(&#39;eggs.txt&#39;), open(r&#39;C:\ham.bin&#39;, &#39;wb&#39;) 集合 set(&#39;abc&#39;), {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;} 其他核心类型：types，none，布尔型 程序单元类型：函数，模块，类。 实现相关的类型：compiled code, stack tracebacks python是动态类型的，也是强类型的语言，一旦创建了对象，它就和操作绑定了。使用变量前必须对其赋值。 python的数字，字符串，元组具有不可变性，创建之后不能改变，但是可以创建一个新的字符串赋给相同的变量名称，旧对象会被清理。 数字整数和浮点数，复数，固定精度的十进制数，有理分数，集合，布尔类型，其他开源的数字扩展（矩阵和向量，扩展精度数字） python3自动提供无穷的整数精度python2中如果整数类型不能容纳的数字需要使用单独的长整型 在python2.7或python3.1之前使用浮点数时可能会出现这种情况：1234&gt;&gt;&gt; 3.1415 * 2 # repr: as code (Pythons &lt; 2.7 and 3.1) 6.2830000000000004 &gt;&gt;&gt; print(3.1415 * 2) # str: user-friendly 6.283 这并不是一个bug，而是显示问题。注意浮点数的输出时的显示问题，python2.7或3.1之前的版本可能会显示出额外的精度，使用print进行输出即可。python2.7和python3.1之后的版本可以更智能的打印浮点数：12&gt;&gt;&gt; 3.1415 * 2 # repr: as code (Pythons &gt;= 2.7 and 3.1) 6.283 python中每个对象都有两种打印方式：完整精度（代码表示）和用户友好的（字符串）格式。所以当有些看起来奇怪的时候，试试使用print打印出来试试。 除了使用表达式python还提供了一个数字模块math和内置函数。12345&gt;&gt;&gt; import math &gt;&gt;&gt; math.pi 3.141592653589793 &gt;&gt;&gt; math.sqrt(85) 9.219544457292887 python的random模块：12345&gt;&gt;&gt; import random &gt;&gt;&gt; random.random() 0.7082048489415967 &gt;&gt;&gt; random.choice([1, 2, 3, 4]) #从一个list中随机选择1 字符串字符串是一个单个字符的序列列表，元组也是序列的一种。 序列的操作：支持索引(正负数索引)，切片，连接（+号），重复（*号） 不可变性：在创建后不能在原地被更改内容。不能覆盖不可变类型对象的值，但是可以使用相同的名字生成一个新的变量。python会负责回收就变量的空间。 python的每个对象都被分为不可变对象和可变对象：核心数据类型中数字，字符串，元组都属于不可变类型，列表，字典和集合都是可变的 如果想使用可更改的文本数据，可以将字符串转换成list或者，2.6/3.0之后的bytearray类型 字符串转换成list:12345&gt;&gt;&gt; S = 'shrubbery' &gt;&gt;&gt; L = list(S) # Expand to a list: [...] &gt;&gt;&gt; L ['s', 'h', 'r', 'u', 'b', 'b', 'e', 'r', 'y'] &gt;&gt;&gt; L[1] = 'c' # Change it in place &gt;&gt;&gt; ''.join(L) # Join with empty delimiter 字符串转换成bytearray，bytearray支持原地修改，但是只支持每个字符最多8bit的宽度（ASCII）123456&gt;&gt;&gt; B = bytearray(b'spam') # A bytes/list hybrid (ahead) &gt;&gt;&gt; B.extend(b'eggs') # 'b' needed in 3.X, not 2.X &gt;&gt;&gt; B # B[i] = ord(c) works here too bytearray(b'spameggs') &gt;&gt;&gt; B.decode() # Translate to normal string 'spameggs' 其他字符串操作函数1234567891011121314151617&gt;&gt;&gt; S = 'Spam' &gt;&gt;&gt; S.find('pa') # Find the offset of a substring in S&gt;&gt;&gt; S.replace('pa', 'XYZ') # Replace occurrences of a string in S with another&gt;&gt;&gt; line = 'aaa,bbb,ccccc,dd' &gt;&gt;&gt; line.split(',') # Split on a delimiter into a list of substrings&gt;&gt;&gt; S = 'spam' &gt;&gt;&gt; S.upper() # Upper- and lowercase conversions 'SPAM' &gt;&gt;&gt; S.isalpha() # Content tests: isalpha, isdigit, etc.&gt;&gt;&gt; line = 'aaa,bbb,ccccc,dd\n' &gt;&gt;&gt; line.rstrip() # Remove whitespace characters on the right side&gt;&gt;&gt; line.rstrip().split(',') # Combine two operations ['aaa', 'bbb', 'ccccc', 'dd'] 字符串还支持formatting 可以作为表达式或方法调用使用： 1234567&gt;&gt;&gt; '%s, eggs, and %s' % ('spam', 'SPAM!') # Formatting expression (all) 'spam, eggs, and SPAM!' &gt;&gt;&gt; '&#123;0&#125;, eggs, and &#123;1&#125;'.format('spam', 'SPAM!') # Formatting method (2.6+, 3.0+) 'spam, eggs, and SPAM!' &gt;&gt;&gt; '&#123;&#125;, eggs, and &#123;&#125;'.format('spam', 'SPAM!') # Numbers optional (2.7+, 3.1+) 格式化数字格式： 1234&gt;&gt;&gt; '&#123;:,.2f&#125;'.format(296999.2567) # Separators, decimal digits '296,999.26' &gt;&gt;&gt; '%.2f | %+05d' % (3.14159, ?42) # Digits, padding, signs '3.14 | ?0042' Python的跨多类型的通用操作通常由内建函数或表达式完成：len(X), X[0]特定类型的操作由方法调用完成(e.g., aString.upper()). 获得帮助 dir()函数，无参数时显示当前上下文中赋值的所有变量。有参数时会显示传入的对象的所有属性列表。其中带双下划线的属性表示支持自定义重载的属性，例如字符串的add方法实际上执行了连接操作： 1234&gt;&gt;&gt; S + 'NI!' 'spamNI!' &gt;&gt;&gt; S.__add__('NI!') 'spamNI!' 但通常情况下不应该直接调用add来使用它。 help函数用来查看某方法的详细信息： 1&gt;&gt;&gt; help(S.replace) help也是pydoc用来从对象抽取文档的有用接口，pydoc可以将文档渲染为HTML格式来显示 dir和help都可以接受类型名或变量名作为参数 其他字符串编码方法使用转义序列：12&gt;&gt;&gt; S = 'A\nB\tC'&gt;&gt;&gt; S = 'A\0B\0C' Unicode字符串 python2中，str类型的字符串处理8bit字符的字符串（包括ASCII文本）和原始字节值，unicode类型的字符串代表Unicode文本，2.6以后才支持python中的bytes类型的文本，但在python2中bytes仍然被按照str类型处理。Python3中，str类型的字符串可以处理Unicode文本，bytes类型的字符串代表原始的字节值(包括媒体文件和encode后的文本)python3中也支持python2中的Unicode文本，python3中按照str类型的字符串处理。 无论python2还是python3中，非unicode字符串都是8bit字节的序列。unicode字符串都是unicode码点的序列，一个码点就是一个字符的识别号码，存储在文件或内存中时可能占用多个字节，根据编码方式决定。 python2和python3都支持bytearray字符串类型，本质上是一个bytes字符串但是支持大多数list对象的可更改操作。 python2和python3都支持转义非ASCII字符的操作： \x 十六进制\u short Unicode\U long Unicode12&gt;&gt;&gt; 'sp\xc4\u00c4\U000000c4m' #python3中式str，python2中是unicode'sp???m' python2中可以混用str字符串和Unicode字符串：12u'x' + b'y' # Works in 2.X (where b is optional and ignored) u'x' + 'y' # Works in 2.X: u'xy' python3中不允许混用str字符串与bytes字符串，除非进行强制转换：1234u'x' + b'y' # Fails in 3.3 (where u is optional and ignored) u'x' + 'y' # Works in 3.3: 'xy' 'x' + b'y'.decode() # Works in 3.X if decode bytes to str: 'xy' 'x'.encode() + b'y' # Works in 3.X if encode str to bytes: b'xy' Unicode处理通常在将文本数据存入文件和从文件读出文本数据时进行：文本被编码成bytes存入文件，从文件读入内存时又被解码为字符。文本被加载后我们通常仅使用解法后的格式进行文本处理。 根据这个模型，python3中文件被按内容分为：文本文件和二进制文件。python2中正常文件内容是str类型的字节，使用专门的codecs模块处理Unicode并且使用unicode类型表示文件内容。 模式匹配使用re模块的方法进行查找，拆分，替换：1234567891011&gt;&gt;&gt; import re &gt;&gt;&gt; match = re.match('Hello[ \t]*(.*)world', 'Hello Python world') &gt;&gt;&gt; match.group(1) 'Python '&gt;&gt;&gt; match = re.match('[/:](.*)[/:](.*)[/:](.*)', '/usr/home:lumberjack') &gt;&gt;&gt; match.groups() ('usr', 'home', 'lumberjack') &gt;&gt;&gt; re.split('[/:]', '/usr/home/lumberjack') ['', 'usr', 'home', 'lumberjack'] 列表 [list]python中最常见的序列，顺序固定的任意类型对象的集合，无固定大小，属于可变数据类型，支持的操作包括： 序列的通用操作123456789101112131415&gt;&gt;&gt; L = [123, 'spam', 1.23] # A list of three different-type objects &gt;&gt;&gt; len(L) # Number of items in the list 3索引，分片等&gt;&gt;&gt; L[0] # Indexing by position 123 &gt;&gt;&gt; L[:-1] # Slicing a list returns a new list [123, 'spam'] &gt;&gt;&gt; L + [4, 5, 6] # Concat/repeat make new lists too [123, 'spam', 1.23, 4, 5, 6] &gt;&gt;&gt; L * 2 [123, 'spam', 1.23, 123, 'spam', 1.23] &gt;&gt;&gt; L # We're not changing the original list [123, 'spam', 1.23] list类型特有的操作1234567891011121314151617&gt;&gt;&gt; L.append('NI')&gt;&gt;&gt; L [123, 'spam', 1.23, 'NI']&gt;&gt;&gt; L.pop(2)1.23 &gt;&gt;&gt; L # "del L[2]" deletes from a list too [123, 'spam', 'NI']&gt;&gt;&gt; M = ['bb', 'aa', 'cc'] &gt;&gt;&gt; M.sort() &gt;&gt;&gt; M ['aa', 'bb', 'cc'] &gt;&gt;&gt; M.reverse() &gt;&gt;&gt; M ['cc', 'bb', 'aa'] 边界检查虽然list没有固定大小，python不允许引用不存在的项目，也不能通过给超出边界的值赋值，不会自动扩展：12345678910&gt;&gt;&gt; L [123, 'spam', 'NI'] &gt;&gt;&gt; L[99] ...error text omitted... IndexError: list index out of range &gt;&gt;&gt; L[99] = 1 ...error text omitted... IndexError: list assignment index out of range 嵌套python的核心数据类型都支持任意深度的嵌套。123456&gt;&gt;&gt; rec = &#123;'name': &#123;'first': 'Bob', 'last': 'Smith'&#125;, 'jobs': ['dev', 'mgr'], 'age': 40.5&#125;&gt;&gt;&gt; rec['jobs'].append('janitor') # Expand Bob's job description in place &gt;&gt;&gt; rec &#123;'age': 40.5, 'jobs': ['dev', 'mgr', 'janitor'], 'name': &#123;'last': 'Smith', 'first': 'Bob'&#125;&#125; python中当一个对象的最后一个引用消失后其内存空间会被立即回收。 列表解析 list comprehension expression12345&gt;&gt;&gt; M [[1, 2, 3], [4, 5, 6], [7, 8, 9]]&gt;&gt;&gt; col2 = [row[1] for row in M] # Collect the items in column 2 &gt;&gt;&gt; col2 [2, 5, 8] 通过对序列中的每个item运行一个表达式来构造一个新的list，一次一个，从左到右。在方括号中编码表示将产生一个list 12345678910&gt;&gt;&gt; [row[1] + 1 for row in M] # Add 1 to each item in column 2&gt;&gt;&gt; [row[1] for row in M if row[1] % 2 == 0] # Filter out odd items&gt;&gt;&gt; diag = [M[i][i] for i in [0, 1, 2]] # Collect a diagonal from matrix &gt;&gt;&gt; diag [1, 5, 9]&gt;&gt;&gt; doubles = [c * 2 for c in 'spam'] # Repeat characters in a string &gt;&gt;&gt; doubles ['ss', 'pp', 'aa', 'mm'] 使用range生成list 123456789&gt;&gt;&gt; list(range(4)) # 0..3 (list() required in 3.X) [0, 1, 2, 3] &gt;&gt;&gt; list(range(?6, 7, 2)) # ?6 to +6 by 2 (need list() in 3.X) [?6, ?4, ?2, 0, 2, 4, 6] &gt;&gt;&gt; [[x ** 2, x ** 3] for x in range(4)] # Multiple values, "if" filters [[0, 0], [1, 1], [4, 8], [9, 27]] &gt;&gt;&gt; [[x, x / 2, x * 2] for x in range(?6, 7, 2) if x &gt; 0] [[2, 1, 4], [4, 2, 8], [6, 3, 12]] 解析的语法不仅可以用来生成新的list，圆括号中的解析语法可以创建一个生成器，根据需求产生结果： 1234567&gt;&gt;&gt; G = (sum(row) for row in M) # Create a generator of row sums &gt;&gt;&gt; next(G) # iter(G) not required here6 &gt;&gt;&gt; next(G) # Run the iteration protocol next() 15 &gt;&gt;&gt; next(G) 24 map内建函数也可以做类似的工作，通过一个函数处理items产生结果，根据请求一次一个 python3中需要使用list()返回所有的值，python2中会自动返回所有结果的一个list12&gt;&gt;&gt; list(map(sum, M)) # Map sum over items in M 与上例比较[6, 15, 24] python2.7和python3中解析语法可以用来创建集合和字典： 12345&gt;&gt;&gt; &#123;sum(row) for row in M&#125; # Create a set of row sums &#123;24, 6, 15&#125; &gt;&gt;&gt; &#123;i : sum(M[i]) for i in range(3)&#125; # Creates key/value table of row sums &#123;0: 6, 1: 15, 2: 24&#125; 所以python3和python2.7中，列表，集合，字典，生成器都可以由解析创建： 12345678&gt;&gt;&gt; [ord(x) for x in 'spaam'] # List of character ordinals [115, 112, 97, 97, 109] &gt;&gt;&gt; &#123;ord(x) for x in 'spaam'&#125; # Sets remove duplicates &#123;112, 97, 115, 109&#125; &gt;&gt;&gt; &#123;x: ord(x) for x in 'spaam'&#125; # Dictionary keys are unique &#123;'p': 112, 'a': 97, 's': 115, 'm': 109&#125; &gt;&gt;&gt; (ord(x) for x in 'spaam') # Generator of values &lt;generator object &lt;genexpr&gt; at 0x000000000254DAB0&gt; 字典字典不是序列，而是mapping，通过使用key而非相对位置存储对象。字典是python核心数据类型里唯一的mapping类型，是可变对象 mapping类型的操作 字典的定义： 1&gt;&gt;&gt; D = &#123;'food': 'Spam', 'quantity': 4, 'color': 'pink'&#125; 字典的检索： 12&gt;&gt;&gt; D['food'] # Fetch value of key 'food'&gt;&gt;&gt; D['quantity'] += 1 # Add 1 to 'quantity' value 通过给字典中不存在的key条目赋值可以创建该条目： 12&gt;&gt;&gt; D = &#123;&#125; &gt;&gt;&gt; D['name'] = 'Bob' # Create keys by assignment 一些应用情境下，字典被用作查找操作，通过key来索引字典通常是python中编写搜索程序速度最快的选择 其它声明字典的方法： 12&gt;&gt;&gt; bob1 = dict(name='Bob', job='dev', age=40) # Keywords&gt;&gt;&gt; bob2 = dict(zip(['name', 'job', 'age'], ['Bob', 'dev', 40]))# Zipping 相当于两列对应合并生成字典。 注意mapping并不维护key-value对出现的顺序，可能会根据python版本不同而不同 虽然字典可以通过给一个不存在的key赋值创建它，但是试图获取一个不存在的key会产生错误： 1234567&gt;&gt;&gt; D = &#123;'a': 1, 'b': 2, 'c': 3&#125; &gt;&gt;&gt; D['e'] = 99 # Assigning new keys grows dictionaries &gt;&gt;&gt; D &#123;'a': 1, 'c': 3, 'b': 2, 'e': 99&#125;&gt;&gt;&gt; D['f'] # Referencing a nonexistent key is an error ...error text omitted... KeyError: 'f' 此时可以先测试f是否在D中存在： 12&gt;&gt;&gt; if not 'f' in D: # Python's sole selection statement print('missing') 除了in测试还可以使用：get方法或带默认值的条件索引 1234567&gt;&gt;&gt; value = D.get('x', 0) # Index but with a default &gt;&gt;&gt; value 0 &gt;&gt;&gt; value = D['x'] if 'x' in D else 0 # if/else expression form &gt;&gt;&gt; value 0 对字典进行排序: 三步法 1234567891011&gt;&gt;&gt; D = &#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; Ks = list(D.keys()) # Unordered keys list &gt;&gt;&gt; Ks # A list in 2.X, "view" in 3.X: use list() ['a', 'c', 'b']&gt;&gt;&gt; Ks.sort() # Sorted keys list &gt;&gt;&gt; Ks ['a', 'b', 'c']&gt;&gt;&gt; for key in Ks: # Iterate though sorted keys print(key, '=&gt;', D[key])# &lt;== press Enter twice here (3.X print) 在较新的python中，支持sorted内建函数进行自动排序： 12&gt;&gt;&gt; for key in sorted(D): print(key, '=&gt;', D[key]) for循环是对序列（实际上是生成器）进行遍历操作的最佳方式：12&gt;&gt;&gt; for c in 'spam': print(c.upper()) 迭代和优化for循环和列表解析表达式都是通用的迭代工具，实际上他们都可以工作在任何遵循迭代协议的可迭代对象上。 迭代协议：是指要实现对象的 __iter()__ 和 next() 方法（注意：Python3 要实现 __next__() 方法），其中，__iter()__ 方法返回迭代器对象本身，next() 方法返回容器的下一个元素，在没有后续元素时抛出 StopIteration 异常。一个对象可迭代： 此对象物理地存储在顺序的内存空间中 对象在每一次迭代操作时都生成一个item（一种虚拟的序列） 生成器列表表达式就是这样一个对象：它的所有值并不存储在相邻的内存单元中，但是可以随请求产生值。 python的文件对象被迭代工具使用时也可以一行一行的迭代，文件的内容并不在list里，而是根据迭代工具的需要进行读取。 以前的例子中sorted可以工作在字典上就是因为字典符合迭代协议。 任何列表解析都可以写成相应的循环：1&gt;&gt;&gt; squares = [x ** 2 for x in [1, 2, 3, 4, 5]] 等价于123&gt;&gt;&gt; squares = [] &gt;&gt;&gt; for x in [1, 2, 3, 4, 5]: # This is what a list comprehension does squares.append(x ** 2) # Both run the iteration protocol internally 但是列表解析，map，filter通常比for循环的写法执行速度更快，处理大数据集合时会获得性能提升。 python代码的主要准则是简单和稳定，然后才是性能。python也提供了衡量运行速度的工具time和timeit模块，profile模块用来确定性能瓶颈。 元组类似list，但不能修改，tuples与list一样是序列，但是是不可变类型的。通常被用来表示元素的固定集合。1&gt;&gt;&gt; T = (1, 2, 3, 4) # A 4-item tuple 元组也具备一些自己的方法12345&gt;&gt;&gt; T.index(4) # Tuple methods: 4 appears at offset 3 3 &gt;&gt;&gt; T.count(4) # 4 appears once 1&gt;&gt;&gt; T = (2,) + T[1:] # Make a new tuple for a new value 元组，与列表和字典相似，也支持混合数据类型和嵌套。但是它是不可变的不能增长或缩减。1&gt;&gt;&gt; T = 'spam', 3.0, [11, 22, 33] 文件文件对象是Python操作外部文件的主要接口。 文件对象是一个核心类型但是没有专门用来创建这个对象的语法，内建的open函数接受一个外部文件名和可选的处理模式字符串可以创建一个文件对象。123456&gt;&gt;&gt; f = open('data.txt', 'w') # Make a new file in output mode ('w' is write) &gt;&gt;&gt; f.write('Hello\n') # Write strings of characters to it 6 &gt;&gt;&gt; f.write('world\n') # Return number of items written in Python 3.X 6 &gt;&gt;&gt; f.close() # Close to flush output buffers to disk 无论文件中存储的是什么数据类型，脚本中的文件内容总是一个字符串。1234&gt;&gt;&gt; f = open('data.txt') # 'r' (read) is the default processing mode &gt;&gt;&gt; text = f.read() # Read entire file into a string &gt;&gt;&gt; text 'Hello\nworld\n' 文件对象还提供了很多其他的方法，read接受一个最大读入的字节或字符数量，readline一次读一行。 但是实际上最好的读入文件的方法是不是用read方法，文件对象提供了一个迭代器可以自动的为for循环和其它上下文按行读入：1&gt;&gt;&gt; for line in open('data.txt'): print(line) 二进制文件 python2中使用文件的8bit字节自然表示。python2中字符串会被原封不动的写入到文本文件中，不会自动编码。python3中依赖于平台的Unicode默认编码。Python3中文本文件中的字符串总是会被编码。python3中的文本和二进制文件有严格地区分，文本文件表示其内容会作为str字符串，并且在写入和读出时自动进行unicode编码和解码。而二进制文件的内容是bytes类型的字符串，允许无改变的访问文件内容。 在处理媒体文件，访问C语言创建的数据文件时二进制文件是很有用的。例如python的struct模块可以用来创建或解包二进制数据包1234567&gt;&gt;&gt; import struct &gt;&gt;&gt; packed = struct.pack('&gt;i4sh', 7, b'spam', 8) # Create packed binary data &gt;&gt;&gt; packed # 10 bytes, not objects or text b'\x00\x00\x00\x07spam\x00\x08' &gt;&gt;&gt; file = open('data.bin', 'wb') # Open binary output file &gt;&gt;&gt; file.write(packed) # Write packed binary data 10 &gt;&gt;&gt; file.close() Unicode文本文件如果要访问包含与默认编码不同的非ASCII的Unicode文本的文件时只需要在打开文件时传入一个编码名称的参数。python在读出和写入时会自动使用提供的编码进行编解码。一般情况下自动的编解码正是我们想要的，但如果想一探真正存储在文件中的内容时可以使用二进制模式打开文件。手工进行编解码。python2中的方法几乎相同，Unicode字符串会使用u前缀显示，unicode文本文件必须使用codecs.open打开，这个方法与python3的open一样接受一个编码名称参数。1234567&gt;&gt;&gt; import codecs &gt;&gt;&gt; codecs.open('unidata.txt', encoding='utf8').read() # 2.X: read/decode text u'sp\xc4m' &gt;&gt;&gt; open('unidata.txt', 'rb').read() # 2.X: read raw bytes 'sp\xc3\x84m' &gt;&gt;&gt; open('unidata.txt').read() # 2.X: raw/undecoded too 'sp\xc3\x84m' 其它文件类型的工具open用于大多数的文件操作python还提供多种工具用于：管道，FIFO，sockets，keyed-access files, persistent object shelves, descriptor-based files, relational and object-oriented database interfaces 其它核心类型集合 无序的单一集合，不可变对象： 123456&gt;&gt;&gt; X = set('spam') # Make a set out of a sequence in 2.X and 3.X &gt;&gt;&gt; Y = &#123;'h', 'a', 'm'&#125; # Make a set with set literals in 3.X and 2.7 &gt;&gt;&gt; X, Y # A tuple of two sets without parentheses (&#123;'m', 'a', 'p', 's'&#125;, &#123;'m', 'a', 'h'&#125;) &gt;&gt;&gt; X &amp; Y # Intersection &#123;'m', 'a'&#125; &gt;&gt;&gt; X | Y # Union &#123;'m', 'h', 'a', 'p', 's'&#125; &gt;&gt;&gt; X - Y # Difference 集合常被用作去重操作，寻找差异，不排序的相等比较等： 123456&gt;&gt;&gt; list(set([1, 2, 1, 3, 1])) # Filtering out duplicates (possibly reordered) [1, 2, 3] &gt;&gt;&gt; set('spam') - set('ham') # Finding differences in collections &#123;'p', 's'&#125; &gt;&gt;&gt; set('spam') == set('asmp') # Order-neutral equality tests (== is False) True 支持成员关系测试：12&gt;&gt;&gt; 'p' in set('spam'), 'p' in 'spam', 'ham' in ['eggs', 'spam', 'ham'] (True, True, True) python还新增了一些新的数值类型：小数（固定精度的浮点数），分数python具有布尔类型和None类型12345678&gt;&gt;&gt; 1 &gt; 2, 1 &lt; 2 # Booleans (False, True) &gt;&gt;&gt; bool('spam') # Object's Boolean value True &gt;&gt;&gt; X = None # None placeholder &gt;&gt;&gt; print(X) None python中不建议根据对象的类型进行编码，会降低代码的适应性1234567891011# In Python 2.X: &gt;&gt;&gt; type(L) # Types: type of L is list type object &lt;type 'list'&gt; &gt;&gt;&gt; type(type(L)) # Even types are objects &lt;type 'type'&gt; # In Python 3.X: &gt;&gt;&gt; type(L) # 3.X: types are classes, and vice versa &lt;class 'list'&gt; &gt;&gt;&gt; type(type(L)) # See Chapter 32 for more on class types &lt;class 'type'&gt; 用于测试对象的类型的方法：1234567891011&gt;&gt;&gt; if type(L) == type([]): # Type testing, if you must... print('yes') yes &gt;&gt;&gt; if type(L) == list: # Using the type name print('yes') yes &gt;&gt;&gt; if isinstance(L, list): # Object-oriented tests print('yes') yes 用户自定义的类数值类型python内部数据是用对象的形式表示的：python提供的内部对象或使用python工具和其它语言创建的对象。 python内部的数值类型并不是单独的一个类型，而是一系列相似的类型： 整数与浮点数对象 复数对象 固定精度的小数对象 分数对象 集合对象 布尔对象 内建函数和模块，round,math,random等 表达式；无限精度的整数；位操作；十六进制，八进制和二进制格式。 第三方扩展：vectors, libraries, visualization, plotting等 数值字符串 无限大小的整数：1234, ?24, 0, 99999999999999 浮点数：1.23, 1., 3.14e-10, 4E210, 4.0e+210 #在Cpython中使用C语言的double实现。 python3中的八进制，十六进制与二进制数字：0o177, 0x9ff, 0b101010 python2中的八进制，十六进制与二进制数字：177, 0o177, 0x9ff, 0b101010 复数：3+4j, 3.0+4.0j, 3J 集合：set(&#39;spam&#39;), {1, 2, 3, 4} 小数与分数：Decimal(&#39;1.0&#39;), Fraction(1, 3) 布尔类型：bool(X), True, False 整数以十进制数字字符串的写法出现，可带正负号，无穷精度。带一个小数点，或带科学技术标志e或E时python会将它变成一个浮点数对象，用在表达式中时将启用浮点数的运算法则，其精度与用来build python解释器的C编译器所给定的双精度一样。 十六进制 0x/0X开头+0-9和A-F大小写均可，八进制0o/0O+0-7，二进制0b/0B+0-1。 所有这些常量都产生一个整数对象，hex(I),oct(I),bin(I)把一个整数I转换成相应进制的字符串。int(str,base)将给定进制的字符串转换成一个整数。 python2中的整数包括正常整数（32位）与long整数，当需要更高精度整数时会自动进行转换。python3中只有一种整数类型，自动支持了无限精度，这个改变不会影响应用，除非应用中做了针对python2的long整型的类型检测。 十六进制，八进制，二进制数值字符串：只是整型对象值的不同语法表示，可以使用内建函数hex(I),oct(I)和bin(I)将整数转换成相应的表示字符串，或int(str, base)将runtime的字符串转化为给定base的整型数值。 复数，包括实部和虚部，实部是可选的，实部+虚部j/J的方式，或通过complex(real,imag)来创建。 内建数值工具 表达式操作符：+, -, *, /, &gt;&gt;, **, &amp; etc. 内建数学函数：pow, abs, round, int, hex, bin etc. 工具模块：random, math etc. 表达式操作符优先级升高顺序： yield x 生成器函数发送协议lambda args: expression 生成匿名函数x if y else z 三元选择表达式x or yx and ynot xx in y , x not in y 成员关系x is y , x is not y 对象实体测试x &lt; y, x &lt;= y, x &gt; y, x &gt;= yx == y, x!=yx | yx ^ yx &amp; yx &lt;&lt; y, x &gt;&gt; yx + y, x - y 加法/合并，减法/集合差集x * y , x % y , x / y , x // y 乘法/重复，余数/格式化，真除法，floor除法-x, +x 一元减法，识别~x 按位求补（取反）x ** y 幂运算x[i] 索引x[i:j:k] 分片x(…) 调用（函数，方法，类及其它可调用的）x.attr 属性引用(…) 元组，表达式，生成器表达式。[…] 列表，列表解析{…} 字典，集合，集合和字典解析。 python2中可以使用X != Y or X &lt;&gt; Y进行不等于测试python3中仅可以使用X != Ypython2中可以使用反引号X代替repr(X)将X转换为字符串显示python3中反引号被移除，只能使用str()或repr()python2和python3中X//Y (floor除法)均会舍弃小数部分保留整数，但是结果的类型与操作数类型有关。python2中X/Y传统除法对于整数运算舍弃小数取整，对于浮点数会保留小数python3中X/Y进行真除法运算，无论整数和浮点数都保留小数部分得到带小数的结果值。 […]语法用于列表初始化和列表解析表达式 (…)语法用于元组初始化，表达式分组与生成器表达式（列表解析的一种用于根据需要产生值）。 {…}语法用于字典初始化，集合初始化，字典与集合解析 yield与if/else语法在python2.5以后可用。 分片表达式X[I:J:K]与使用slice对象的索引相等X[slice(I, J, K)] 混合类型的数值在同一个表达式中共同使用时python会自动转换到最复杂的数值类型。 floor和truncate floor向下取整，小于真实结果的最近的一个整数 trunc向0取证 123456789101112131415161718192021222324&gt;&gt;&gt; import math &gt;&gt;&gt; math.floor(2.5) # Closest number below value 2 &gt;&gt;&gt; math.floor(-2.5) -3 &gt;&gt;&gt; math.trunc(2.5) # Truncate fractional part (toward zero) 2 &gt;&gt;&gt; math.trunc(-2.5) -2&gt;&gt;&gt; (5 / 2), (5 / 2.0), (5 / ?2.0), (5 / ?2) # 3.X true division (2.5, 2.5, ?2.5, ?2.5) &gt;&gt;&gt; (5 // 2), (5 // 2.0), (5 // ?2.0), (5 // ?2)# 3.X floor division (2, 2.0, ?3.0, ?3) &gt;&gt;&gt; (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0) # Both (3.0, 3.0, 3, 3.0)&gt;&gt;&gt; (5 / 2), (5 / 2.0), (5 / ?2.0), (5 / ?2) # 2.X classic division (differs) (2, 2.5, ?2.5, ?3) &gt;&gt;&gt; (5 // 2), (5 // 2.0), (5 // ?2.0), (5 // ?2)# 2.X floor division (same) (2, 2.0, ?3.0, ?3) &gt;&gt;&gt; (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0) # Both (3, 3.0, 3, 3.0) 复数十六进制，八进制，二进制的数值与转换位操作其它内置数学工具123456789101112131415161718192021222324252627&gt;&gt;&gt; import math&gt;&gt;&gt; math.pi, math.e # Common constants (3.141592653589793, 2.718281828459045) &gt;&gt;&gt; math.sin(2 * math.pi / 180) # Sine, tangent, cosine 0.03489949670250097&gt;&gt;&gt; math.sqrt(144), math.sqrt(2) # Square root (12.0, 1.4142135623730951) &gt;&gt;&gt; pow(2, 4), 2 ** 4, 2.0 ** 4.0 # Exponentiation (power) (16, 16, 16.0) &gt;&gt;&gt; abs(-42.0), sum((1, 2, 3, 4)) # Absolute value, summation (42.0, 10) &gt;&gt;&gt; min(3, 1, 2, 4), max(3, 1, 2, 4) # Minimum, maximum (1, 4)&gt;&gt;&gt; math.floor(2.567), math.floor(-2.567) # Floor (next-lower integer) (2, ?3) &gt;&gt;&gt; math.trunc(2.567), math.trunc(?2.567) # Truncate (drop decimal digits) (2, ?2) &gt;&gt;&gt; int(2.567), int(?2.567) # Truncate (integer conversion) (2, ?2) &gt;&gt;&gt; round(2.567), round(2.467), round(2.567, 2) # Round (Python 3.X version)(3, 2, 2.57) &gt;&gt;&gt; '%.1f' % 2.567, '&#123;0:.2f&#125;'.format(2.567) # Round for display (Chapter 7) ('2.6', '2.57')&gt;&gt;&gt; (1 / 3.0), round(1 / 3.0, 2), ('%.2f' % (1 / 3.0)) (0.3333333333333333, 0.33, '0.33') 例如计算开方有三种方法：1234567&gt;&gt;&gt; import math &gt;&gt;&gt; math.sqrt(144) # Module 12.0 &gt;&gt;&gt; 144 ** .5 # Expression 12.0 &gt;&gt;&gt; pow(144, .5) # Built-in 12.0 产生随机数12345678910111213141516171819202122&gt;&gt;&gt; import random &gt;&gt;&gt; random.random()0.5566014960423105 &gt;&gt;&gt; random.random() # Random floats, integers, choices, shuffles 0.051308506597373515&gt;&gt;&gt; random.randint(1, 10) 5 &gt;&gt;&gt; random.randint(1, 10) 9&gt;&gt;&gt; random.choice(['Life of Brian', 'Holy Grail', 'Meaning of Life']) 'Holy Grail' &gt;&gt;&gt; random.choice(['Life of Brian', 'Holy Grail', 'Meaning of Life']) 'Life of Brian' &gt;&gt;&gt; suits = ['hearts', 'clubs', 'diamonds', 'spades'] &gt;&gt;&gt; random.shuffle(suits) &gt;&gt;&gt; suits ['spades', 'hearts', 'diamonds', 'clubs'] &gt;&gt;&gt; random.shuffle(suits) &gt;&gt;&gt; suits ['clubs', 'diamonds', 'hearts', 'spades'] 其它数值类型小数对象import decimal 能修正浮点数不精确的现象。小数的上下文管理器，用于重新设定精度。1234567891011&gt;&gt;&gt; 0.1 + 0.1 + 0.1 - 0.3 # Python 3.3 5.551115123125783e-17&gt;&gt;&gt; from decimal import Decimal &gt;&gt;&gt; Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3') Decimal('0.0')&gt;&gt;&gt; Decimal('0.1') + Decimal('0.10') + Decimal('0.10') - Decimal('0.30') Decimal('0.00')&gt;&gt;&gt; Decimal(0.1) + Decimal(0.1) + Decimal(0.1) - Decimal(0.3) Decimal('2.775557561565156540423631668E-17') 设定全局的精度123456789&gt;&gt;&gt; import decimal &gt;&gt;&gt; decimal.Decimal(1) / decimal.Decimal(7) # Default: 28 digits Decimal('0.1428571428571428571428571429') &gt;&gt;&gt; decimal.getcontext().prec = 4 # Fixed precision &gt;&gt;&gt; decimal.Decimal(1) / decimal.Decimal(7) Decimal('0.1429') &gt;&gt;&gt; Decimal(0.1) + Decimal(0.1) + Decimal(0.1) - Decimal(0.3) # Closer to 0 Decimal('1.110E-17') 小数上下文管理器: 使用with上下文管理器语句临时的改变小数的精度。1234567891011&gt;&gt;&gt; import decimal &gt;&gt;&gt; decimal.Decimal('1.00') / decimal.Decimal('3.00') Decimal('0.3333333333333333333333333333') &gt;&gt;&gt; with decimal.localcontext() as ctx: ... ctx.prec = 2 ... decimal.Decimal('1.00') / decimal.Decimal('3.00') ... Decimal('0.33') &gt;&gt;&gt; decimal.Decimal('1.00') / decimal.Decimal('3.00') Decimal('0.3333333333333333333333333333') 分数类型分数实现了一个有理数对象，import fractions,保持精确性，并自动简化结果。类型转换和混合类型。12345678910&gt;&gt;&gt; from fractions import Fraction &gt;&gt;&gt; x = Fraction(1, 3) # Numerator, denominator &gt;&gt;&gt; y = Fraction(4, 6) # Simplified to 2, 3 by gcd&gt;&gt;&gt; x + y Fraction(1, 1) &gt;&gt;&gt; x ? y Fraction(?1, 3) &gt;&gt;&gt; x * y Fraction(2, 9) 也可以使用浮点数来创建分数对象：123456&gt;&gt;&gt; Fraction('.25') Fraction(1, 4) &gt;&gt;&gt; Fraction('1.25') Fraction(5, 4) &gt;&gt;&gt; Fraction('.25') + Fraction('1.25') Fraction(3, 2) 分数的转换：1234&gt;&gt;&gt; (2.5).as_integer_ratio() # float object method (5, 2) &gt;&gt;&gt; f = 2.5 &gt;&gt;&gt; z = Fraction(*f.as_integer_ratio()) # Convert float -&gt; fraction: two args *符号是一种可以将元组展开成单独参数的特殊语法。12345678910111213&gt;&gt;&gt; z # Same as Fraction(5, 2) Fraction(5, 2)&gt;&gt;&gt; x # x from prior interaction Fraction(1, 3) &gt;&gt;&gt; x + z Fraction(17, 6) # 5/2 + 1/3 = 15/6 + 2/6 &gt;&gt;&gt; float(x) # Convert fraction -&gt; float 0.3333333333333333 &gt;&gt;&gt; float(z) 2.5 &gt;&gt;&gt; float(x + z) 2.8333333333333335 将浮点数转换为分数的两种方法：123456789101112&gt;&gt;&gt; Fraction.from_float(1.75) # Convert float -&gt; fraction: other way Fraction(7, 4)&gt;&gt;&gt; Fraction(*(1.75).as_integer_ratio()) Fraction(7, 4)&gt;&gt;&gt; (4.0 / 3).as_integer_ratio() # Precision loss from float (6004799503160661, 4503599627370496) &gt;&gt;&gt; x Fraction(1, 3) &gt;&gt;&gt; a = x + Fraction(*(4.0 / 3).as_integer_ratio()) &gt;&gt;&gt; a Fraction(22517998136852479, 13510798882111488) 通过限制分母的最大值简化分数。12&gt;&gt;&gt; a.limit_denominator(10) # Simplify to closest fraction Fraction(5, 3) 集合唯一的不可变对象的一个无序集合，一个项在集合中只能出现一次。可迭代，可根据需要增长缩短，能包含各种对象类型。1234567x = set(‘abcde’)‘e’ in xx - y 差集x | y 并集x &amp; y 交集x ^ y 异或x &gt; y , x &lt; y 超级，子集。 成员测试：1234&gt;&gt;&gt; 'e' in x # Membership (sets) True &gt;&gt;&gt; 'e' in 'Camelot', 22 in [11, 22, 33] # But works on other types too (True, True) 集合的方法： 123456x.intersection(y) 与 x &amp; y相同z.add('SPAM') 增加一个项目z.remove('b') 删除一个项目z.update(set['X','Y']) 合并s.union()s.issubset() 集合是一个可迭代的容器，可以被用于len，for循环和列表解析 1&gt;&gt;&gt; for item in set('abc'): print(item * 3) python3与python2.7中，集合表示为{1,2,3,4}无值的字典，等价于set([1, 2, 3, 4])。python2.7与python3都可以接受这两种方式的初始化，但是显示方法会不同。 空集合必须通过set来创建。 注意：集合只能包含不可变的对象类型，因此列表和字典不能嵌入集合，元组可以嵌入。 python3与python2.7中集合的解析语法：12345678910&gt;&gt;&gt; &#123;x ** 2 for x in [1, 2, 3, 4]&#125; # 3.X/2.7 set comprehension &#123;16, 1, 4, 9&#125;&gt;&gt;&gt; &#123;x for x in 'spam'&#125; # Same as: set('spam') &#123;'m', 's', 'p', 'a'&#125; &gt;&gt;&gt; &#123;c * 4 for c in 'spam'&#125; # Set of collected expression results &#123;'pppp', 'aaaa', 'ssss', 'mmmm'&#125; &gt;&gt;&gt; &#123;c * 4 for c in 'spamham'&#125; &#123;'pppp', 'aaaa', 'hhhh', 'ssss', 'mmmm'&#125; 集合的用途： 去除list中重复项 12345678910111213&gt;&gt;&gt; list(set(['yy', 'cc', 'aa', 'xx', 'dd', 'aa'])) # But order may change ['cc', 'xx', 'yy', 'dd', 'aa']&gt;&gt;&gt; set([1, 3, 5, 7]) - set([1, 2, 4, 5, 6]) # Find list differences &#123;3, 7&#125; &gt;&gt;&gt; set('abcdefg') - set('abdghij') # Find string differences &#123;'c', 'e', 'f'&#125; &gt;&gt;&gt; set('spam') - set(['h', 'a', 'm']) # Find differences, mixed &#123;'p', 's'&#125; &gt;&gt;&gt; set(dir(bytes)) - set(dir(bytearray)) # In bytes but not bytearray &#123;'__getnewargs__'&#125; &gt;&gt;&gt; set(dir(bytearray)) - set(dir(bytes)) &#123;'append', 'copy', '__alloc__', '__imul__', 'remove', 'pop', 'insert', ...more...] 无序的集合比较 123456789&gt;&gt;&gt; L1, L2 = [1, 3, 5, 2, 4], [2, 5, 3, 4, 1] &gt;&gt;&gt; L1 == L2 # Order matters in sequences False &gt;&gt;&gt; set(L1) == set(L2) # Order-neutral equality True &gt;&gt;&gt; sorted(L1) == sorted(L2) # Similar but results ordered True &gt;&gt;&gt; 'spam' == 'asmp', set('spam') == set('asmp'), sorted('spam') == sorted('asmp') (False, True, True) 遍历图形或回还结构时用来记录访问过的位置。 布尔型bool有两个值True False123456789101112&gt;&gt;&gt; type(True) &lt;class 'bool'&gt; &gt;&gt;&gt; isinstance(True, int) True&gt;&gt;&gt; True == 1 # Same value True &gt;&gt;&gt; True is 1 # But a different object: see the next chapter False &gt;&gt;&gt; True or False # Same as: 1 or 0 True &gt;&gt;&gt; True + 4 # (Hmmm) 5 数字扩展NumPy动态类型简介python中没有声明语句，python中变量的类型是在运行中自动决定的。 变量的创建: 第一次赋值时创建它，之后的赋值改变变量名的值。 python变量永远不会有任何和他关联的类型信息，类型的概念在于对象中而不是变量名。 变量出现在表达式中时马上会被该变量引用的对象代替。变量必须在使用前明确的赋值，引用未赋值的变量会出错。 变量被赋予了新的对象值时，之前的对象内存会被回收-垃圾收集。 共享引用123a = 3 b = a 两个变量名引用到了同一个对象a = a + 2 此后b的值并不会改变。 对于可在原地修改的对象，共享引用要小心，例如列表1234567L1 = [2,3,4]L2 = L1L1[0] = 24 #此后L2的值也会发生改变L1 = [2,3,4]L2 = L1[:]L1[0] = 24 #此时L2是L1的一个拷贝 对于字典和集合使用import copy 复制。123import copy X = copy.copy(Y) # Make top-level "shallow" copy of any object Y X = copy.deepcopy(Y) # Make deep copy of any object Y: copy all nested parts 共享引用和相等测试： 由于python的引用模型，有两种用于检测相等性的方法：1234L = [1,2,3] M = LL == M 测试被引用的对象是否有相同的值，不一定是相同的对象L is M 测试两个变量名是否精确的指向同一个对象。内部实现上仅检测引用的指针是否相同 比较下面两个例子：12345678910111213&gt;&gt;&gt; L = [1, 2, 3] &gt;&gt;&gt; M = [1, 2, 3] # M and L reference different objects &gt;&gt;&gt; L == M # Same values True &gt;&gt;&gt; L is M # Different objects False&gt;&gt;&gt; X = 42 &gt;&gt;&gt; Y = 42 # Should be two different objects &gt;&gt;&gt; X == Y True &gt;&gt;&gt; X is Y # Same object anyhow: caching at work! 实际上X与Y指向相同的对象，这是因为小整数和字符串会被缓存和重用。True 查看某对象的引用次数：123&gt;&gt;&gt; import sys &gt;&gt;&gt; sys.getrefcount(1) # 647 pointers to this shared piece of memory 647 字符串字符串：一个有序的字符集合。 python没有单个字符的类型，可以使用一个字符的字符串，python字符串被划分为不可变序列类别。 python3中有3种字符串类型：str用作unicode文本（包括ascii），bytes用作二进制数据（包括encoded的文本），bytearray是bytes的可变形式。python3中的文件工作在两种模式：text文本模式：内容表示为str字符串，实现了unicode编码，二进制文件模式：用来处理原始的bytes不做数据转换。python2中unocode字符串表示unicode文本，str字符串处理8bit的文本和二进制数据，bytearray在python2.6之后可用。python2中普通文件的内容只是bytes，表示为str字符串。codecs模块可以打开unicode文本文件处理编码，将文件内容表示为unicode字符串对象。 字符串基础类似C语言中的字符数组，但是包含了一些更高级的处理工具，python中没有字符类型，只能使用一个字符的字符串。 python的字符串是不可变对象，从左到右的位置顺序固定并且不能在原地更改（序列对象的一种）。 常见的字符串常量和表达式1234567891011121314151617181920212223242526272829S = '' 空字符串S = "spam's" 双引号，与单引号相同S = 's\np\ta\x00m' 转义序列S = """...multiline...""" 三引号字符串块S = r'\temp\spam' Raw字符串，没有转移序列B = b'sp\xc4m' Byte字符串U = u'sp\u00c4m' Unicode字符串S1 + S2 合并S * 3 重复 S[i] 索引S[i:j] 分片len(S) 求长度"a %s parrot" % kind 字符串格式化表达式 "a &#123;0&#125; parrot".format(kind) 字符串格式化方法 S.find('pa') S.rstrip() S.replace('pa', 'xx') S.split(',') 字符串方法调用S.isdigit() S.lower() S.endswith('spam') 'spam'.join(strlist) S.encode('latin-1') B.decode('utf8')for x in S: print(x) 'spam' in S [c * 2 for c in S] map(ord, S)re.match('sp(.*)am', line) 模式匹配 字符串常量代码中的各种字符串使用方法：单引号 ‘spa“m’双引号 “spa&#39;m”三引号 &#39;&#39;&#39;...spam...&#39;&#39;&#39;, &quot;&quot;&quot;...spam...&quot;&quot;&quot;转义字符 “s\tp\na\0m”Raw字符串 r&quot;C:\new\test.spm&quot; 抑制转义字符python3和python2.6+中的byte字符串 b&#39;sp\x01am&#39;python2和python3.3+中的unicode字符串 u&#39;eggs\u0020spam&#39; 包围python字符串的单引号和双引号是可以互换的。1&gt;&gt;&gt; 'shrubbery', "shrubbery" 当需要在字符串中包含一种引号时就是用另一种引号包围整个字符串。1&gt;&gt;&gt; 'shrubbery', "shrubbery" python自动在任意表达式中合并相邻的字符串常量，也可以增加+操作符明确的表示这是一个合并操作。例如：123&gt;&gt;&gt; title = "Meaning " 'of' " Life"&gt;&gt;&gt; title 'Meaning of Life' 在字符串间添加逗号会得到一个元组结果：12&gt;&gt;&gt; 'knight\'s', "knight\"s" ("knight's", 'knight"s') 转义序列能在字符串中嵌入不容易通过键盘输入的字节，最终会被一个单字符替代。print()会将其解释。12345&gt;&gt;&gt; s = 'a\nb\tc'&gt;&gt;&gt; s 'a\nb\tc'&gt;&gt;&gt; len(s) 5 Python中并不使用nullbyte结束字符串，而是将字符串和它的长度全部存储在内存中。 python提供的转义字符序列：123456789101112131415161718\newline 忽略(continuation line) \\ 保留\ \' 保留单引号\" 保留双引号\a 响铃\b 退格 \f 换页 \n 换行 \r 回车 \t 水平制表符 \v 垂直制表符\xhh hh为十六进制值 (exactly 2 digits) \ooo 八进制 \0 Null: binary 0 character (doesn’t end string) \N&#123; id &#125; Unicode database ID \uhhhh Unicode character with 16-bit hex value \Uhhhhhhhh Unicode character with 32-bit hex valuea \other 不转义 (keeps both \ and other) 如果python不能识别\符号之后的字符作为转义码，会将\字符作为一个字符保留在字符串中。但是不要依赖于这种形式，如果要保留\使用\或raw字符串。 raw字符串会抑制转义序列：1234567myfile = open(r'C:\new\text.dat', 'w')ormyfile = open('C:\\new\\text.dat', 'w')&gt;&gt;&gt; path = r'C:\new\text.dat' &gt;&gt;&gt; path # Show as Python code 'C:\\new\\text.dat' raw字符串也常被用于正则表达式(re模块)。 三引号中的多行字符串块（单引号或双引号），可以包含其它的单引号或双引号，直到出现下一个三引号时结束。 三引号字符串将包含所有的被包围的文本，包括中间行的注释。所以如果需要注释，添加在三引号之前或之后。 三引号可以在任何需要多行文本的位置使用：如程序中内嵌的多行的错误消息，HTML，XML或JSON代码等。 三引号也常用作文档字符串 三引号也可用作临时注释多行代码的作用。 字符串操作1234567&gt;&gt;&gt; len('abc') # Length: number of items 3 &gt;&gt;&gt; 'abc' + 'def' # Concatenation: a new string 'abcdef' &gt;&gt;&gt; 'Ni!' * 4 # Repetition: like "Ni!" + "Ni!" + ... 'Ni!Ni!Ni!Ni!'&gt;&gt;&gt; print('-' * 80) # 80 dashes, the easy way 注意：+操作符用于连接字符串时如果表达式中同时有字符串和数字会出现错误：’abc’+9 raises。12345&gt;&gt;&gt; myjob = "hacker" &gt;&gt;&gt; for c in myjob: print(c, end=' ') # Step through items, print each (3.X form)h a c k e r &gt;&gt;&gt; "k" in myjob # FoundTrue 索引 S[i] 第一个元素索引为0,S[0]获取第一个元素 负索引意味着从最后反向计数，S[?2]获取倒数第二个元素，等价于S[len(S)?2] 分片S[i:j] i不包含在结果分片内 S[:]默认从0到字符串长度 S[i:j:k] k为步长。S[::-1]实际将反转字符串。 1234567891011121314&gt;&gt;&gt; S = 'spam' &gt;&gt;&gt; S[0], S[?2] # Indexing from front or end ('s', 'a') &gt;&gt;&gt; S[1:3], S[1:], S[:?1] # Slicing: extract a section ('pa', 'pam', 'spa')&gt;&gt;&gt; S = 'abcdefghijklmnop' &gt;&gt;&gt; S[1:10:2] # Skipping items 'bdfhj' &gt;&gt;&gt; S[::2] 'acegikmo'&gt;&gt;&gt; S = 'hello' &gt;&gt;&gt; S[::?1] # Reversing items 'olleh' 以下两个操作是等价的1234&gt;&gt;&gt; 'spam'[1:3] # Slicing syntax 'pa' &gt;&gt;&gt; 'spam'[slice(1, 3)] # Slice objects with index syntax + object 'pa' 字符串的转换 +操作符不能连接字符串与数字，需要进行类型转换: int() str() eval() 123456789101112131415161718192021&gt;&gt;&gt; int("42"), str(42) # Convert from/to string (42, '42') &gt;&gt;&gt; repr(42) # Convert to as-code string '42'&gt;&gt;&gt; print(str('spam'), repr('spam')) # 2.X: print str('spam'), repr('spam') spam 'spam'&gt;&gt;&gt; str('spam'), repr('spam') # Raw interactive echo displays ('spam', "'spam'")&gt;&gt;&gt; S = "42" &gt;&gt;&gt; I = 1 &gt;&gt;&gt; S + I TypeError: Can't convert 'int' object to str implicitly &gt;&gt;&gt; int(S) + I # Force addition 43 &gt;&gt;&gt; S + str(I) # Force concatenation '421'&gt;&gt;&gt; str(3.1415), float("1.5") ('3.1415', 1.5) 字符代码转换：ord()转化为ascii码， chr()将ascii转换为字符 123456789&gt;&gt;&gt; ord('s') 115 &gt;&gt;&gt; chr(115) 's'&gt;&gt;&gt; int('1101', 2) # Convert binary to integer: built-in 13 &gt;&gt;&gt; bin(13) # Convert integer to binary: built-in '0b1101' 字符串是不可原地修改的只能生成新的对象赋值给原来的变量12345678910111213&gt;&gt;&gt; S = 'spam' &gt;&gt;&gt; S[0] = 'x' # Raises an error! TypeError: 'str' object does not support item assignment&gt;&gt;&gt; S = S + 'SPAM!' # To change a string, make a new one &gt;&gt;&gt; S 'spamSPAM!' &gt;&gt;&gt; S = S[:4] + 'Burger' + S[?1] &gt;&gt;&gt; S 'spamBurger!'&gt;&gt;&gt; S = 'splot' &gt;&gt;&gt; S = S.replace('pl', 'pamal') 字串替换 也可以使用字符串格式化表达式构造一个新的字符串 字符串方法1234567891011121314151617181920212223242526272829303132333435363738394041424344String method calls in Python 3.3 S.capitalize() S.ljust(width [, fill]) S.casefold() S.lower() S.center(width [, fill]) S.lstrip([chars]) S.count(sub [, start [, end]]) S.maketrans(x[, y[, z]]) S.encode([encoding [,errors]]) S.partition(sep) S.endswith(suffix [, start [, end]]) S.replace(old, new [, count]) S.expandtabs([tabsize]) S.rfind(sub [,start [,end]]) S.find(sub [, start [, end]]) S.rindex(sub [, start [, end]]) S.format(fmtstr, *args, **kwargs) S.rjust(width [, fill]) S.index(sub [, start [, end]]) S.rpartition(sep) S.isalnum() S.rsplit([sep[, maxsplit]]) S.isalpha() S.rstrip([chars]) S.isdecimal() S.split([sep [,maxsplit]])S.isdigit() S.splitlines([keepends]) S.isidentifier() S.startswith(prefix [, start [, end]]) S.islower() S.strip([chars]) S.isnumeric() S.swapcase() S.isprintable() S.title() S.isspace() S.translate(map) S.istitle() S.upper() S.isupper() S.zfill(width) S.join(iterable) 使用字符串方法代替：1234567891011121314151617181920212223&gt;&gt;&gt; S = 'spammy' &gt;&gt;&gt; S = S[:3] + 'xx' + S[5:] # Slice sections from S &gt;&gt;&gt; S 'spaxxy'&gt;&gt;&gt; S = 'spammy' &gt;&gt;&gt; S = S.replace('mm', 'xx') # Replace all mm with xx in S&gt;&gt;&gt; 'aa$bb$cc$dd'.replace('$', 'SPAM')&gt;&gt;&gt; S = 'xxxxSPAMxxxxSPAMxxxx' &gt;&gt;&gt; where = S.find('SPAM') # Search for position &gt;&gt;&gt; where # Occurs at offset 4 4 &gt;&gt;&gt; S = S[:where] + 'EGGS' + S[(where+4):] &gt;&gt;&gt; S 'xxxxEGGSxxxxSPAMxxxx'&gt;&gt;&gt; S = 'xxxxSPAMxxxxSPAMxxxx' &gt;&gt;&gt; S.replace('SPAM', 'EGGS') # Replace all 'xxxxEGGSxxxxEGGSxxxx' &gt;&gt;&gt; S.replace('SPAM', 'EGGS', 1) # Replace one 'xxxxEGGSxxxxSPAMxxxx' 每次连接和替换操作都会创建新的字符串对象，如果对一个非常大的字符串进行多次操作这可能是一个性能瓶颈为提高性能可以将字符串转换成支持原地修改的对象后操作：123456789101112&gt;&gt;&gt; S = 'spammy' &gt;&gt;&gt; L = list(S) #内建函数list可以从序列创建一个列表&gt;&gt;&gt; L ['s', 'p', 'a', 'm', 'm', 'y']&gt;&gt;&gt; L[3] = 'x' # Works for lists, not strings&gt;&gt;&gt; L ['s', 'p', 'a', 'x', 'x', 'y']&gt;&gt;&gt; S = ''.join(L) #完成操作后再转换回字符串。delimiter.join方法将参数中列表的值使用delimiter连接起来，使用join通常比单独的进行子串连接操作运行更快速&gt;&gt;&gt; 'SPAM'.join(['eggs', 'sausage', 'ham', 'toast']) 'eggsSPAMsausageSPAMhamSPAMtoast' 文本解析12345678910111213141516171819202122232425262728&gt;&gt;&gt; line = 'aaa bbb ccc' &gt;&gt;&gt; col1 = line[0:3] &gt;&gt;&gt; col3 = line[8:]&gt;&gt;&gt; line = 'aaa bbb ccc' &gt;&gt;&gt; cols = line.split() #默认使用withespace，1或多个空格，tab，newline&gt;&gt;&gt; cols ['aaa', 'bbb', 'ccc']&gt;&gt;&gt; line = 'bob,hacker,40' &gt;&gt;&gt; line.split(',') ['bob', 'hacker', '40']&gt;&gt;&gt; line = "i'mSPAMaSPAMlumberjack" &gt;&gt;&gt; line.split("SPAM") #可以使用多个字符["i'm", 'a', 'lumberjack']&gt;&gt;&gt; line = "The knights who say Ni!\n" &gt;&gt;&gt; line.rstrip() 'The knights who say Ni!' #去除空白字符&gt;&gt;&gt; line.upper() 'THE KNIGHTS WHO SAY NI!\n' #转换为大写&gt;&gt;&gt; line.isalpha() False &gt;&gt;&gt; line.endswith('Ni!\n') True &gt;&gt;&gt; line.startswith('The') True 包含12&gt;&gt;&gt; line.find('Ni') != ?1 # Search via method call or expression True 等价于12&gt;&gt;&gt; 'Ni' in line True 结尾123&gt;&gt;&gt; sub = 'Ni!\n' &gt;&gt;&gt; line.endswith(sub) # End test via method call or slice True 等价于12&gt;&gt;&gt; line[-len(sub):] == sub True 要使用基于pattern的文本处理必须使用python的re模块字符串格式化的两种风格 字符串格式化表达式：&#39;...%s...&#39; % (values)1'That is %d %s bird!' % (1, 'dead') 格式化字符串时，Python使用一个字符串作为模板。模板中有格式符，这些格式符为真实值预留位置，并说明真实数值应该呈现的格式。Python用一个tuple(其实可以不写tuple括号也可以)将多个值传递给模板，每个值对应一个格式符。 操作符%左边提供一个包含多个以%开头的转换目标的格式化字符串，右边提供要插入格式化字符串中的对象组成的元组。12345&gt;&gt;&gt; exclamation = 'Ni' &gt;&gt;&gt; 'The knights who say %s!' % exclamation # String substitution 'The knights who say Ni!' &gt;&gt;&gt; '%d %s %g you' % (1, 'spam', 4.0) # Type-specific substitutions '1 spam 4 you' 可用的字符串格式符：格式符为真实值预留位置，并控制显示的格式。123456789101112131415%s 字符串 (采用str()的显示)%r 字符串 (采用repr()的显示)%c 单个字符%b 二进制整数%d 十进制整数%i 十进制整数%o 八进制整数%x 十六进制整数%e 指数 (基底写为e)%E 指数 (基底写为E)%f 浮点数%F 浮点数，与上相同%g 指数(e)或浮点数 (根据显示长度)%G 指数(E)或浮点数 (根据显示长度)要是想输出%则要使用%%进行转义操作. 转换目标的通用语法：%[(keyname)][flags][width][.precision]typecode 其中的：123456789keyname:用于作为表达式右边字典的索引flags: 可以有+,-,’ ‘或0。 -表示左对齐。 +表示显示数字的正号。 ’ ‘为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。 0表示使用0填充满width的宽度。width: 替代文本的显示最小宽度，如果实际的值超出这个宽度，宽度将会被扩充。[.precision]表示浮点数小数点后的精度width, precision为两个整数。我们可以利用*，来使用元组中的数值动态代入这两个量。 123456789101112131415161718&gt;&gt;&gt; x = 1234 &gt;&gt;&gt; res = 'integers: ...%d...%?6d...%06d' % (x, x, x) &gt;&gt;&gt; res 'integers: ...1234...1234 ...001234'&gt;&gt;&gt; x = 1.23456789 &gt;&gt;&gt; '%e | %f | %g' % (x, x, x) '1.234568e+00 | 1.234568 | 1.23457' &gt;&gt;&gt; '%E' % x '1.234568E+00'&gt;&gt;&gt; '%?6.2f | %05.2f | %+06.1f' % (x, x, x) '1.23 | 01.23 | +001.2' &gt;&gt;&gt; '%s' % x, str(x) ('1.23456789', '1.23456789')&gt;&gt;&gt; '%f, %.2f, %.*f' % (1/3.0, 1/3.0, 4, 1/3.0) '0.333333, 0.33, 0.3333' 基于字典的字符串格式化：允许左边的转换目标引用右边的字典中的键值来提取对应值： &#39;%(qty)d more %(food)s&#39; % {&#39;qty&#39;: 1, &#39;food&#39;: &#39;spam&#39;} 12345678910&gt;&gt;&gt; reply = """ Greetings... Hello %(name)s! Your age is %(age)s """ &gt;&gt;&gt; values = &#123;'name': 'Bob', 'age': 40&#125; # Build up values to substitute &gt;&gt;&gt; print(reply % values) # Perform substitutions小技巧：与vars()配合使用访问变量&gt;&gt;&gt; food = 'spam' &gt;&gt;&gt; qty = 10 &gt;&gt;&gt; vars() &#123;'food': 'spam', 'qty': 10, ...plus built-in names set by Python... &#125;&gt;&gt;&gt; '%(qty)d more %(food)s' % vars() # Variables are keys in vars() '10 more spam' 字符串格式化方法调用：’…{}…’.format(values) python2.6和python3中引入这种方式,字符串格式化调用方法： 按位置： 12template = '&#123;0&#125;, &#123;1&#125; and &#123;2&#125;'template.format('spam', 'ham', 'eggs') 按关键字： 12template = '&#123;motto&#125;, &#123;pork&#125; and &#123;food&#125;'template.format(motto='spam', pork='ham', food='eggs') 按两种方式： 12template = '&#123;motto&#125;, &#123;0&#125; and &#123;food&#125;'template.format('ham', motto='spam', food='eggs') 相对位置 12template = '&#123;&#125;, &#123;&#125; and &#123;&#125;'template.format('spam', 'ham', 'eggs') 转换为格式化字符串的方式：1234567&gt;&gt;&gt; template = '%s, %s and %s' # Same via expression &gt;&gt;&gt; template % ('spam', 'ham', 'eggs') 'spam, ham and eggs' 使用dict()将关键字参数列表转换为字典：&gt;&gt;&gt; template = '%(motto)s, %(pork)s and %(food)s' &gt;&gt;&gt; template % dict(motto='spam', pork='ham', food='eggs') 'spam, ham and eggs' 也可以用来赋值：X = &#39;{motto}, {0} and {food}&#39;.format(42, motto=3.14, food=[1, 2]) 格式化字符串中也可以使用索引，只有正数索引有效123456789101112'My &#123;1[kind]&#125; runs &#123;0.platform&#125;'.format(sys, &#123;'kind': 'laptop'&#125;) 'My &#123;map[kind]&#125; runs &#123;sys.platform&#125;'.format(sys=sys, map=&#123;'kind': 'laptop'&#125;) &gt;&gt;&gt; somelist = list('SPAM') &gt;&gt;&gt; somelist ['S', 'P', 'A', 'M'] &gt;&gt;&gt; 'first=&#123;0[0]&#125;, third=&#123;0[2]&#125;'.format(somelist) 'first=S, third=A' &gt;&gt;&gt; 'first=&#123;0&#125;, last=&#123;1&#125;'.format(somelist[0], somelist[-1]) # [-1] fails in fmt 'first=S, last=M' &gt;&gt;&gt; parts = somelist[0], somelist[-1], somelist[1:3] # [1:3] fails in fmt &gt;&gt;&gt; 'first=&#123;0&#125;, last=&#123;1&#125;, middle=&#123;2&#125;'.format(*parts) # Or '&#123;&#125;' in 2.7/3.1+ # *parts将元组转换为单独的函数列表"first=S, last=M, middle=['P', 'A']" 高级格式化方法调用语法，用作特定格式化输出：1234567891011&#123;fieldname component !conversionflag :formatspec&#125; ，实际使用时没有中间的空格fieldname 可选的数字或关键字，用于标识一个参数component 可选的用于获取参数的属性或索引“.name” or “[index]”conversionflag 如果存在这个参数以!开头后跟r, s, a分别表示对值调用repr, str 或 ascii内建函数。formatspec 如果存在这个参数需要以:开始后跟定义如何输出显示的文本，包括字段宽度，对齐，填充，小数精度等，并以可选的数据类型代码结束。formatspec的组成语法： [[fill]align][sign][#][0][width][,][.precision][typecode] fill 为除&#123;&#125;之外的任何填充字符 align 可以为 &lt;, &gt;, =, or ^，表示左对齐，右对齐，符号字符填充和中央对齐。 sign 可以是+，-或空格 width和precision 与%表达式中的类似 [,] 按千位分割符，见下 formatspec还可以包含嵌套的仅包含字段名称的{}格式字符串，来从参数列表动态的获取值12345678&gt;&gt;&gt; '&#123;0:.2f&#125;'.format(1 / 3.0) # Parameters hardcoded '0.33' &gt;&gt;&gt; '%.2f' % (1 / 3.0) # Ditto for expression '0.33' &gt;&gt;&gt; '&#123;0:.&#123;1&#125;f&#125;'.format(1 / 3.0, 4) # Take value from arguments '0.3333' &gt;&gt;&gt; '%.*f' % (4, 1 / 3.0) # Ditto for expression '0.3333' typecode 与格式化字符串中的code一样，format方法还支持%b用来显示十进制数字的二进制表示方法，%用于显示百分数，对于正数只有%d(i或u不在此使用)1234567891011121314'&#123;.platform:&gt;10&#125; = &#123;[kind]:&lt;10&#125;'.format(sys, dict(kind='laptop')) '&#123;0:f&#125;, &#123;1:.2f&#125;, &#123;2:06.2f&#125;'.format(3.14159, 3.14159, 3.14159) &gt;&gt;&gt; '&#123;0:.2f&#125;'.format(1.2345) # String method '1.23' &gt;&gt;&gt; format(1.2345, '.2f') # Built-in function '1.23' &gt;&gt;&gt; '%.2f' % 1.2345 # Expression '1.23' &gt;&gt;&gt; '&#123;0:d&#125;'.format(999999999999) '999999999999' &gt;&gt;&gt; '&#123;0:,d&#125;'.format(999999999999) '999,999,999,999' 格式化方法与%表达式的比较： 字符串格式化表达式比format方法更容易使用，更通用：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556print('%s=%s' % ('spam', 42)) # Format expression: in all 2.X/3.X print('&#123;0&#125;=&#123;1&#125;'.format('spam', 42)) # Format method: in 3.0+ and 2.6+ print('&#123;&#125;=&#123;&#125;'.format('spam', 42)) # With autonumbering: in 3.1+ and 2.7&gt;&gt;&gt; '%s, %s and %s' % (3.14, 42, [1, 2])'My %(kind)s runs %(platform)s' % &#123;'kind': 'laptop', 'platform': sys.platform&#125; 'My %(kind)s runs %(platform)s' % dict(kind='laptop', platform=sys.platform) '%(plat)10s = %(kind)-10s' % dict(plat=sys.platform, kind='laptop') 'My &#123;1[kind]:&lt;8&#125; runs &#123;0.platform:&gt;8&#125;'.format(sys, &#123;'kind': 'laptop'&#125;) 'My %(kind)-8s runs %(plat)8s' % dict(kind='laptop', plat=sys.platform)# Floating-point numbers &gt;&gt;&gt; '%e, %.3e, %g' % (3.14159, 3.14159, 3.14159) '3.141590e+00, 3.142e+00, 3.14159' &gt;&gt;&gt; '%f, %.2f, %06.2f' % (3.14159, 3.14159, 3.14159) '3.141590, 3.14, 003.14' # Hex and octal, but not binary (see ahead) &gt;&gt;&gt; '%x, %o' % (255, 255) 'ff, 377'# Hardcoded references in both &gt;&gt;&gt; import sys &gt;&gt;&gt; 'My &#123;1[kind]:&lt;8&#125; runs &#123;0.platform:&gt;8&#125;'.format(sys, &#123;'kind': 'laptop'&#125;) 'My laptop runs win32' &gt;&gt;&gt; 'My %(kind)-8s runs %(plat)8s' % dict(kind='laptop', plat=sys.platform) 'My laptop runs win32'# Building data ahead of time in both &gt;&gt;&gt; data = dict(platform=sys.platform, kind='laptop') &gt;&gt;&gt; 'My &#123;kind:&lt;8&#125; runs &#123;platform:&gt;8&#125;'.format(**data) #**用于将字典解包为关键字参数'My laptop runs win32' &gt;&gt;&gt; 'My %(kind)-8s runs %(platform)8s' % data 'My laptop runs win32'&gt;&gt;&gt; '&#123;:,d&#125;'.format(999999999999) '999,999,999,999' &gt;&gt;&gt; '&#123;:,d&#125; &#123;:,d&#125;'.format(9999999, 8888888) '9,999,999 8,888,888' &gt;&gt;&gt; '&#123;:,.2f&#125;'.format(296999.2567) '296,999.26'&gt;&gt;&gt; from formats import commas, money &gt;&gt;&gt; '%s' % commas(999999999999) '999,999,999,999' &gt;&gt;&gt; '%s %s' % (commas(9999999), commas(8888888))'9,999,999 8,888,888' &gt;&gt;&gt; '%s' % money(296999.2567) '$296,999.26'&gt;&gt;&gt; [commas(x) for x in (9999999, 8888888)] ['9,999,999', '8,888,888'] &gt;&gt;&gt; '%s %s' % tuple(commas(x) for x in (9999999, 8888888)) '9,999,999 8,888,888' &gt;&gt;&gt; ''.join(commas(x) for x in (9999999, 8888888)) '9,999,9998,888,888' 使用format方法的优点： 具有%表达式本身没有的一些特性 例如打印二进制的表示，使用format和表达式分别实现为：12345678910111213&gt;&gt;&gt; '&#123;0:b&#125;'.format((2 ** 16) ? 1) # Expression (only) binary format code '1111111111111111' &gt;&gt;&gt; '%b' % ((2 ** 16) ? 1) ValueError: unsupported format character 'b'... &gt;&gt;&gt; bin((2 ** 16) ? 1) # But other more general options work too '0b1111111111111111' &gt;&gt;&gt; '%s' % bin((2 ** 16) - 1) # Usable with both method and % expression '0b1111111111111111' &gt;&gt;&gt; '&#123;&#125;'.format(bin((2 ** 16) - 1)) # With 2.7/3.1+ relative numbering '0b1111111111111111' &gt;&gt;&gt; '%s' % bin((2 ** 16) - 1)[2:] # Slice off 0b to get exact equivalent '1111111111111111' 打印千分位符的数字分别实现：1234&gt;&gt;&gt; '&#123;:,d&#125;'.format(999999999999) # New str.format method feature in 3.1/2.7 '999,999,999,999' &gt;&gt;&gt; '%s' % commas(999999999999) # But % is same with simple 8-line function '999,999,999,999' 有更灵活的数值引用语法 123456789101112&gt;&gt;&gt; '&#123;name&#125; &#123;job&#125; &#123;name&#125;'.format(name='Bob', job='dev') 'Bob dev Bob' &gt;&gt;&gt; '%(name)s %(job)s %(name)s' % dict(name='Bob', job='dev') 'Bob dev Bob'&gt;&gt;&gt; D = dict(name='Bob', job='dev') &gt;&gt;&gt; '&#123;0[name]&#125; &#123;0[job]&#125; &#123;0[name]&#125;'.format(D) # Method, key references 'Bob dev Bob' &gt;&gt;&gt; '&#123;name&#125; &#123;job&#125; &#123;name&#125;'.format(**D) # Method, dict-to-args 'Bob dev Bob' &gt;&gt;&gt; '%(name)s %(job)s %(name)s' % D # Expression, key references 'Bob dev Bob' 更明确的值引用替换 12'\n%s&lt;Class %s, address %s:\n%s%s%s&gt;\n' % (...) # Expression '\n&#123;0&#125;&lt;Class &#123;1&#125;, address &#123;2&#125;:\n&#123;3&#125;&#123;4&#125;&#123;5&#125;&gt;\n'.format(...) # Method 注意各种形式使用的python版本：123456&gt;&gt;&gt; 'The &#123;0&#125; side &#123;1&#125; &#123;2&#125;'.format('bright', 'of', 'life') # Python 3.X, 2.6+ 'The bright side of life' &gt;&gt;&gt; 'The &#123;&#125; side &#123;&#125; &#123;&#125;'.format('bright', 'of', 'life') # Python 3.1+, 2.7+ 'The bright side of life' &gt;&gt;&gt; 'The %s side %s %s' % ('bright', 'of', 'life') # All Pythons 'The bright side of life' 对于浮点数的显示，格式化表达式会更简介：123456&gt;&gt;&gt; '&#123;0:f&#125;, &#123;1:.2f&#125;, &#123;2:05.2f&#125;'.format(3.14159, 3.14159, 3.14159) '3.141590, 3.14, 03.14' &gt;&gt;&gt; '&#123;:f&#125;, &#123;:.2f&#125;, &#123;:06.2f&#125;'.format(3.14159, 3.14159, 3.14159) '3.141590, 3.14, 003.14' &gt;&gt;&gt; '%f, %.2f, %06.2f' % (3.14159, 3.14159, 3.14159) '3.141590, 3.14, 003.14' 比%操作符更容易记的方法名称 单值和多值使用相同的语法 1234567891011121314151617&gt;&gt;&gt; '%.2f' % 1.2345 # Single value '1.23' &gt;&gt;&gt; '%.2f %s' % (1.2345, 99) # Multiple values tuple '1.23 99' &gt;&gt;&gt; '%s' % (1.23,) # Single value, in a tuple '1.23' &gt;&gt;&gt; '%s' % ((1.23,),) # Single value that is a tuple '(1.23,)'&gt;&gt;&gt; '&#123;0:.2f&#125;'.format(1.2345) # Single value '1.23' &gt;&gt;&gt; '&#123;0:.2f&#125; &#123;1&#125;'.format(1.2345, 99) # Multiple values '1.23 99' &gt;&gt;&gt; '&#123;0&#125;'.format(1.23) # Single value, by itself '1.23' &gt;&gt;&gt; '&#123;0&#125;'.format((1.23,)) # Single value that is a tuple '(1.23,)' 作为一个函数可以用在不能使用表达式的地方，例如作为函数参数 Python中类型分类 数字（整数，浮点，二进制，分数，小数） 支持加法乘法 序列（字符串，列表，元组） 支持索引，分片，合并等 映射（字典） 支持通过键的索引。 只有可变类型能在原处修改： 不可变类型（数字，字符串，元组，不可变集合） 可变类型（列表，字典，可变集合） 列表与字典其它对象的集合 列表有序对象集合，与字符串不同可以包含任何种类的对象，数字，字符串，其他列表等。 列表是可变对象，支持在原处修改的操作： 列表是任意对象的有序集合。 通过便宜读取。 可变长度，异构（可以包含任何类型的对象），任意嵌套。 属于可变序列的分类，支持原地修改，可以响应索引，分片及合并，返回新的列表。 列表是对象引用的数组，包含0个或多个其他对象的引用。 常用的列表操作123456789101112131415161718192021222324252627282930L = [] An empty list L = [123, &apos;abc&apos;, 1.23, &#123;&#125;] Four items: indexes 0..3 L = [&apos;Bob&apos;, 40.0, [&apos;dev&apos;, &apos;mgr&apos;]] Nested sublists L = list(&apos;spam&apos;) L = list(range(-4, 4)) List of an iterable’s items, list of successive integers L[i] L[i][j] L[i:j] len(L) Index, index of index, slice, length L1 + L2 Concatenate 生成新的列表L * 3 repeatfor x in L: print(x) 3 in L Iteration, membershipL.append(4) 在原地修改，返回值为noneL.extend([5,6,7]) L.insert(i, X) Methods: growingL.index(X) L.count(X) Methods: searchingL.sort() 原地修改，返回值为none。key参数给出一个单个参数的函数，返回排序中使用的值。reverse参数升序降序。L.reverse() 原地反转列表L.copy() L.clear() Methods: sorting, reversing, copying (3.3+), clearing (3.3+)L.pop(i) L.remove(X) del L[i] del L[i:j] L[i:j] = [] Methods, statements: shrinkingL[i] = 3 L[i:j] = [4,5,6] Index assignment, slice assignmentL = [x**2 for x in range(5)] list(map(ord, &apos;spam&apos;)) List comprehensions and maps 列表的操作：1234567891011&gt;&gt;&gt; [1, 2, 3] + [4, 5, 6] # Concatenation&gt;&gt;&gt; ['Ni!'] * 4 # Repetition&gt;&gt;&gt; str([1, 2]) + "34" # Same as "[1, 2]" + "34" '[1, 2]34' &gt;&gt;&gt; [1, 2] + list("34") # Same as [1, 2] + ["3", "4"] [1, 2, '3', '4']&gt;&gt;&gt; 3 in [1, 2, 3] # Membership True &gt;&gt;&gt; for x in [1, 2, 3]: ... print(x, end=' ') # Iteration (2.X uses: print x,) 列表解析123&gt;&gt;&gt; res = [c * 4 for c in 'SPAM'] # List comprehensions &gt;&gt;&gt; res ['SSSS', 'PPPP', 'AAAA', 'MMMM'] 等价于，但是列表解析会更快速 123&gt;&gt;&gt; res = [] &gt;&gt;&gt; for c in 'SPAM': # List comprehension equivalent ... res.append(c * 4) 1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt;&gt;&gt; list(map(abs, [?1, ?2, 0, 1, 2])) # Map a function across a sequence 对每个元素执行map中的函数[1, 2, 0, 1, 2]&gt;&gt;&gt; L = ['spam', 'Spam', 'SPAM!'] &gt;&gt;&gt; L[1] = 'eggs' #原地修改，索引赋值&gt;&gt;&gt; L[0:2] = ['eat', 'more'] # Slice assignment: delete+insert 分片赋值&gt;&gt;&gt; L # Replaces items 0,1 ['eat', 'more', 'SPAM!']&gt;&gt;&gt; L = [1, 2, 3] &gt;&gt;&gt; L[1:2] = [4, 5] # Replacement/insertion &gt;&gt;&gt; L [1, 4, 5, 3] &gt;&gt;&gt; L[1:1] = [6, 7] # Insertion (replace nothing) &gt;&gt;&gt; L [1, 6, 7, 4, 5, 3] &gt;&gt;&gt; L[1:2] = [] # Deletion (insert nothing) &gt;&gt;&gt; L [1, 7, 4, 5, 3]&gt;&gt;&gt; L = [1] &gt;&gt;&gt; L[:0] = [2, 3, 4] # Insert all at :0, an empty slice at front &gt;&gt;&gt; L [2, 3, 4, 1] &gt;&gt;&gt; L[len(L):] = [5, 6, 7] # Insert all at len(L):, an empty slice at end &gt;&gt;&gt; L [2, 3, 4, 1, 5, 6, 7] &gt;&gt;&gt; L.extend([8, 9, 10]) # Insert all at end, named method &gt;&gt;&gt; L [2, 3, 4, 1, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; L = ['eat', 'more', 'SPAM!'] &gt;&gt;&gt; L.append('please') # Append method call: add item at end &gt;&gt;&gt; L ['eat', 'more', 'SPAM!', 'please']&gt;&gt;&gt; L.sort() # Sort list items ('S' &lt; 'e') &gt;&gt;&gt; L ['SPAM!', 'eat', 'more', 'please'] 关于sort函数：1234567891011121314&gt;&gt;&gt; L = ['abc', 'ABD', 'aBe'] &gt;&gt;&gt; L.sort() # Sort with mixed case &gt;&gt;&gt; L ['ABD', 'aBe', 'abc'] &gt;&gt;&gt; L = ['abc', 'ABD', 'aBe'] &gt;&gt;&gt; L.sort(key=str.lower) # Normalize to lowercase &gt;&gt;&gt; L ['abc', 'ABD', 'aBe']&gt;&gt;&gt; L = ['abc', 'ABD', 'aBe'] &gt;&gt;&gt; L.sort(key=str.lower, reverse=True) # Change sort order &gt;&gt;&gt; L ['aBe', 'ABD', 'abc'] python2中不同类型的对象比较是可行的，语言根据类型的名称定义了固定的不同类型的顺序,int总是小于strpython3中不再能比较不同类型了，[1, 2, ‘spam’].sort()在python3中会报告异常。python3中也不再支持给sort传递任意的比较函数，使用reverse=True来改变顺序。 注意append和sort会在原地改变传入的列表，但是使用python内置的sort函数对任意集合则会返回排序后的列表：1234567&gt;&gt;&gt; L = ['abc', 'ABD', 'aBe'] &gt;&gt;&gt; sorted(L, key=str.lower, reverse=True) # Sorting built-in ['aBe', 'ABD', 'abc'] &gt;&gt;&gt; L = ['abc', 'ABD', 'aBe'] &gt;&gt;&gt; sorted([x.lower() for x in L], reverse=True) # Pretransform items: differs! ['abe', 'abd', 'abc'] #注意此时会输出转换为小写后的结果，而不是元列表中的元素。 python的内置函数sorted（）可以排序任何集合。12345678910111213&gt;&gt;&gt; L = [1, 2] &gt;&gt;&gt; L.extend([3, 4, 5]) # Add many items at end (like in-place +) &gt;&gt;&gt; L [1, 2, 3, 4, 5] &gt;&gt;&gt; L.pop() # Delete and return last item (by default: ?1) 5 &gt;&gt;&gt; L [1, 2, 3, 4] &gt;&gt;&gt; L.reverse() # In-place reversal method&gt;&gt;&gt; L [4, 3, 2, 1] &gt;&gt;&gt; list(reversed(L)) # Reversal built-in with a result (iterator) [1, 2, 3, 4] list(reversed(L)) reversed迭代器 pop() 和 append() 方法联合使用可以用来实现一个堆栈。pop()可以接受一个索引，默认为-11234567891011121314&gt;&gt;&gt; L = ['spam', 'eggs', 'ham'] &gt;&gt;&gt; L.index('eggs') # Index of an object (search/find) 1 &gt;&gt;&gt; L.insert(1, 'toast') # Insert at position &gt;&gt;&gt; L ['spam', 'toast', 'eggs', 'ham'] &gt;&gt;&gt; L.remove('eggs') # Delete by value &gt;&gt;&gt; L ['spam', 'toast', 'ham'] &gt;&gt;&gt; L.pop(1) # Delete by position 'toast' &gt;&gt;&gt; L ['spam', 'ham'] &gt;&gt;&gt; L.count('spam') # Number of occurrences 1 count和index不改变原列表内容，只返回信息。 另一种删除方法：1234567&gt;&gt;&gt; L = ['spam', 'eggs', 'ham', 'toast'] &gt;&gt;&gt; del L[0] # Delete one item &gt;&gt;&gt; L ['eggs', 'ham', 'toast'] &gt;&gt;&gt; del L[1:] # Delete an entire section &gt;&gt;&gt; L # Same as L[1:] = [] ['eggs'] L.copy()顶层拷贝 字典无序对象的集合，字典中的元素通过key来存取，而不是偏移，作为高度优化的内置类型，索引一个字典是非常快速的查找操作。 字典通过key而不是偏移读取数据。有时又叫做关联数组或者散列表。 任意对象的无序集合。 可变长度，异构，任意嵌套。 属于可变映射类型。 列表实际上是对象的引用表，散列表。采用最优化的散列算法来寻找key。 字典的常用操作123456789101112131415161718192021222324252627D = &#123;&#125; Empty dictionary D = &#123;'name': 'Bob', 'age': 40&#125; Two-item dictionary E = &#123;'cto': &#123;'name': 'Bob', 'age': 40&#125;&#125; Nesting D = dict(name='Bob', age=40) D = dict([('name', 'Bob'), ('age', 40)]) D = dict(zip(keyslist, valueslist)) D = dict.fromkeys(['name', 'age']) Alternative construction techniques: keywords, key/value pairs, zipped key/value pairs, key lists D['name'] E['cto']['age'] Indexing by key 'age' in D Membership: key present test D.keys() all keysD.values() all valuesD.items() all key+value tuplesD.copy() copy (top-level)D.clear() clear (remove all items)D.update(D2) merge by keysD.get(key, default?) fetch by key if absent default (or None)D.pop(key, default?) remove by key, if absent default (or error)D.setdefault(key, default?) fetch by key, if absent set default (or None)D.popitem() remove/return any (key, value) pair; etc. len(D) Length: number of stored entries D[key] = 42 Adding/changing keys del D[key] Deleting entries by key list(D.keys()) Dictionary views (Python 3.X)D1.keys() &amp; D2.keys() D.viewkeys(), D.viewvalues() Dictionary views (Python 2.7) D = &#123;x: x*2 for x in range(10)&#125; Dictionary comprehensions (Python 3.X, 2.7) 字典的操作：12345678&gt;&gt;&gt; D = &#123;'spam': 2, 'ham': 1, 'eggs': 3&#125; # Make a dictionary &gt;&gt;&gt; D['spam'] # Fetch a value by key&gt;&gt;&gt; len(D) # Number of entries in dictionary 3&gt;&gt;&gt; 'ham' in D # Key membership test alternative #字典实现了迭代器协议True &gt;&gt;&gt; list(D.keys()) # Create a new list of D's keys ['eggs', 'spam', 'ham'] python3中keys()方法返回的是一个迭代器对象，要显示转换为listpython2中keys()创建并返回一个列表。 123456789101112&gt;&gt;&gt; D &#123;'eggs': 3, 'spam': 2, 'ham': 1&#125; &gt;&gt;&gt; D['ham'] = ['grill', 'bake', 'fry'] # Change entry (value=list) 创建新项目&gt;&gt;&gt; D &#123;'eggs': 3, 'spam': 2, 'ham': ['grill', 'bake', 'fry']&#125;&gt;&gt;&gt; del D['eggs'] # Delete entry 删除&gt;&gt;&gt; D &#123;'spam': 2, 'ham': ['grill', 'bake', 'fry']&#125; &gt;&gt;&gt; D['brunch'] = 'Bacon' # Add new entry 新建&gt;&gt;&gt; D &#123;'brunch': 'Bacon', 'spam': 2, 'ham': ['grill', 'bake', 'fry']&#125; python3中与keys()一样values()与items()方法也都返回迭代器对象12345&gt;&gt;&gt; D = &#123;'spam': 2, 'ham': 1, 'eggs': 3&#125; &gt;&gt;&gt; list(D.values()) [3, 2, 1] &gt;&gt;&gt; list(D.items()) [('eggs', 3), ('spam', 2), ('ham', 1)] 实际使用中试图获取一个不存在的key会产生错误，可以使用get方法，对于不存在的key它返回一个None对象或传入的默认值。123456&gt;&gt;&gt; D.get('spam') # A key that is there 2 &gt;&gt;&gt; print(D.get('toast')) # A key that is missing None &gt;&gt;&gt; D.get('toast', 88) 88 update方法合并两个字典，如果已经存在某个key会被覆盖：12345&gt;&gt;&gt; D &#123;'eggs': 3, 'spam': 2, 'ham': 1&#125; &gt;&gt;&gt; D2 = &#123;'toast':4, 'muffin':5&#125; # Lots of delicious scrambled order here &gt;&gt;&gt; D.update(D2) &gt;&gt;&gt; D &#123;'eggs': 3, 'muffin': 5, 'toast': 4, 'spam': 2, 'ham': 1&#125; 字典的pop()方法删除一个key，返回被删除的key对应的值12345&gt;&gt;&gt; D.pop('muffin') 5 &gt;&gt;&gt; D.pop('toast') # Delete and return from a key 4 &gt;&gt;&gt; D &#123;'eggs': 3, 'spam': 2, 'ham': 1&#125; 遍历字典：for key in D: 与 key in D.keys()效果一样。 将值映射到keys：1234&gt;&gt;&gt; list(table.items()) # Value=&gt;Key (year=&gt;title) [('The Meaning of Life', '1983'), ('Holy Grail', '1975'), ('Life of Brian', '1979')] &gt;&gt;&gt; [title for (title, year) in table.items() if year == '1975'] ['Holy Grail'] 或者使用如下形式：12345&gt;&gt;&gt; V = '1975' &gt;&gt;&gt; [key for (key, value) in table.items() if value == V] # Value=&gt;Key ['Holy Grail'] &gt;&gt;&gt; [key for key in table.keys() if table[key] == V] # Ditto ['Holy Grail'] 注意 序列运算无效，包括有序合并，分片等。 对新索引赋值会添加项。 键不一定总是字符串，任何不可变对象都可以。 所以可以使用字典模拟灵活列表：列表必须按顺序插入，列表可以随意选择值插入 使用字典作为稀疏数组对象，用元组作为key：12345&gt;&gt;&gt; Matrix = &#123;&#125; &gt;&gt;&gt; Matrix[(2, 3, 4)] = 88 &gt;&gt;&gt; Matrix[(7, 8, 9)] = 99&gt;&gt;&gt; Matrix &#123;(2, 3, 4): 88, (7, 8, 9): 99&#125; 队列表超范围的索引赋值是非法的，但字典可以随意赋值。 避免键值不存在的错误： 使用key前先进行测试 1234&gt;&gt;&gt; if (2, 3, 6) in Matrix: # Check for key before fetch ... print(Matrix[(2, 3, 6)]) # See Chapters 10 and 12 for if/else ... else: ... print(0) 使用try语句捕获异常并恢复 1234&gt;&gt;&gt; try: ... print(Matrix[(2, 3, 6)]) # Try to index ... except KeyError: # Catch and recover ... print(0) # See Chapters 10 and 34 for try/except 使用字典的get方法，在不存在时提供一个默认值。 1234&gt;&gt;&gt; Matrix.get((2, 3, 4), 0) # Exists: fetch and return 88 &gt;&gt;&gt; Matrix.get((2, 3, 6), 0) # Doesn't exist: use default arg 0 字典中可以嵌套各种类型 其它创建字典的方法： 如果可以事先拼凑出整个字典，可以{&#39;name&#39;: &#39;Bob&#39;, &#39;age&#39;: 40} 如果需要一次动态的建立一个字典的一个字段： 123D = &#123;&#125;D['name'] = 'Bob'D['age'] = 40 dict(name=&#39;Bob&#39;, age=40)此方法键必须是字符串。 程序运行时把键和值逐步建成序列后统一用 dict([(&#39;name&#39;, &#39;Bob&#39;), (&#39;age&#39;, 40)]) zip函数使用键和值的列表构建对应字典： D = dict(zip([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [1, 2, 3])) 如果所有的键值都相同作为初始值： dict.fromkeys([&#39;a&#39;, &#39;b&#39;], 0) 在python3与python2.7中使用字典解析表达式创建 python3与python2.7中字典： 支持新的字典解析表达式 对D.keys, D.values, and D.items返回迭代器对象视图对象，而不再是列表。 由于上一条改变遍历方法需要使用不同的风格了 不再支持跨类型的比较操作 没有D.has_key方法了，使用in操作进行测试。 python3中的字典新特性 字典解析： 12345678910&gt;&gt;&gt; list(zip(['a', 'b', 'c'], [1, 2, 3])) # Zip together keys and values [('a', 1), ('b', 2), ('c', 3)] &gt;&gt;&gt; D = dict(zip(['a', 'b', 'c'], [1, 2, 3])) # Make a dict from zip result &gt;&gt;&gt; D &#123;'b': 2, 'c': 3, 'a': 1&#125;D = &#123;k: v for (k, v) in zip(['a', 'b', 'c'], [1, 2, 3])&#125; D = &#123;x: x ** 2 for x in [1, 2, 3, 4]&#125; D = &#123;c: c * 4 for c in 'SPAM'&#125; D = &#123;c.lower(): c + '!' for c in ['SPAM', 'EGGS', 'HAM']&#125; 初始化： 1234D = dict.fromkeys(['a', 'b', 'c'], 0) D = &#123;k:0 for k in ['a', 'b', 'c']&#125; D = dict.fromkeys('spam') D = &#123;k: None for k in 'spam'&#125; 字典视图： keys,values,items都返回视图对象。2.x中返回结果列表。 视图对象是可迭代的，要应用列表操作或显示值，需要使用list()函数。1234567&gt;&gt;&gt; D.items() dict_items([('b', 2), ('c', 3), ('a', 1)]) &gt;&gt;&gt; list(D.items()) [('b', 2), ('c', 3), ('a', 1)]&gt;&gt;&gt; for k in D.keys(): print(k) # Iterators used automatically in loops&gt;&gt;&gt; for key in D: print(key) # Still no need to call keys() to iterate 视图对象创建后依然能够动态的显示其字典对象的改变：1234567891011121314&gt;&gt;&gt; D = &#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; K = D.keys() &gt;&gt;&gt; V = D.values() &gt;&gt;&gt; list(K) # Views maintain same order as dictionary ['b', 'c', 'a'] &gt;&gt;&gt; list(V) [2, 3, 1]&gt;&gt;&gt; del D['b'] # Change the dictionary in place &gt;&gt;&gt; D &#123;'c': 3, 'a': 1&#125; &gt;&gt;&gt; list(K) # Reflected in any current view objects ['c', 'a'] &gt;&gt;&gt; list(V) # Not true in 2.X! - lists detached from dict [3, 1] 字典视图和集合相似。 keys()返回的视图对象支持集合的交集与并集操作。values()的不支持。12345678&gt;&gt;&gt; K, V (dict_keys(['c', 'a']), dict_values([3, 1])) &gt;&gt;&gt; K | &#123;'x': 4&#125; # Keys (and some items) views are set-like &#123;'c', 'x', 'a'&#125; &gt;&gt;&gt; V &amp; &#123;'x': 4&#125; TypeError: unsupported operand type(s) for &amp;: 'dict_values' and 'dict' &gt;&gt;&gt; V &amp; &#123;'x': 4&#125;.values() TypeError: unsupported operand type(s) for &amp;: 'dict_values' and 'dict_values' keys视图对象可以与其它的视图对象，集合，字典对象混合操作123456789&gt;&gt;&gt; D = &#123;'a': 1, 'b': 2, 'c': 3&#125; &gt;&gt;&gt; D.keys() &amp; D.keys() # Intersect keys views &#123;'b', 'c', 'a'&#125; &gt;&gt;&gt; D.keys() &amp; &#123;'b'&#125; # Intersect keys and set &#123;'b'&#125; &gt;&gt;&gt; D.keys() &amp; &#123;'b': 1&#125; # Intersect keys and dict &#123;'b'&#125;&gt;&gt;&gt; D.keys() | &#123;'b', 'c', 'd'&#125; # Union keys and set &#123;'b', 'c', 'a', 'd'&#125; 如果items()视图对象仅包含不可变对象那么它也具有以上特性。 python3对字典key的排序 不可以：123D = &#123;'a': 1, 'b': 2, 'c': 3&#125;Ks = D.keys()Ks.sort() 会返回错误，Ks是视图对象。 可以：1234Ks = list(Ks)Ks.sort()for k in Ks: print(k, D[k]) 也可以：123Ks = D.keys()for k in sorted(Ks): print(k, D[k]) 也可以：12for k in sorted(D): print(k, D[k]) 内建sorted函数接受任何可迭代类型。 不能比较字典的大小了 但是可以比较排序后keys的list的大小：1sorted(D1.items()) &lt; sorted(D2.items()) # Like 2.X D1 &lt; D2 取消has_key方法 可以使用12if 'c' in D: print('present', D['c']) 或12if D.get('c') != None: print('present', D['c'])]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安装，配置]]></title>
    <url>%2F2019%2F01%2F05%2Fhexo-install-config%2F</url>
    <content type="text"><![CDATA[前言在网络上游荡20几年，没有一个稳定的博客空间，很多自己的总结/随笔都是以文本文件的形式存储在本地，主要因为下面几个原因： 感觉大部分的博客空间都随时有消失的可能，免费空间大都有各种限制，没有安全感，不想自己多年的心血白费 大部分博客中的内容的富文本格式不可移植，不能很方便的同步在多个空间 我懒，本地存储虽然low但是使用、搜索、编辑起来还是很方便的 不过如今的网络文章写作已经很不同了，Markdown的流行甚至成了一种标准，主流的博客平台基本都开始支持Markdown格式，这让一次写作多处发布成为了可能，而且Markdown格式的文本在本地也很容易存储、编辑、解析后更已读、能够方便的导出为html,pdf等多种格式分享。很大程度上减轻了维护一个甚至多个博客空间的工作量。 支持Markdown写作的博客有多种选择，比如 在线的：简书，github，博客园，SegmentFault，开源中国，图灵社区等 blog建站系统：hexo，jekyII，wordpress，Ghost，gitblog，CMD Markdown，startblog等 我自己目前的需求是以本地为中心，能够方便的生成静态页面或直接上传Markdown文档后进行多位置的部署，又不想受各博客空间的模板限制，又想稳定方便，所以，自己搭搭建可以说是个很好的选择。在这里，我将介绍我当前博客的搭建方法：使用自己的虚拟主机+Github Page同步发布，基于Hexo框架，采用nexT模板。下面就把自己搭建，配置过程和使用方法进行一个记录。 我自己的博客环境的需求： 能在多台电脑随时写作更新，能在本地查看格式化后内容，能根据内容搜索。 博客空间位于两个位置：自己的虚拟主机和github.io ，可以同步更新。 对于文章可以有选择地复制到其它在线空间。 Hexo安装配置什么是Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo基于Node.js，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub上，是搭建博客的首选框架。 最好的介绍还是上官网链接：https://hexo.io/zh-cn/ 安装我的安装环境是一个刚刚在本地重装好的centos7虚拟机，首先我会用这台主机作为初始空间配置的生成，并运行独立的http服务器。 安装gitHexo, node.js, Hexo主题，后续空间的发布，配置及文章的同步都需要git作为工具。 Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Linux (Ubuntu, Debian)：sudo apt-get install git-core Windows：下载并安装 git. Mac：使用Homebrew, MacPorts：brew install git ;或下载安装程序安装。 由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。 安装Node.js安装 Node.js 的最佳方式是使用nvm。 cURL: 1$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh Wget: 1$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装Node.js： 1$ nvm install stable 或者您也可以下载安装程序来安装。 对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 配置以上Hexo最基本的组件已经全部安装完成，后续可能还会需要其它的依赖组件，在配置过程中用到时再随时安装。 创建一个Hexo运行目录Hexo系统需要一个目录用来初始化生成博客空间所需要的全部文件，我选择在自己home目录下的hexo文件夹： 1$ mkdir ~/hexo 初始化运行目录请执行下列命令，Hexo将会在指定文件夹中新建所需要的文件。 123$ hexo init ~/hexo$ cd ~/hexo$ npm install 新建完成后，文件夹hexo内的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中各文件和目录的作用： _config.yml: 网站的 配置 信息，您可以在此配置大部分的参数。 package.json: 应用程序的信息。一般无需更改。 scaffolds: 模版 文件夹。当新建文章时，Hexo 会根据scaffold来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source: 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes: 主题 文件夹。Hexo 会根据主题来生成静态页面。 执行完初始化，就可以预览一下hexo的初始样貌了，可以在~/hexo目录下执行如下命令: 12$ hexo generate$ hexo server 执行完毕后可以通过浏览器访问http://server-ip:4000/来访问 配置hexo安装nexT主题我个人很喜欢hexo的NexT主题，所以配置过程中一起安装这个主题。NexT主题是托管在github上的，其新的主页地址：https://github.com/theme-next/hexo-theme-next/原地址，此代码库已停止更新：https://github.com/iissnan/hexo-theme-next 安装方法： 12cd ~/hexogit clone https://github.com/theme-next/hexo-theme-next themes/next 修改hexo站点基本配置~/hexo/_config.yml可以在 _config.yml 中修改大部分的配置。以下是我修改的内容： 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述。主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。 author 您的名字，用于显示文章的作者。 language 网站使用的语言，简体中文应设置为zh-Hans，支持的语言列表可参看所用主题的目录：themes/next/languages/ timezone 网站时区。Hexo默认使用您电脑的时区。为增加移植性设定为北京时间：Asia/Shanghai ，参考时区列表。 url 网址，填http://自己网站域名 root 网站根目录，本blog在网站中的目录 theme 当前主题名称，即themes目录下主题目录的名称。我安装了NexT主题，这里设置为 next deploy 部署部分的设置，将在下面章节详述 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 下列参数是可能会用到的，我目前保留了默认值： 参数 描述 默认值 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 default_category 默认分类 uncategorized date_format 日期格式 Hexo 使用 Moment.js 来解析和显示时间。 YYYY-MM-DD time_format 时间格式 H:mm:ss per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 修改NexT主题配置~/hexo/themes/next/_config.yml关于NexT主题的全部详细配置方法见官网：https://theme-next.org/原官网地址，已停止更新：https://theme-next.iissnan.com 我自己对NexT主题配置文件的修改如下： 显示在菜单导航栏中的项目1234567menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive about: /about/ || user sitemap: /sitemap.xml || sitemap categories和tags页面将在后面使用hexo命令创建 主题显示布局，默认为Muse，更改为更简洁的Mist1234#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 修改社交媒体及联系方式123social: GitHub: https://github.com/redfuture || github E-Mail: mailto:redfuture@hotmail.com || envelope 其中第一部分为显示的文字名称，第二部分为链接，第三部分为显示的图标对应的fontawesome icons的名称 添加站点建立时间12footer: since: 2019 添加背景动画1canvas_nest: true 使用night风格的代码高亮显示1highlight_theme: night 至此hexo站点与next主题基本配置完毕。接下来使用hexo命令创建categories和tags页面，并新建一个新的文章。 使用hexo我希望在站点首页的导航菜单栏里添加两个链接： 分类：显示所有文章分类的页面，点击分类后显示这个分类下的所有文章 标签：所有文章使用过的标签页面，点击相应标签可以查看所有有此标签的文章 创建categories和tags页面hexo中创建页面的方式是相同的，使用以下命令：123$ hexo new page categories$ hexo new page tags$ hexo new page about 我同时还创建了一个关于页面，可以添加个人的简历，这个些可以和NexT主题配置文件中menu下面的子项相对应。命令执行后的结果就是在~/hexo/source/目录下分别生成了三个目录：categories，tags，about。每个目录中都有一个index.md。 修改post模板我们有了categories页面及tags页面，希望在以后发布的每篇博客都指定一个分类（Hexo仅支持一篇文章属于一个分类，不能属于多个分类），并设置多个标签。那么可以修改scaffolds/post.md文件，这个文件中的内容在以后每次用命令行创建新文章时会自动复制到新文章的md文件中。将其内容修改成：123456789---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:- defaulttags:- default1- default2--- 发布新文章现在所有都已经准备就绪，可以发布自己的第一篇文章了：1$ hexo new post "title" 命令执行后创建~/hexo/source/_post/title.md ,随后就可以使用熟悉的编辑器编辑title.md了 或者可以先创建一个草稿：1$ hexo new draft "title" 会生成~/hexo/source/_post/title.md，编辑完成后执行1$ hexo publish post "title" 会将文件移动到~/hexo/source/_post/title.md 生成静态页面并部署文章写作完成后可以执行如下命令生成静态页面：12345678$ hexo generate (hexo g) 由当前目录下的配置和文章生成新的博客静态页面$ hexo server (hexo s) 启动本地http server服务，默认在4000端口$ hexo deploy (hexo d) 提交到远程仓库$ hexo new page "xx"(hexo n page) 创建页面 $ hexo new "xx" (hexo n "") 创建文章$ hexo d -g 生成静态并提交到远程仓库$ hexo s -g 生成静态文件并启动本地预览$ hexo clean 如果修改了配置文件，建议先执行这个步骤，将public下的文件全部清除，重新生成 之后就可以在http://localhost:4000/看到刚才发布的文章了。至此hexo基础环境已经搭建完成。 将静态页面部署到github.iogithub为每个用户提供了一个无限容量的静态页面空间：your-github-username.github.io hexo也提供了方便的将自己的博客部署到github.io的功能： 登录自己github，确认已经存在username.github.io代码库，没有的话创建一个（必须以.github.io做后缀）。 生成一对RSA key, 命令如下： 1$ ssh-keygen -t rsa -b 4096 -C "自己的标识" 一路回车，会在~/.ssh/目录下生成两个文件：id_rsa和id_rsa.pub ，id_rsa自己保留好这是私钥。 将上面生成的id_rsa.pub配置到github账户，以便可以免密从自己的代码库check in/out代码。具体参见github帮助文档：Adding a new SSH key to your GitHub account 验证是否添加key成功： 1$ ssh -T git@github.com 修改站点配置文件：~/hexo/_config.yml 1234deploy: type: git repo: git@github.com:username.github.io.git branch: master 安装hexo的git插件 1$ npm install hexo-deployer-git --save 运行命令进行部署： 12$ hexo g$ hexo d 之后就可以在 http://username.github.io 看到自己的博客了。 写作环境博客基本成形了，同时发布在了github.io。但是有一个问题，如何能方便的在任意电脑上都能随时随地的码字更新，修改配置呢？ 建立个性化内容的代码库分析Hexo的文档结构后发现会被我们使用的配置文件和存储文章md文件的目录其实很集中，那么我们可以把这些可能被改变的文件提取出来，单独存放在一个github的代码库，这样每当需要修改配置，或添加新文章时就可以先去代码库checkout，修改，然后checkin了。只要电脑有git客户端和一个markdown编辑器就够了。 在github建立一个新代码库，假设名称为：myblog_site 将本地hexo运行目录中需要保存到github的易变内容提取出来： 12345$ mkdir ~/myblog_site$ mkdir -p ~/myblog_site/themes/next$ cd ~/hexo/$ cp -a _config.yml scaffolds source ~/myblog_site/ #拷贝站点配置，模板，文章目录至代码库目录$ cp themes/next/_config.yml ~/myblog_site/themes/next/ #拷贝NexT主题配置文件至代码库相同路径下 将~/myblog_site/ 初始化为git目录，并于新建立的代码库myblog_site关联，checkin 123456$ cd ~/myblog_site$ git init$ git add *$ git commit -a -m "init blog raw data."$ git remote add origin git@github.com:username/myblog_site.git$ git push -u origin master #将本地代码推送到远程代码库 至此博客的数据代码库建立完成。 在虚拟主机上建立相同的站点 登录虚拟主机，按照上面的步骤完成安装，假设仍然将hexo工作目录放在~/hexo/。 checkout博客的配置和文章数据： 12345678910$ cd$ scp id_rsa.pub ~/.ssh/ #将上面生成的私钥放置在虚拟主机服务器上$ git clone git@github.com:username/myblog_site.git #将配置/文章代码库克隆到本地$ cd ~/hexo/ #进入安装初始化好的博客工作目录$ rm -rf _config.yml scaffolds source themes/next/_config.yml$ ln -s ~/myblog_site/_config.yml # 如下分别将文件链接到代码库中的相同文件/目录$ ln -s ~/myblog_site/scaffolds$ ln -s ~/myblog_site/source$ cd themes/next/$ ln -s ~/myblog_site/themes/next/_config.yml 在虚拟主机上执行静态页面生成与部署： 123$ hexo g$ hexo d$ hexo s &amp; 后续写作过程 在一台新的工作电脑上（已安装git），将myblog_site克隆到本地目录。 使用任意markdown编辑器，编辑/添加文章到相应目录，或修改配置文件。 发布时先checkin到github: 12$ git commit -a -m "comments"$ git push origin master 登录到自己的虚拟主机执行myblog_site的checkout，然后执行静态页面的生成与部署到github.io，同时主机上启动服务。 关于markdown编辑器目前有多种编辑器可供使用,比如markdownpad, 在线的简书编辑器等，我自己更喜欢一些开源，免费，简单可移植的工具。工作中一直在用notepad++这个工具觉得很不错。notepad++也有第三方的plugin可以进行简单的markdown解析预览，虽然效果不是特别好，但是对于日常的文章写作足够用。 notepad++ notepad++ markdown预览插件：MarkdownViewerPlusPlus notepad++ markdown语法高亮插件：Markdown Syntax Highlighting for Notepad++ 以上所有部件均为纯绿色版本，存进自己的U盘，随身携带，即插即用。 完善博客功能添加搜索 进入到站点根目录：cd ~/hexo/ 安装：npm install –save hexo-generator-searchdb 配置： 编辑站点配置文件~/hexo/_config.yml，确保下列内容存在： 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件~/hexo/theme/next/_config.yml，启用本地搜索功能： 123# Local searchlocal_search: enable: true 重新生成。 添加站点地图 进入到站点根目录：cd ~/hexo/ 分别用下面两个命令来安装针对谷歌和百度的插件： 12$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 在站点配置文件中~/hexo/_config.yml中添加如下代码 12345678Plugins:- hexo-generator-baidu-sitemap- hexo-generator-sitemapbaidusitemap: path: baidusitemap.xmlsitemap: path: sitemap.xml 在你的博客根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了 优化SEO最简单的 添加RSS添加fork me on github 在GitHub Ribbons或GitHub Corners选择一款你喜欢的挂饰，拷贝方框内的代码。 将刚刚复制的挂饰代码，添加到hexo/themes/next/layout/_layout.swig文件中，放在下方。 12&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;&lt;a href=&quot;https://github.com/redfuture/&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 添加公益404页面设置阅读全文方式设置侧栏头像文章中使用图片添加评论功能添加访问量统计 静态网页最快接入计算访问量插件:不蒜子 接入方式很简单只需要将如下代码加入到页面中想要显示的位置:123456&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;span id="busuanzi_container_site_pv"&gt;本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次本站访客数&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人次本文总阅读量&lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt;次&lt;/span&gt; 在hexo的next主题中已经集成了不蒜子，使用起来更为方便，只需修改next的主题的配置文件：themes/next/_config.yml123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; page_pv_footer: 由于不蒜子的域名改变，如果使用了旧版本的next主题，还需修改next主题中不蒜子的地址，位于文件themes/next/layout/_third-party/analytics/busuanzi-counter.swig。 1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>skills</tag>
        <tag>github.io</tag>
      </tags>
  </entry>
</search>
