<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[learning-python阅读笔记]]></title>
    <url>%2F2019%2F01%2F23%2Flearning-python-notes%2F</url>
    <content type="text"><![CDATA[python对象类型介绍python的框架等级python程序可以分解为：模块，语句，表达式和对象 程序由模块构成。 模块包含语句。 语句包含表达式。 表达式建立并处理对象。 使用内建数据类型的好处 内建对象使得程序的编写更为简单 内建对象是其它扩展的基本元素 内建对象通常比自定义数据结构更有效率 内建对象是语言的一个标准部分 python的核心数据类型 数字 1234, 3.1415, 3+4j, 0b111, Decimal(), Fraction() 字符串 &#39;spam&#39;, &quot;Bob&#39;s&quot;, b&#39;a\x01c&#39;, u&#39;sp\xc4m&#39; 列表 [1, [2, &#39;three&#39;], 4.5], list(range(10)) 字典 {&#39;food&#39;: &#39;spam&#39;, &#39;taste&#39;: &#39;yum&#39;}, dict(hours=10) 元组 (1, &#39;spam&#39;, 4, &#39;U&#39;), tuple(&#39;spam&#39;), namedtuple 文件 open(&#39;eggs.txt&#39;), open(r&#39;C:\ham.bin&#39;, &#39;wb&#39;) 集合 set(&#39;abc&#39;), {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;} 其他核心类型：types，none，布尔型 程序单元类型：函数，模块，类。 实现相关的类型：compiled code, stack tracebacks python是动态类型的，也是强类型的语言，一旦创建了对象，它就和操作绑定了。使用变量前必须对其赋值。 python的数字，字符串，元组具有不可变性，创建之后不能改变，但是可以创建一个新的字符串赋给相同的变量名称，旧对象会被清理。 数字整数和浮点数，复数，固定精度的十进制数，有理分数，集合，布尔类型，其他开源的数字扩展（矩阵和向量，扩展精度数字） python3自动提供无穷的整数精度python2中如果整数类型不能容纳的数字需要使用单独的长整型 在python2.7或python3.1之前使用浮点数时可能会出现这种情况：1234&gt;&gt;&gt; 3.1415 * 2 # repr: as code (Pythons &lt; 2.7 and 3.1) 6.2830000000000004 &gt;&gt;&gt; print(3.1415 * 2) # str: user-friendly 6.283 这并不是一个bug，而是显示问题。注意浮点数的输出时的显示问题，python2.7或3.1之前的版本可能会显示出额外的精度，使用print进行输出即可。python2.7和python3.1之后的版本可以更智能的打印浮点数：12&gt;&gt;&gt; 3.1415 * 2 # repr: as code (Pythons &gt;= 2.7 and 3.1) 6.283 python中每个对象都有两种打印方式：完整精度（代码表示）和用户友好的（字符串）格式。所以当有些看起来奇怪的时候，试试使用print打印出来试试。 除了使用表达式python还提供了一个数字模块math和内置函数。12345&gt;&gt;&gt; import math &gt;&gt;&gt; math.pi 3.141592653589793 &gt;&gt;&gt; math.sqrt(85) 9.219544457292887 python的random模块：12345&gt;&gt;&gt; import random &gt;&gt;&gt; random.random() 0.7082048489415967 &gt;&gt;&gt; random.choice([1, 2, 3, 4]) #从一个list中随机选择1 字符串字符串是一个单个字符的序列列表，元组也是序列的一种。 序列的操作：支持索引(正负数索引)，切片，连接（+号），重复（*号） 不可变性：在创建后不能在原地被更改内容。不能覆盖不可变类型对象的值，但是可以使用相同的名字生成一个新的变量。python会负责回收就变量的空间。 python的每个对象都被分为不可变对象和可变对象：核心数据类型中数字，字符串，元组都属于不可变类型，列表，字典和集合都是可变的 如果想使用可更改的文本数据，可以将字符串转换成list或者，2.6/3.0之后的bytearray类型 字符串转换成list:12345&gt;&gt;&gt; S = 'shrubbery' &gt;&gt;&gt; L = list(S) # Expand to a list: [...] &gt;&gt;&gt; L ['s', 'h', 'r', 'u', 'b', 'b', 'e', 'r', 'y'] &gt;&gt;&gt; L[1] = 'c' # Change it in place &gt;&gt;&gt; ''.join(L) # Join with empty delimiter 字符串转换成bytearray，bytearray支持原地修改，但是只支持每个字符最多8bit的宽度（ASCII）123456&gt;&gt;&gt; B = bytearray(b'spam') # A bytes/list hybrid (ahead) &gt;&gt;&gt; B.extend(b'eggs') # 'b' needed in 3.X, not 2.X &gt;&gt;&gt; B # B[i] = ord(c) works here too bytearray(b'spameggs') &gt;&gt;&gt; B.decode() # Translate to normal string 'spameggs' 其他字符串操作函数1234567891011121314151617&gt;&gt;&gt; S = 'Spam' &gt;&gt;&gt; S.find('pa') # Find the offset of a substring in S&gt;&gt;&gt; S.replace('pa', 'XYZ') # Replace occurrences of a string in S with another&gt;&gt;&gt; line = 'aaa,bbb,ccccc,dd' &gt;&gt;&gt; line.split(',') # Split on a delimiter into a list of substrings&gt;&gt;&gt; S = 'spam' &gt;&gt;&gt; S.upper() # Upper- and lowercase conversions 'SPAM' &gt;&gt;&gt; S.isalpha() # Content tests: isalpha, isdigit, etc.&gt;&gt;&gt; line = 'aaa,bbb,ccccc,dd\n' &gt;&gt;&gt; line.rstrip() # Remove whitespace characters on the right side&gt;&gt;&gt; line.rstrip().split(',') # Combine two operations ['aaa', 'bbb', 'ccccc', 'dd'] 字符串还支持formatting 可以作为表达式或方法调用使用： 1234567&gt;&gt;&gt; '%s, eggs, and %s' % ('spam', 'SPAM!') # Formatting expression (all) 'spam, eggs, and SPAM!' &gt;&gt;&gt; '&#123;0&#125;, eggs, and &#123;1&#125;'.format('spam', 'SPAM!') # Formatting method (2.6+, 3.0+) 'spam, eggs, and SPAM!' &gt;&gt;&gt; '&#123;&#125;, eggs, and &#123;&#125;'.format('spam', 'SPAM!') # Numbers optional (2.7+, 3.1+) 格式化数字格式： 1234&gt;&gt;&gt; '&#123;:,.2f&#125;'.format(296999.2567) # Separators, decimal digits '296,999.26' &gt;&gt;&gt; '%.2f | %+05d' % (3.14159, ?42) # Digits, padding, signs '3.14 | ?0042' Python的跨多类型的通用操作通常由内建函数或表达式完成：len(X), X[0]特定类型的操作由方法调用完成(e.g., aString.upper()). 获得帮助 dir()函数，无参数时显示当前上下文中赋值的所有变量。有参数时会显示传入的对象的所有属性列表。其中带双下划线的属性表示支持自定义重载的属性，例如字符串的add方法实际上执行了连接操作： 1234&gt;&gt;&gt; S + 'NI!' 'spamNI!' &gt;&gt;&gt; S.__add__('NI!') 'spamNI!' 但通常情况下不应该直接调用add来使用它。 help函数用来查看某方法的详细信息： 1&gt;&gt;&gt; help(S.replace) help也是pydoc用来从对象抽取文档的有用接口，pydoc可以将文档渲染为HTML格式来显示 dir和help都可以接受类型名或变量名作为参数 其他字符串编码方法使用转义序列：12&gt;&gt;&gt; S = 'A\nB\tC'&gt;&gt;&gt; S = 'A\0B\0C' Unicode字符串 python2中，str类型的字符串处理8bit字符的字符串（包括ASCII文本）和原始字节值，unicode类型的字符串代表Unicode文本，2.6以后才支持python中的bytes类型的文本，但在python2中bytes仍然被按照str类型处理。Python3中，str类型的字符串可以处理Unicode文本，bytes类型的字符串代表原始的字节值(包括媒体文件和encode后的文本)python3中也支持python2中的Unicode文本，python3中按照str类型的字符串处理。 无论python2还是python3中，非unicode字符串都是8bit字节的序列。unicode字符串都是unicode码点的序列，一个码点就是一个字符的识别号码，存储在文件或内存中时可能占用多个字节，根据编码方式决定。 python2和python3都支持bytearray字符串类型，本质上是一个bytes字符串但是支持大多数list对象的可更改操作。 python2和python3都支持转义非ASCII字符的操作： \x 十六进制\u short Unicode\U long Unicode12&gt;&gt;&gt; 'sp\xc4\u00c4\U000000c4m' #python3中式str，python2中是unicode'sp???m' python2中可以混用str字符串和Unicode字符串：12u'x' + b'y' # Works in 2.X (where b is optional and ignored) u'x' + 'y' # Works in 2.X: u'xy' python3中不允许混用str字符串与bytes字符串，除非进行强制转换：1234u'x' + b'y' # Fails in 3.3 (where u is optional and ignored) u'x' + 'y' # Works in 3.3: 'xy' 'x' + b'y'.decode() # Works in 3.X if decode bytes to str: 'xy' 'x'.encode() + b'y' # Works in 3.X if encode str to bytes: b'xy' Unicode处理通常在将文本数据存入文件和从文件读出文本数据时进行：文本被编码成bytes存入文件，从文件读入内存时又被解码为字符。文本被加载后我们通常仅使用解法后的格式进行文本处理。 根据这个模型，python3中文件被按内容分为：文本文件和二进制文件。python2中正常文件内容是str类型的字节，使用专门的codecs模块处理Unicode并且使用unicode类型表示文件内容。 模式匹配使用re模块的方法进行查找，拆分，替换：1234567891011&gt;&gt;&gt; import re &gt;&gt;&gt; match = re.match('Hello[ \t]*(.*)world', 'Hello Python world') &gt;&gt;&gt; match.group(1) 'Python '&gt;&gt;&gt; match = re.match('[/:](.*)[/:](.*)[/:](.*)', '/usr/home:lumberjack') &gt;&gt;&gt; match.groups() ('usr', 'home', 'lumberjack') &gt;&gt;&gt; re.split('[/:]', '/usr/home/lumberjack') ['', 'usr', 'home', 'lumberjack'] 列表 [list]python中最常见的序列，顺序固定的任意类型对象的集合，无固定大小，属于可变数据类型，支持的操作包括： 序列的通用操作123456789101112131415&gt;&gt;&gt; L = [123, 'spam', 1.23] # A list of three different-type objects &gt;&gt;&gt; len(L) # Number of items in the list 3索引，分片等&gt;&gt;&gt; L[0] # Indexing by position 123 &gt;&gt;&gt; L[:-1] # Slicing a list returns a new list [123, 'spam'] &gt;&gt;&gt; L + [4, 5, 6] # Concat/repeat make new lists too [123, 'spam', 1.23, 4, 5, 6] &gt;&gt;&gt; L * 2 [123, 'spam', 1.23, 123, 'spam', 1.23] &gt;&gt;&gt; L # We're not changing the original list [123, 'spam', 1.23] list类型特有的操作1234567891011121314151617&gt;&gt;&gt; L.append('NI')&gt;&gt;&gt; L [123, 'spam', 1.23, 'NI']&gt;&gt;&gt; L.pop(2)1.23 &gt;&gt;&gt; L # "del L[2]" deletes from a list too [123, 'spam', 'NI']&gt;&gt;&gt; M = ['bb', 'aa', 'cc'] &gt;&gt;&gt; M.sort() &gt;&gt;&gt; M ['aa', 'bb', 'cc'] &gt;&gt;&gt; M.reverse() &gt;&gt;&gt; M ['cc', 'bb', 'aa'] 边界检查虽然list没有固定大小，python不允许引用不存在的项目，也不能通过给超出边界的值赋值，不会自动扩展：12345678910&gt;&gt;&gt; L [123, 'spam', 'NI'] &gt;&gt;&gt; L[99] ...error text omitted... IndexError: list index out of range &gt;&gt;&gt; L[99] = 1 ...error text omitted... IndexError: list assignment index out of range 嵌套python的核心数据类型都支持任意深度的嵌套。123456&gt;&gt;&gt; rec = &#123;'name': &#123;'first': 'Bob', 'last': 'Smith'&#125;, 'jobs': ['dev', 'mgr'], 'age': 40.5&#125;&gt;&gt;&gt; rec['jobs'].append('janitor') # Expand Bob's job description in place &gt;&gt;&gt; rec &#123;'age': 40.5, 'jobs': ['dev', 'mgr', 'janitor'], 'name': &#123;'last': 'Smith', 'first': 'Bob'&#125;&#125; python中当一个对象的最后一个引用消失后其内存空间会被立即回收。 列表解析 list comprehension expression12345&gt;&gt;&gt; M [[1, 2, 3], [4, 5, 6], [7, 8, 9]]&gt;&gt;&gt; col2 = [row[1] for row in M] # Collect the items in column 2 &gt;&gt;&gt; col2 [2, 5, 8] 通过对序列中的每个item运行一个表达式来构造一个新的list，一次一个，从左到右。在方括号中编码表示将产生一个list 12345678910&gt;&gt;&gt; [row[1] + 1 for row in M] # Add 1 to each item in column 2&gt;&gt;&gt; [row[1] for row in M if row[1] % 2 == 0] # Filter out odd items&gt;&gt;&gt; diag = [M[i][i] for i in [0, 1, 2]] # Collect a diagonal from matrix &gt;&gt;&gt; diag [1, 5, 9]&gt;&gt;&gt; doubles = [c * 2 for c in 'spam'] # Repeat characters in a string &gt;&gt;&gt; doubles ['ss', 'pp', 'aa', 'mm'] 使用range生成list 123456789&gt;&gt;&gt; list(range(4)) # 0..3 (list() required in 3.X) [0, 1, 2, 3] &gt;&gt;&gt; list(range(?6, 7, 2)) # ?6 to +6 by 2 (need list() in 3.X) [?6, ?4, ?2, 0, 2, 4, 6] &gt;&gt;&gt; [[x ** 2, x ** 3] for x in range(4)] # Multiple values, "if" filters [[0, 0], [1, 1], [4, 8], [9, 27]] &gt;&gt;&gt; [[x, x / 2, x * 2] for x in range(?6, 7, 2) if x &gt; 0] [[2, 1, 4], [4, 2, 8], [6, 3, 12]] 解析的语法不仅可以用来生成新的list，圆括号中的解析语法可以创建一个生成器，根据需求产生结果： 1234567&gt;&gt;&gt; G = (sum(row) for row in M) # Create a generator of row sums &gt;&gt;&gt; next(G) # iter(G) not required here6 &gt;&gt;&gt; next(G) # Run the iteration protocol next() 15 &gt;&gt;&gt; next(G) 24 map内建函数也可以做类似的工作，通过一个函数处理items产生结果，根据请求一次一个 python3中需要使用list()返回所有的值，python2中会自动返回所有结果的一个list12&gt;&gt;&gt; list(map(sum, M)) # Map sum over items in M 与上例比较[6, 15, 24] python2.7和python3中解析语法可以用来创建集合和字典： 12345&gt;&gt;&gt; &#123;sum(row) for row in M&#125; # Create a set of row sums &#123;24, 6, 15&#125; &gt;&gt;&gt; &#123;i : sum(M[i]) for i in range(3)&#125; # Creates key/value table of row sums &#123;0: 6, 1: 15, 2: 24&#125; 所以python3和python2.7中，列表，集合，字典，生成器都可以由解析创建： 12345678&gt;&gt;&gt; [ord(x) for x in 'spaam'] # List of character ordinals [115, 112, 97, 97, 109] &gt;&gt;&gt; &#123;ord(x) for x in 'spaam'&#125; # Sets remove duplicates &#123;112, 97, 115, 109&#125; &gt;&gt;&gt; &#123;x: ord(x) for x in 'spaam'&#125; # Dictionary keys are unique &#123;'p': 112, 'a': 97, 's': 115, 'm': 109&#125; &gt;&gt;&gt; (ord(x) for x in 'spaam') # Generator of values &lt;generator object &lt;genexpr&gt; at 0x000000000254DAB0&gt; 字典字典不是序列，而是mapping，通过使用key而非相对位置存储对象。字典是python核心数据类型里唯一的mapping类型，是可变对象 mapping类型的操作 字典的定义： 1&gt;&gt;&gt; D = &#123;'food': 'Spam', 'quantity': 4, 'color': 'pink'&#125; 字典的检索： 12&gt;&gt;&gt; D['food'] # Fetch value of key 'food'&gt;&gt;&gt; D['quantity'] += 1 # Add 1 to 'quantity' value 通过给字典中不存在的key条目赋值可以创建该条目： 12&gt;&gt;&gt; D = &#123;&#125; &gt;&gt;&gt; D['name'] = 'Bob' # Create keys by assignment 一些应用情境下，字典被用作查找操作，通过key来索引字典通常是python中编写搜索程序速度最快的选择 其它声明字典的方法： 12&gt;&gt;&gt; bob1 = dict(name='Bob', job='dev', age=40) # Keywords&gt;&gt;&gt; bob2 = dict(zip(['name', 'job', 'age'], ['Bob', 'dev', 40]))# Zipping 相当于两列对应合并生成字典。 注意mapping并不维护key-value对出现的顺序，可能会根据python版本不同而不同 虽然字典可以通过给一个不存在的key赋值创建它，但是试图获取一个不存在的key会产生错误： 1234567&gt;&gt;&gt; D = &#123;'a': 1, 'b': 2, 'c': 3&#125; &gt;&gt;&gt; D['e'] = 99 # Assigning new keys grows dictionaries &gt;&gt;&gt; D &#123;'a': 1, 'c': 3, 'b': 2, 'e': 99&#125;&gt;&gt;&gt; D['f'] # Referencing a nonexistent key is an error ...error text omitted... KeyError: 'f' 此时可以先测试f是否在D中存在： 12&gt;&gt;&gt; if not 'f' in D: # Python's sole selection statement print('missing') 除了in测试还可以使用：get方法或带默认值的条件索引 1234567&gt;&gt;&gt; value = D.get('x', 0) # Index but with a default &gt;&gt;&gt; value 0 &gt;&gt;&gt; value = D['x'] if 'x' in D else 0 # if/else expression form &gt;&gt;&gt; value 0 对字典进行排序: 三步法 1234567891011&gt;&gt;&gt; D = &#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; Ks = list(D.keys()) # Unordered keys list &gt;&gt;&gt; Ks # A list in 2.X, "view" in 3.X: use list() ['a', 'c', 'b']&gt;&gt;&gt; Ks.sort() # Sorted keys list &gt;&gt;&gt; Ks ['a', 'b', 'c']&gt;&gt;&gt; for key in Ks: # Iterate though sorted keys print(key, '=&gt;', D[key])# &lt;== press Enter twice here (3.X print) 在较新的python中，支持sorted内建函数进行自动排序： 12&gt;&gt;&gt; for key in sorted(D): print(key, '=&gt;', D[key]) for循环是对序列（实际上是生成器）进行遍历操作的最佳方式：12&gt;&gt;&gt; for c in 'spam': print(c.upper()) 迭代和优化for循环和列表解析表达式都是通用的迭代工具，实际上他们都可以工作在任何遵循迭代协议的可迭代对象上。 迭代协议：是指要实现对象的 __iter()__ 和 next() 方法（注意：Python3 要实现 __next__() 方法），其中，__iter()__ 方法返回迭代器对象本身，next() 方法返回容器的下一个元素，在没有后续元素时抛出 StopIteration 异常。一个对象可迭代： 此对象物理地存储在顺序的内存空间中 对象在每一次迭代操作时都生成一个item（一种虚拟的序列） 生成器列表表达式就是这样一个对象：它的所有值并不存储在相邻的内存单元中，但是可以随请求产生值。 python的文件对象被迭代工具使用时也可以一行一行的迭代，文件的内容并不在list里，而是根据迭代工具的需要进行读取。 以前的例子中sorted可以工作在字典上就是因为字典符合迭代协议。 任何列表解析都可以写成相应的循环：1&gt;&gt;&gt; squares = [x ** 2 for x in [1, 2, 3, 4, 5]] 等价于123&gt;&gt;&gt; squares = [] &gt;&gt;&gt; for x in [1, 2, 3, 4, 5]: # This is what a list comprehension does squares.append(x ** 2) # Both run the iteration protocol internally 但是列表解析，map，filter通常比for循环的写法执行速度更快，处理大数据集合时会获得性能提升。 python代码的主要准则是简单和稳定，然后才是性能。python也提供了衡量运行速度的工具time和timeit模块，profile模块用来确定性能瓶颈。 元组类似list，但不能修改，tuples与list一样是序列，但是是不可变类型的。通常被用来表示元素的固定集合。1&gt;&gt;&gt; T = (1, 2, 3, 4) # A 4-item tuple 元组也具备一些自己的方法12345&gt;&gt;&gt; T.index(4) # Tuple methods: 4 appears at offset 3 3 &gt;&gt;&gt; T.count(4) # 4 appears once 1&gt;&gt;&gt; T = (2,) + T[1:] # Make a new tuple for a new value 元组，与列表和字典相似，也支持混合数据类型和嵌套。但是它是不可变的不能增长或缩减。1&gt;&gt;&gt; T = 'spam', 3.0, [11, 22, 33] 文件文件对象是Python操作外部文件的主要接口。 文件对象是一个核心类型但是没有专门用来创建这个对象的语法，内建的open函数接受一个外部文件名和可选的处理模式字符串可以创建一个文件对象。123456&gt;&gt;&gt; f = open('data.txt', 'w') # Make a new file in output mode ('w' is write) &gt;&gt;&gt; f.write('Hello\n') # Write strings of characters to it 6 &gt;&gt;&gt; f.write('world\n') # Return number of items written in Python 3.X 6 &gt;&gt;&gt; f.close() # Close to flush output buffers to disk 无论文件中存储的是什么数据类型，脚本中的文件内容总是一个字符串。1234&gt;&gt;&gt; f = open('data.txt') # 'r' (read) is the default processing mode &gt;&gt;&gt; text = f.read() # Read entire file into a string &gt;&gt;&gt; text 'Hello\nworld\n' 文件对象还提供了很多其他的方法，read接受一个最大读入的字节或字符数量，readline一次读一行。 但是实际上最好的读入文件的方法是不是用read方法，文件对象提供了一个迭代器可以自动的为for循环和其它上下文按行读入：1&gt;&gt;&gt; for line in open('data.txt'): print(line) 二进制文件 python2中使用文件的8bit字节自然表示。python2中字符串会被原封不动的写入到文本文件中，不会自动编码。python3中依赖于平台的Unicode默认编码。Python3中文本文件中的字符串总是会被编码。python3中的文本和二进制文件有严格地区分，文本文件表示其内容会作为str字符串，并且在写入和读出时自动进行unicode编码和解码。而二进制文件的内容是bytes类型的字符串，允许无改变的访问文件内容。 在处理媒体文件，访问C语言创建的数据文件时二进制文件是很有用的。例如python的struct模块可以用来创建或解包二进制数据包1234567&gt;&gt;&gt; import struct &gt;&gt;&gt; packed = struct.pack('&gt;i4sh', 7, b'spam', 8) # Create packed binary data &gt;&gt;&gt; packed # 10 bytes, not objects or text b'\x00\x00\x00\x07spam\x00\x08' &gt;&gt;&gt; file = open('data.bin', 'wb') # Open binary output file &gt;&gt;&gt; file.write(packed) # Write packed binary data 10 &gt;&gt;&gt; file.close() Unicode文本文件如果要访问包含与默认编码不同的非ASCII的Unicode文本的文件时只需要在打开文件时传入一个编码名称的参数。python在读出和写入时会自动使用提供的编码进行编解码。一般情况下自动的编解码正是我们想要的，但如果想一探真正存储在文件中的内容时可以使用二进制模式打开文件。手工进行编解码。python2中的方法几乎相同，Unicode字符串会使用u前缀显示，unicode文本文件必须使用codecs.open打开，这个方法与python3的open一样接受一个编码名称参数。1234567&gt;&gt;&gt; import codecs &gt;&gt;&gt; codecs.open('unidata.txt', encoding='utf8').read() # 2.X: read/decode text u'sp\xc4m' &gt;&gt;&gt; open('unidata.txt', 'rb').read() # 2.X: read raw bytes 'sp\xc3\x84m' &gt;&gt;&gt; open('unidata.txt').read() # 2.X: raw/undecoded too 'sp\xc3\x84m' 其它文件类型的工具open用于大多数的文件操作python还提供多种工具用于：管道，FIFO，sockets，keyed-access files, persistent object shelves, descriptor-based files, relational and object-oriented database interfaces 其它核心类型集合 无序的单一集合，不可变对象： 123456&gt;&gt;&gt; X = set('spam') # Make a set out of a sequence in 2.X and 3.X &gt;&gt;&gt; Y = &#123;'h', 'a', 'm'&#125; # Make a set with set literals in 3.X and 2.7 &gt;&gt;&gt; X, Y # A tuple of two sets without parentheses (&#123;'m', 'a', 'p', 's'&#125;, &#123;'m', 'a', 'h'&#125;) &gt;&gt;&gt; X &amp; Y # Intersection &#123;'m', 'a'&#125; &gt;&gt;&gt; X | Y # Union &#123;'m', 'h', 'a', 'p', 's'&#125; &gt;&gt;&gt; X - Y # Difference 集合常被用作去重操作，寻找差异，不排序的相等比较等： 123456&gt;&gt;&gt; list(set([1, 2, 1, 3, 1])) # Filtering out duplicates (possibly reordered) [1, 2, 3] &gt;&gt;&gt; set('spam') - set('ham') # Finding differences in collections &#123;'p', 's'&#125; &gt;&gt;&gt; set('spam') == set('asmp') # Order-neutral equality tests (== is False) True 支持成员关系测试：12&gt;&gt;&gt; 'p' in set('spam'), 'p' in 'spam', 'ham' in ['eggs', 'spam', 'ham'] (True, True, True) python还新增了一些新的数值类型：小数（固定精度的浮点数），分数python具有布尔类型和None类型12345678&gt;&gt;&gt; 1 &gt; 2, 1 &lt; 2 # Booleans (False, True) &gt;&gt;&gt; bool('spam') # Object's Boolean value True &gt;&gt;&gt; X = None # None placeholder &gt;&gt;&gt; print(X) None python中不建议根据对象的类型进行编码，会降低代码的适应性1234567891011# In Python 2.X: &gt;&gt;&gt; type(L) # Types: type of L is list type object &lt;type 'list'&gt; &gt;&gt;&gt; type(type(L)) # Even types are objects &lt;type 'type'&gt; # In Python 3.X: &gt;&gt;&gt; type(L) # 3.X: types are classes, and vice versa &lt;class 'list'&gt; &gt;&gt;&gt; type(type(L)) # See Chapter 32 for more on class types &lt;class 'type'&gt; 用于测试对象的类型的方法：1234567891011&gt;&gt;&gt; if type(L) == type([]): # Type testing, if you must... print('yes') yes &gt;&gt;&gt; if type(L) == list: # Using the type name print('yes') yes &gt;&gt;&gt; if isinstance(L, list): # Object-oriented tests print('yes') yes 用户自定义的类数值类型python内部数据是用对象的形式表示的：python提供的内部对象或使用python工具和其它语言创建的对象。 python内部的数值类型并不是单独的一个类型，而是一系列相似的类型： 整数与浮点数对象 复数对象 固定精度的小数对象 分数对象 集合对象 布尔对象 内建函数和模块，round,math,random等 表达式；无限精度的整数；位操作；十六进制，八进制和二进制格式。 第三方扩展：vectors, libraries, visualization, plotting等 数值字符串 无限大小的整数：1234, ?24, 0, 99999999999999 浮点数：1.23, 1., 3.14e-10, 4E210, 4.0e+210 #在Cpython中使用C语言的double实现。 python3中的八进制，十六进制与二进制数字：0o177, 0x9ff, 0b101010 python2中的八进制，十六进制与二进制数字：177, 0o177, 0x9ff, 0b101010 复数：3+4j, 3.0+4.0j, 3J 集合：set(&#39;spam&#39;), {1, 2, 3, 4} 小数与分数：Decimal(&#39;1.0&#39;), Fraction(1, 3) 布尔类型：bool(X), True, False 整数以十进制数字字符串的写法出现，可带正负号，无穷精度。带一个小数点，或带科学技术标志e或E时python会将它变成一个浮点数对象，用在表达式中时将启用浮点数的运算法则，其精度与用来build python解释器的C编译器所给定的双精度一样。 十六进制 0x/0X开头+0-9和A-F大小写均可，八进制0o/0O+0-7，二进制0b/0B+0-1。 所有这些常量都产生一个整数对象，hex(I),oct(I),bin(I)把一个整数I转换成相应进制的字符串。int(str,base)将给定进制的字符串转换成一个整数。 python2中的整数包括正常整数（32位）与long整数，当需要更高精度整数时会自动进行转换。python3中只有一种整数类型，自动支持了无限精度，这个改变不会影响应用，除非应用中做了针对python2的long整型的类型检测。 十六进制，八进制，二进制数值字符串：只是整型对象值的不同语法表示，可以使用内建函数hex(I),oct(I)和bin(I)将整数转换成相应的表示字符串，或int(str, base)将runtime的字符串转化为给定base的整型数值。 复数，包括实部和虚部，实部是可选的，实部+虚部j/J的方式，或通过complex(real,imag)来创建。 内建数值工具 表达式操作符：+, -, *, /, &gt;&gt;, **, &amp; etc. 内建数学函数：pow, abs, round, int, hex, bin etc. 工具模块：random, math etc. 表达式操作符优先级升高顺序： yield x 生成器函数发送协议lambda args: expression 生成匿名函数x if y else z 三元选择表达式x or yx and ynot xx in y , x not in y 成员关系x is y , x is not y 对象实体测试x &lt; y, x &lt;= y, x &gt; y, x &gt;= yx == y, x!=yx | yx ^ yx &amp; yx &lt;&lt; y, x &gt;&gt; yx + y, x - y 加法/合并，减法/集合差集x * y , x % y , x / y , x // y 乘法/重复，余数/格式化，真除法，floor除法-x, +x 一元减法，识别~x 按位求补（取反）x ** y 幂运算x[i] 索引x[i:j:k] 分片x(…) 调用（函数，方法，类及其它可调用的）x.attr 属性引用(…) 元组，表达式，生成器表达式。[…] 列表，列表解析{…} 字典，集合，集合和字典解析。 python2中可以使用X != Y or X &lt;&gt; Y进行不等于测试python3中仅可以使用X != Ypython2中可以使用反引号X代替repr(X)将X转换为字符串显示python3中反引号被移除，只能使用str()或repr()python2和python3中X//Y (floor除法)均会舍弃小数部分保留整数，但是结果的类型与操作数类型有关。python2中X/Y传统除法对于整数运算舍弃小数取整，对于浮点数会保留小数python3中X/Y进行真除法运算，无论整数和浮点数都保留小数部分得到带小数的结果值。 […]语法用于列表初始化和列表解析表达式 (…)语法用于元组初始化，表达式分组与生成器表达式（列表解析的一种用于根据需要产生值）。 {…}语法用于字典初始化，集合初始化，字典与集合解析 yield与if/else语法在python2.5以后可用。 分片表达式X[I:J:K]与使用slice对象的索引相等X[slice(I, J, K)] 混合类型的数值在同一个表达式中共同使用时python会自动转换到最复杂的数值类型。 floor和truncate floor向下取整，小于真实结果的最近的一个整数 trunc向0取证 123456789101112131415161718192021222324&gt;&gt;&gt; import math &gt;&gt;&gt; math.floor(2.5) # Closest number below value 2 &gt;&gt;&gt; math.floor(-2.5) -3 &gt;&gt;&gt; math.trunc(2.5) # Truncate fractional part (toward zero) 2 &gt;&gt;&gt; math.trunc(-2.5) -2&gt;&gt;&gt; (5 / 2), (5 / 2.0), (5 / ?2.0), (5 / ?2) # 3.X true division (2.5, 2.5, ?2.5, ?2.5) &gt;&gt;&gt; (5 // 2), (5 // 2.0), (5 // ?2.0), (5 // ?2)# 3.X floor division (2, 2.0, ?3.0, ?3) &gt;&gt;&gt; (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0) # Both (3.0, 3.0, 3, 3.0)&gt;&gt;&gt; (5 / 2), (5 / 2.0), (5 / ?2.0), (5 / ?2) # 2.X classic division (differs) (2, 2.5, ?2.5, ?3) &gt;&gt;&gt; (5 // 2), (5 // 2.0), (5 // ?2.0), (5 // ?2)# 2.X floor division (same) (2, 2.0, ?3.0, ?3) &gt;&gt;&gt; (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0) # Both (3, 3.0, 3, 3.0) 复数十六进制，八进制，二进制的数值与转换位操作其它内置数学工具123456789101112131415161718192021222324252627&gt;&gt;&gt; import math&gt;&gt;&gt; math.pi, math.e # Common constants (3.141592653589793, 2.718281828459045) &gt;&gt;&gt; math.sin(2 * math.pi / 180) # Sine, tangent, cosine 0.03489949670250097&gt;&gt;&gt; math.sqrt(144), math.sqrt(2) # Square root (12.0, 1.4142135623730951) &gt;&gt;&gt; pow(2, 4), 2 ** 4, 2.0 ** 4.0 # Exponentiation (power) (16, 16, 16.0) &gt;&gt;&gt; abs(-42.0), sum((1, 2, 3, 4)) # Absolute value, summation (42.0, 10) &gt;&gt;&gt; min(3, 1, 2, 4), max(3, 1, 2, 4) # Minimum, maximum (1, 4)&gt;&gt;&gt; math.floor(2.567), math.floor(-2.567) # Floor (next-lower integer) (2, ?3) &gt;&gt;&gt; math.trunc(2.567), math.trunc(?2.567) # Truncate (drop decimal digits) (2, ?2) &gt;&gt;&gt; int(2.567), int(?2.567) # Truncate (integer conversion) (2, ?2) &gt;&gt;&gt; round(2.567), round(2.467), round(2.567, 2) # Round (Python 3.X version)(3, 2, 2.57) &gt;&gt;&gt; '%.1f' % 2.567, '&#123;0:.2f&#125;'.format(2.567) # Round for display (Chapter 7) ('2.6', '2.57')&gt;&gt;&gt; (1 / 3.0), round(1 / 3.0, 2), ('%.2f' % (1 / 3.0)) (0.3333333333333333, 0.33, '0.33') 例如计算开方有三种方法：1234567&gt;&gt;&gt; import math &gt;&gt;&gt; math.sqrt(144) # Module 12.0 &gt;&gt;&gt; 144 ** .5 # Expression 12.0 &gt;&gt;&gt; pow(144, .5) # Built-in 12.0 产生随机数12345678910111213141516171819202122&gt;&gt;&gt; import random &gt;&gt;&gt; random.random()0.5566014960423105 &gt;&gt;&gt; random.random() # Random floats, integers, choices, shuffles 0.051308506597373515&gt;&gt;&gt; random.randint(1, 10) 5 &gt;&gt;&gt; random.randint(1, 10) 9&gt;&gt;&gt; random.choice(['Life of Brian', 'Holy Grail', 'Meaning of Life']) 'Holy Grail' &gt;&gt;&gt; random.choice(['Life of Brian', 'Holy Grail', 'Meaning of Life']) 'Life of Brian' &gt;&gt;&gt; suits = ['hearts', 'clubs', 'diamonds', 'spades'] &gt;&gt;&gt; random.shuffle(suits) &gt;&gt;&gt; suits ['spades', 'hearts', 'diamonds', 'clubs'] &gt;&gt;&gt; random.shuffle(suits) &gt;&gt;&gt; suits ['clubs', 'diamonds', 'hearts', 'spades'] 其它数值类型小数对象import decimal 能修正浮点数不精确的现象。小数的上下文管理器，用于重新设定精度。1234567891011&gt;&gt;&gt; 0.1 + 0.1 + 0.1 - 0.3 # Python 3.3 5.551115123125783e-17&gt;&gt;&gt; from decimal import Decimal &gt;&gt;&gt; Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3') Decimal('0.0')&gt;&gt;&gt; Decimal('0.1') + Decimal('0.10') + Decimal('0.10') - Decimal('0.30') Decimal('0.00')&gt;&gt;&gt; Decimal(0.1) + Decimal(0.1) + Decimal(0.1) - Decimal(0.3) Decimal('2.775557561565156540423631668E-17') 设定全局的精度123456789&gt;&gt;&gt; import decimal &gt;&gt;&gt; decimal.Decimal(1) / decimal.Decimal(7) # Default: 28 digits Decimal('0.1428571428571428571428571429') &gt;&gt;&gt; decimal.getcontext().prec = 4 # Fixed precision &gt;&gt;&gt; decimal.Decimal(1) / decimal.Decimal(7) Decimal('0.1429') &gt;&gt;&gt; Decimal(0.1) + Decimal(0.1) + Decimal(0.1) - Decimal(0.3) # Closer to 0 Decimal('1.110E-17') 小数上下文管理器: 使用with上下文管理器语句临时的改变小数的精度。1234567891011&gt;&gt;&gt; import decimal &gt;&gt;&gt; decimal.Decimal('1.00') / decimal.Decimal('3.00') Decimal('0.3333333333333333333333333333') &gt;&gt;&gt; with decimal.localcontext() as ctx: ... ctx.prec = 2 ... decimal.Decimal('1.00') / decimal.Decimal('3.00') ... Decimal('0.33') &gt;&gt;&gt; decimal.Decimal('1.00') / decimal.Decimal('3.00') Decimal('0.3333333333333333333333333333') 分数类型分数实现了一个有理数对象，import fractions,保持精确性，并自动简化结果。类型转换和混合类型。12345678910&gt;&gt;&gt; from fractions import Fraction &gt;&gt;&gt; x = Fraction(1, 3) # Numerator, denominator &gt;&gt;&gt; y = Fraction(4, 6) # Simplified to 2, 3 by gcd&gt;&gt;&gt; x + y Fraction(1, 1) &gt;&gt;&gt; x ? y Fraction(?1, 3) &gt;&gt;&gt; x * y Fraction(2, 9) 也可以使用浮点数来创建分数对象：123456&gt;&gt;&gt; Fraction('.25') Fraction(1, 4) &gt;&gt;&gt; Fraction('1.25') Fraction(5, 4) &gt;&gt;&gt; Fraction('.25') + Fraction('1.25') Fraction(3, 2) 分数的转换：1234&gt;&gt;&gt; (2.5).as_integer_ratio() # float object method (5, 2) &gt;&gt;&gt; f = 2.5 &gt;&gt;&gt; z = Fraction(*f.as_integer_ratio()) # Convert float -&gt; fraction: two args *符号是一种可以将元组展开成单独参数的特殊语法。12345678910111213&gt;&gt;&gt; z # Same as Fraction(5, 2) Fraction(5, 2)&gt;&gt;&gt; x # x from prior interaction Fraction(1, 3) &gt;&gt;&gt; x + z Fraction(17, 6) # 5/2 + 1/3 = 15/6 + 2/6 &gt;&gt;&gt; float(x) # Convert fraction -&gt; float 0.3333333333333333 &gt;&gt;&gt; float(z) 2.5 &gt;&gt;&gt; float(x + z) 2.8333333333333335 将浮点数转换为分数的两种方法：123456789101112&gt;&gt;&gt; Fraction.from_float(1.75) # Convert float -&gt; fraction: other way Fraction(7, 4)&gt;&gt;&gt; Fraction(*(1.75).as_integer_ratio()) Fraction(7, 4)&gt;&gt;&gt; (4.0 / 3).as_integer_ratio() # Precision loss from float (6004799503160661, 4503599627370496) &gt;&gt;&gt; x Fraction(1, 3) &gt;&gt;&gt; a = x + Fraction(*(4.0 / 3).as_integer_ratio()) &gt;&gt;&gt; a Fraction(22517998136852479, 13510798882111488) 通过限制分母的最大值简化分数。12&gt;&gt;&gt; a.limit_denominator(10) # Simplify to closest fraction Fraction(5, 3) 集合唯一的不可变对象的一个无序集合，一个项在集合中只能出现一次。可迭代，可根据需要增长缩短，能包含各种对象类型。1234567x = set(‘abcde’)‘e’ in xx - y 差集x | y 并集x &amp; y 交集x ^ y 异或x &gt; y , x &lt; y 超级，子集。 成员测试：1234&gt;&gt;&gt; 'e' in x # Membership (sets) True &gt;&gt;&gt; 'e' in 'Camelot', 22 in [11, 22, 33] # But works on other types too (True, True) 集合的方法： 123456x.intersection(y) 与 x &amp; y相同z.add('SPAM') 增加一个项目z.remove('b') 删除一个项目z.update(set['X','Y']) 合并s.union()s.issubset() 集合是一个可迭代的容器，可以被用于len，for循环和列表解析 1&gt;&gt;&gt; for item in set('abc'): print(item * 3) python3与python2.7中，集合表示为{1,2,3,4}无值的字典，等价于set([1, 2, 3, 4])。python2.7与python3都可以接受这两种方式的初始化，但是显示方法会不同。 空集合必须通过set来创建。 注意：集合只能包含不可变的对象类型，因此列表和字典不能嵌入集合，元组可以嵌入。 python3与python2.7中集合的解析语法：12345678910&gt;&gt;&gt; &#123;x ** 2 for x in [1, 2, 3, 4]&#125; # 3.X/2.7 set comprehension &#123;16, 1, 4, 9&#125;&gt;&gt;&gt; &#123;x for x in 'spam'&#125; # Same as: set('spam') &#123;'m', 's', 'p', 'a'&#125; &gt;&gt;&gt; &#123;c * 4 for c in 'spam'&#125; # Set of collected expression results &#123;'pppp', 'aaaa', 'ssss', 'mmmm'&#125; &gt;&gt;&gt; &#123;c * 4 for c in 'spamham'&#125; &#123;'pppp', 'aaaa', 'hhhh', 'ssss', 'mmmm'&#125; 集合的用途： 去除list中重复项 12345678910111213&gt;&gt;&gt; list(set(['yy', 'cc', 'aa', 'xx', 'dd', 'aa'])) # But order may change ['cc', 'xx', 'yy', 'dd', 'aa']&gt;&gt;&gt; set([1, 3, 5, 7]) - set([1, 2, 4, 5, 6]) # Find list differences &#123;3, 7&#125; &gt;&gt;&gt; set('abcdefg') - set('abdghij') # Find string differences &#123;'c', 'e', 'f'&#125; &gt;&gt;&gt; set('spam') - set(['h', 'a', 'm']) # Find differences, mixed &#123;'p', 's'&#125; &gt;&gt;&gt; set(dir(bytes)) - set(dir(bytearray)) # In bytes but not bytearray &#123;'__getnewargs__'&#125; &gt;&gt;&gt; set(dir(bytearray)) - set(dir(bytes)) &#123;'append', 'copy', '__alloc__', '__imul__', 'remove', 'pop', 'insert', ...more...] 无序的集合比较 123456789&gt;&gt;&gt; L1, L2 = [1, 3, 5, 2, 4], [2, 5, 3, 4, 1] &gt;&gt;&gt; L1 == L2 # Order matters in sequences False &gt;&gt;&gt; set(L1) == set(L2) # Order-neutral equality True &gt;&gt;&gt; sorted(L1) == sorted(L2) # Similar but results ordered True &gt;&gt;&gt; 'spam' == 'asmp', set('spam') == set('asmp'), sorted('spam') == sorted('asmp') (False, True, True) 遍历图形或回还结构时用来记录访问过的位置。 布尔型bool有两个值True False123456789101112&gt;&gt;&gt; type(True) &lt;class 'bool'&gt; &gt;&gt;&gt; isinstance(True, int) True&gt;&gt;&gt; True == 1 # Same value True &gt;&gt;&gt; True is 1 # But a different object: see the next chapter False &gt;&gt;&gt; True or False # Same as: 1 or 0 True &gt;&gt;&gt; True + 4 # (Hmmm) 5 数字扩展NumPy动态类型简介python中没有声明语句，python中变量的类型是在运行中自动决定的。 变量的创建: 第一次赋值时创建它，之后的赋值改变变量名的值。 python变量永远不会有任何和他关联的类型信息，类型的概念在于对象中而不是变量名。 变量出现在表达式中时马上会被该变量引用的对象代替。变量必须在使用前明确的赋值，引用未赋值的变量会出错。 变量被赋予了新的对象值时，之前的对象内存会被回收-垃圾收集。 共享引用123a = 3 b = a 两个变量名引用到了同一个对象a = a + 2 此后b的值并不会改变。 对于可在原地修改的对象，共享引用要小心，例如列表1234567L1 = [2,3,4]L2 = L1L1[0] = 24 #此后L2的值也会发生改变L1 = [2,3,4]L2 = L1[:]L1[0] = 24 #此时L2是L1的一个拷贝 对于字典和集合使用import copy 复制。123import copy X = copy.copy(Y) # Make top-level "shallow" copy of any object Y X = copy.deepcopy(Y) # Make deep copy of any object Y: copy all nested parts 共享引用和相等测试： 由于python的引用模型，有两种用于检测相等性的方法：1234L = [1,2,3] M = LL == M 测试被引用的对象是否有相同的值，不一定是相同的对象L is M 测试两个变量名是否精确的指向同一个对象。内部实现上仅检测引用的指针是否相同 比较下面两个例子：12345678910111213&gt;&gt;&gt; L = [1, 2, 3] &gt;&gt;&gt; M = [1, 2, 3] # M and L reference different objects &gt;&gt;&gt; L == M # Same values True &gt;&gt;&gt; L is M # Different objects False&gt;&gt;&gt; X = 42 &gt;&gt;&gt; Y = 42 # Should be two different objects &gt;&gt;&gt; X == Y True &gt;&gt;&gt; X is Y # Same object anyhow: caching at work! 实际上X与Y指向相同的对象，这是因为小整数和字符串会被缓存和重用。True 查看某对象的引用次数：123&gt;&gt;&gt; import sys &gt;&gt;&gt; sys.getrefcount(1) # 647 pointers to this shared piece of memory 647 字符串字符串：一个有序的字符集合。 python没有单个字符的类型，可以使用一个字符的字符串，python字符串被划分为不可变序列类别。 python3中有3种字符串类型：str用作unicode文本（包括ascii），bytes用作二进制数据（包括encoded的文本），bytearray是bytes的可变形式。python3中的文件工作在两种模式：text文本模式：内容表示为str字符串，实现了unicode编码，二进制文件模式：用来处理原始的bytes不做数据转换。python2中unocode字符串表示unicode文本，str字符串处理8bit的文本和二进制数据，bytearray在python2.6之后可用。python2中普通文件的内容只是bytes，表示为str字符串。codecs模块可以打开unicode文本文件处理编码，将文件内容表示为unicode字符串对象。 字符串基础类似C语言中的字符数组，但是包含了一些更高级的处理工具，python中没有字符类型，只能使用一个字符的字符串。 python的字符串是不可变对象，从左到右的位置顺序固定并且不能在原地更改（序列对象的一种）。 常见的字符串常量和表达式1234567891011121314151617181920212223242526272829S = '' 空字符串S = "spam's" 双引号，与单引号相同S = 's\np\ta\x00m' 转义序列S = """...multiline...""" 三引号字符串块S = r'\temp\spam' Raw字符串，没有转移序列B = b'sp\xc4m' Byte字符串U = u'sp\u00c4m' Unicode字符串S1 + S2 合并S * 3 重复 S[i] 索引S[i:j] 分片len(S) 求长度"a %s parrot" % kind 字符串格式化表达式 "a &#123;0&#125; parrot".format(kind) 字符串格式化方法 S.find('pa') S.rstrip() S.replace('pa', 'xx') S.split(',') 字符串方法调用S.isdigit() S.lower() S.endswith('spam') 'spam'.join(strlist) S.encode('latin-1') B.decode('utf8')for x in S: print(x) 'spam' in S [c * 2 for c in S] map(ord, S)re.match('sp(.*)am', line) 模式匹配 字符串常量代码中的各种字符串使用方法：单引号 ‘spa“m’双引号 “spa&#39;m”三引号 &#39;&#39;&#39;...spam...&#39;&#39;&#39;, &quot;&quot;&quot;...spam...&quot;&quot;&quot;转义字符 “s\tp\na\0m”Raw字符串 r&quot;C:\new\test.spm&quot; 抑制转义字符python3和python2.6+中的byte字符串 b&#39;sp\x01am&#39;python2和python3.3+中的unicode字符串 u&#39;eggs\u0020spam&#39; 包围python字符串的单引号和双引号是可以互换的。1&gt;&gt;&gt; 'shrubbery', "shrubbery" 当需要在字符串中包含一种引号时就是用另一种引号包围整个字符串。1&gt;&gt;&gt; 'shrubbery', "shrubbery" python自动在任意表达式中合并相邻的字符串常量，也可以增加+操作符明确的表示这是一个合并操作。例如：123&gt;&gt;&gt; title = "Meaning " 'of' " Life"&gt;&gt;&gt; title 'Meaning of Life' 在字符串间添加逗号会得到一个元组结果：12&gt;&gt;&gt; 'knight\'s', "knight\"s" ("knight's", 'knight"s') 转义序列能在字符串中嵌入不容易通过键盘输入的字节，最终会被一个单字符替代。print()会将其解释。12345&gt;&gt;&gt; s = 'a\nb\tc'&gt;&gt;&gt; s 'a\nb\tc'&gt;&gt;&gt; len(s) 5 Python中并不使用nullbyte结束字符串，而是将字符串和它的长度全部存储在内存中。 python提供的转义字符序列：123456789101112131415161718\newline 忽略(continuation line) \\ 保留\ \' 保留单引号\" 保留双引号\a 响铃\b 退格 \f 换页 \n 换行 \r 回车 \t 水平制表符 \v 垂直制表符\xhh hh为十六进制值 (exactly 2 digits) \ooo 八进制 \0 Null: binary 0 character (doesn’t end string) \N&#123; id &#125; Unicode database ID \uhhhh Unicode character with 16-bit hex value \Uhhhhhhhh Unicode character with 32-bit hex valuea \other 不转义 (keeps both \ and other) 如果python不能识别\符号之后的字符作为转义码，会将\字符作为一个字符保留在字符串中。但是不要依赖于这种形式，如果要保留\使用\或raw字符串。 raw字符串会抑制转义序列：1234567myfile = open(r'C:\new\text.dat', 'w')ormyfile = open('C:\\new\\text.dat', 'w')&gt;&gt;&gt; path = r'C:\new\text.dat' &gt;&gt;&gt; path # Show as Python code 'C:\\new\\text.dat' raw字符串也常被用于正则表达式(re模块)。 三引号中的多行字符串块（单引号或双引号），可以包含其它的单引号或双引号，直到出现下一个三引号时结束。 三引号字符串将包含所有的被包围的文本，包括中间行的注释。所以如果需要注释，添加在三引号之前或之后。 三引号可以在任何需要多行文本的位置使用：如程序中内嵌的多行的错误消息，HTML，XML或JSON代码等。 三引号也常用作文档字符串 三引号也可用作临时注释多行代码的作用。 字符串操作1234567&gt;&gt;&gt; len('abc') # Length: number of items 3 &gt;&gt;&gt; 'abc' + 'def' # Concatenation: a new string 'abcdef' &gt;&gt;&gt; 'Ni!' * 4 # Repetition: like "Ni!" + "Ni!" + ... 'Ni!Ni!Ni!Ni!'&gt;&gt;&gt; print('-' * 80) # 80 dashes, the easy way 注意：+操作符用于连接字符串时如果表达式中同时有字符串和数字会出现错误：’abc’+9 raises。12345&gt;&gt;&gt; myjob = "hacker" &gt;&gt;&gt; for c in myjob: print(c, end=' ') # Step through items, print each (3.X form)h a c k e r &gt;&gt;&gt; "k" in myjob # FoundTrue 索引 S[i] 第一个元素索引为0,S[0]获取第一个元素 负索引意味着从最后反向计数，S[?2]获取倒数第二个元素，等价于S[len(S)?2] 分片S[i:j] i不包含在结果分片内 S[:]默认从0到字符串长度 S[i:j:k] k为步长。S[::-1]实际将反转字符串。 1234567891011121314&gt;&gt;&gt; S = 'spam' &gt;&gt;&gt; S[0], S[?2] # Indexing from front or end ('s', 'a') &gt;&gt;&gt; S[1:3], S[1:], S[:?1] # Slicing: extract a section ('pa', 'pam', 'spa')&gt;&gt;&gt; S = 'abcdefghijklmnop' &gt;&gt;&gt; S[1:10:2] # Skipping items 'bdfhj' &gt;&gt;&gt; S[::2] 'acegikmo'&gt;&gt;&gt; S = 'hello' &gt;&gt;&gt; S[::?1] # Reversing items 'olleh' 以下两个操作是等价的1234&gt;&gt;&gt; 'spam'[1:3] # Slicing syntax 'pa' &gt;&gt;&gt; 'spam'[slice(1, 3)] # Slice objects with index syntax + object 'pa' 字符串的转换 +操作符不能连接字符串与数字，需要进行类型转换: int() str() eval() 123456789101112131415161718192021&gt;&gt;&gt; int("42"), str(42) # Convert from/to string (42, '42') &gt;&gt;&gt; repr(42) # Convert to as-code string '42'&gt;&gt;&gt; print(str('spam'), repr('spam')) # 2.X: print str('spam'), repr('spam') spam 'spam'&gt;&gt;&gt; str('spam'), repr('spam') # Raw interactive echo displays ('spam', "'spam'")&gt;&gt;&gt; S = "42" &gt;&gt;&gt; I = 1 &gt;&gt;&gt; S + I TypeError: Can't convert 'int' object to str implicitly &gt;&gt;&gt; int(S) + I # Force addition 43 &gt;&gt;&gt; S + str(I) # Force concatenation '421'&gt;&gt;&gt; str(3.1415), float("1.5") ('3.1415', 1.5) 字符代码转换：ord()转化为ascii码， chr()将ascii转换为字符 123456789&gt;&gt;&gt; ord('s') 115 &gt;&gt;&gt; chr(115) 's'&gt;&gt;&gt; int('1101', 2) # Convert binary to integer: built-in 13 &gt;&gt;&gt; bin(13) # Convert integer to binary: built-in '0b1101' 字符串是不可原地修改的只能生成新的对象赋值给原来的变量12345678910111213&gt;&gt;&gt; S = 'spam' &gt;&gt;&gt; S[0] = 'x' # Raises an error! TypeError: 'str' object does not support item assignment&gt;&gt;&gt; S = S + 'SPAM!' # To change a string, make a new one &gt;&gt;&gt; S 'spamSPAM!' &gt;&gt;&gt; S = S[:4] + 'Burger' + S[?1] &gt;&gt;&gt; S 'spamBurger!'&gt;&gt;&gt; S = 'splot' &gt;&gt;&gt; S = S.replace('pl', 'pamal') 字串替换 也可以使用字符串格式化表达式构造一个新的字符串 字符串方法1234567891011121314151617181920212223242526272829303132333435363738394041424344String method calls in Python 3.3 S.capitalize() S.ljust(width [, fill]) S.casefold() S.lower() S.center(width [, fill]) S.lstrip([chars]) S.count(sub [, start [, end]]) S.maketrans(x[, y[, z]]) S.encode([encoding [,errors]]) S.partition(sep) S.endswith(suffix [, start [, end]]) S.replace(old, new [, count]) S.expandtabs([tabsize]) S.rfind(sub [,start [,end]]) S.find(sub [, start [, end]]) S.rindex(sub [, start [, end]]) S.format(fmtstr, *args, **kwargs) S.rjust(width [, fill]) S.index(sub [, start [, end]]) S.rpartition(sep) S.isalnum() S.rsplit([sep[, maxsplit]]) S.isalpha() S.rstrip([chars]) S.isdecimal() S.split([sep [,maxsplit]])S.isdigit() S.splitlines([keepends]) S.isidentifier() S.startswith(prefix [, start [, end]]) S.islower() S.strip([chars]) S.isnumeric() S.swapcase() S.isprintable() S.title() S.isspace() S.translate(map) S.istitle() S.upper() S.isupper() S.zfill(width) S.join(iterable) 使用字符串方法代替：1234567891011121314151617181920212223&gt;&gt;&gt; S = 'spammy' &gt;&gt;&gt; S = S[:3] + 'xx' + S[5:] # Slice sections from S &gt;&gt;&gt; S 'spaxxy'&gt;&gt;&gt; S = 'spammy' &gt;&gt;&gt; S = S.replace('mm', 'xx') # Replace all mm with xx in S&gt;&gt;&gt; 'aa$bb$cc$dd'.replace('$', 'SPAM')&gt;&gt;&gt; S = 'xxxxSPAMxxxxSPAMxxxx' &gt;&gt;&gt; where = S.find('SPAM') # Search for position &gt;&gt;&gt; where # Occurs at offset 4 4 &gt;&gt;&gt; S = S[:where] + 'EGGS' + S[(where+4):] &gt;&gt;&gt; S 'xxxxEGGSxxxxSPAMxxxx'&gt;&gt;&gt; S = 'xxxxSPAMxxxxSPAMxxxx' &gt;&gt;&gt; S.replace('SPAM', 'EGGS') # Replace all 'xxxxEGGSxxxxEGGSxxxx' &gt;&gt;&gt; S.replace('SPAM', 'EGGS', 1) # Replace one 'xxxxEGGSxxxxSPAMxxxx' 每次连接和替换操作都会创建新的字符串对象，如果对一个非常大的字符串进行多次操作这可能是一个性能瓶颈为提高性能可以将字符串转换成支持原地修改的对象后操作：123456789101112&gt;&gt;&gt; S = 'spammy' &gt;&gt;&gt; L = list(S) #内建函数list可以从序列创建一个列表&gt;&gt;&gt; L ['s', 'p', 'a', 'm', 'm', 'y']&gt;&gt;&gt; L[3] = 'x' # Works for lists, not strings&gt;&gt;&gt; L ['s', 'p', 'a', 'x', 'x', 'y']&gt;&gt;&gt; S = ''.join(L) #完成操作后再转换回字符串。delimiter.join方法将参数中列表的值使用delimiter连接起来，使用join通常比单独的进行子串连接操作运行更快速&gt;&gt;&gt; 'SPAM'.join(['eggs', 'sausage', 'ham', 'toast']) 'eggsSPAMsausageSPAMhamSPAMtoast' 文本解析12345678910111213141516171819202122232425262728&gt;&gt;&gt; line = 'aaa bbb ccc' &gt;&gt;&gt; col1 = line[0:3] &gt;&gt;&gt; col3 = line[8:]&gt;&gt;&gt; line = 'aaa bbb ccc' &gt;&gt;&gt; cols = line.split() #默认使用withespace，1或多个空格，tab，newline&gt;&gt;&gt; cols ['aaa', 'bbb', 'ccc']&gt;&gt;&gt; line = 'bob,hacker,40' &gt;&gt;&gt; line.split(',') ['bob', 'hacker', '40']&gt;&gt;&gt; line = "i'mSPAMaSPAMlumberjack" &gt;&gt;&gt; line.split("SPAM") #可以使用多个字符["i'm", 'a', 'lumberjack']&gt;&gt;&gt; line = "The knights who say Ni!\n" &gt;&gt;&gt; line.rstrip() 'The knights who say Ni!' #去除空白字符&gt;&gt;&gt; line.upper() 'THE KNIGHTS WHO SAY NI!\n' #转换为大写&gt;&gt;&gt; line.isalpha() False &gt;&gt;&gt; line.endswith('Ni!\n') True &gt;&gt;&gt; line.startswith('The') True 包含12&gt;&gt;&gt; line.find('Ni') != ?1 # Search via method call or expression True 等价于12&gt;&gt;&gt; 'Ni' in line True 结尾123&gt;&gt;&gt; sub = 'Ni!\n' &gt;&gt;&gt; line.endswith(sub) # End test via method call or slice True 等价于12&gt;&gt;&gt; line[-len(sub):] == sub True 要使用基于pattern的文本处理必须使用python的re模块字符串格式化的两种风格 字符串格式化表达式：&#39;...%s...&#39; % (values)1'That is %d %s bird!' % (1, 'dead') 格式化字符串时，Python使用一个字符串作为模板。模板中有格式符，这些格式符为真实值预留位置，并说明真实数值应该呈现的格式。Python用一个tuple(其实可以不写tuple括号也可以)将多个值传递给模板，每个值对应一个格式符。 操作符%左边提供一个包含多个以%开头的转换目标的格式化字符串，右边提供要插入格式化字符串中的对象组成的元组。12345&gt;&gt;&gt; exclamation = 'Ni' &gt;&gt;&gt; 'The knights who say %s!' % exclamation # String substitution 'The knights who say Ni!' &gt;&gt;&gt; '%d %s %g you' % (1, 'spam', 4.0) # Type-specific substitutions '1 spam 4 you' 可用的字符串格式符：格式符为真实值预留位置，并控制显示的格式。123456789101112131415%s 字符串 (采用str()的显示)%r 字符串 (采用repr()的显示)%c 单个字符%b 二进制整数%d 十进制整数%i 十进制整数%o 八进制整数%x 十六进制整数%e 指数 (基底写为e)%E 指数 (基底写为E)%f 浮点数%F 浮点数，与上相同%g 指数(e)或浮点数 (根据显示长度)%G 指数(E)或浮点数 (根据显示长度)要是想输出%则要使用%%进行转义操作. 转换目标的通用语法：%[(keyname)][flags][width][.precision]typecode 其中的：123456789keyname:用于作为表达式右边字典的索引flags: 可以有+,-,’ ‘或0。 -表示左对齐。 +表示显示数字的正号。 ’ ‘为一个空格，表示在正数的左侧填充一个空格，从而与负数对齐。 0表示使用0填充满width的宽度。width: 替代文本的显示最小宽度，如果实际的值超出这个宽度，宽度将会被扩充。[.precision]表示浮点数小数点后的精度width, precision为两个整数。我们可以利用*，来使用元组中的数值动态代入这两个量。 123456789101112131415161718&gt;&gt;&gt; x = 1234 &gt;&gt;&gt; res = 'integers: ...%d...%?6d...%06d' % (x, x, x) &gt;&gt;&gt; res 'integers: ...1234...1234 ...001234'&gt;&gt;&gt; x = 1.23456789 &gt;&gt;&gt; '%e | %f | %g' % (x, x, x) '1.234568e+00 | 1.234568 | 1.23457' &gt;&gt;&gt; '%E' % x '1.234568E+00'&gt;&gt;&gt; '%?6.2f | %05.2f | %+06.1f' % (x, x, x) '1.23 | 01.23 | +001.2' &gt;&gt;&gt; '%s' % x, str(x) ('1.23456789', '1.23456789')&gt;&gt;&gt; '%f, %.2f, %.*f' % (1/3.0, 1/3.0, 4, 1/3.0) '0.333333, 0.33, 0.3333' 基于字典的字符串格式化：允许左边的转换目标引用右边的字典中的键值来提取对应值： &#39;%(qty)d more %(food)s&#39; % {&#39;qty&#39;: 1, &#39;food&#39;: &#39;spam&#39;} 12345678910&gt;&gt;&gt; reply = """ Greetings... Hello %(name)s! Your age is %(age)s """ &gt;&gt;&gt; values = &#123;'name': 'Bob', 'age': 40&#125; # Build up values to substitute &gt;&gt;&gt; print(reply % values) # Perform substitutions小技巧：与vars()配合使用访问变量&gt;&gt;&gt; food = 'spam' &gt;&gt;&gt; qty = 10 &gt;&gt;&gt; vars() &#123;'food': 'spam', 'qty': 10, ...plus built-in names set by Python... &#125;&gt;&gt;&gt; '%(qty)d more %(food)s' % vars() # Variables are keys in vars() '10 more spam' 字符串格式化方法调用：’…{}…’.format(values) python2.6和python3中引入这种方式,字符串格式化调用方法： 按位置： 12template = '&#123;0&#125;, &#123;1&#125; and &#123;2&#125;'template.format('spam', 'ham', 'eggs') 按关键字： 12template = '&#123;motto&#125;, &#123;pork&#125; and &#123;food&#125;'template.format(motto='spam', pork='ham', food='eggs') 按两种方式： 12template = '&#123;motto&#125;, &#123;0&#125; and &#123;food&#125;'template.format('ham', motto='spam', food='eggs') 相对位置 12template = '&#123;&#125;, &#123;&#125; and &#123;&#125;'template.format('spam', 'ham', 'eggs') 转换为格式化字符串的方式：1234567&gt;&gt;&gt; template = '%s, %s and %s' # Same via expression &gt;&gt;&gt; template % ('spam', 'ham', 'eggs') 'spam, ham and eggs' 使用dict()将关键字参数列表转换为字典：&gt;&gt;&gt; template = '%(motto)s, %(pork)s and %(food)s' &gt;&gt;&gt; template % dict(motto='spam', pork='ham', food='eggs') 'spam, ham and eggs' 也可以用来赋值：X = &#39;{motto}, {0} and {food}&#39;.format(42, motto=3.14, food=[1, 2]) 格式化字符串中也可以使用索引，只有正数索引有效123456789101112'My &#123;1[kind]&#125; runs &#123;0.platform&#125;'.format(sys, &#123;'kind': 'laptop'&#125;) 'My &#123;map[kind]&#125; runs &#123;sys.platform&#125;'.format(sys=sys, map=&#123;'kind': 'laptop'&#125;) &gt;&gt;&gt; somelist = list('SPAM') &gt;&gt;&gt; somelist ['S', 'P', 'A', 'M'] &gt;&gt;&gt; 'first=&#123;0[0]&#125;, third=&#123;0[2]&#125;'.format(somelist) 'first=S, third=A' &gt;&gt;&gt; 'first=&#123;0&#125;, last=&#123;1&#125;'.format(somelist[0], somelist[-1]) # [-1] fails in fmt 'first=S, last=M' &gt;&gt;&gt; parts = somelist[0], somelist[-1], somelist[1:3] # [1:3] fails in fmt &gt;&gt;&gt; 'first=&#123;0&#125;, last=&#123;1&#125;, middle=&#123;2&#125;'.format(*parts) # Or '&#123;&#125;' in 2.7/3.1+ # *parts将元组转换为单独的函数列表"first=S, last=M, middle=['P', 'A']" 高级格式化方法调用语法，用作特定格式化输出：1234567891011&#123;fieldname component !conversionflag :formatspec&#125; ，实际使用时没有中间的空格fieldname 可选的数字或关键字，用于标识一个参数component 可选的用于获取参数的属性或索引“.name” or “[index]”conversionflag 如果存在这个参数以!开头后跟r, s, a分别表示对值调用repr, str 或 ascii内建函数。formatspec 如果存在这个参数需要以:开始后跟定义如何输出显示的文本，包括字段宽度，对齐，填充，小数精度等，并以可选的数据类型代码结束。formatspec的组成语法： [[fill]align][sign][#][0][width][,][.precision][typecode] fill 为除&#123;&#125;之外的任何填充字符 align 可以为 &lt;, &gt;, =, or ^，表示左对齐，右对齐，符号字符填充和中央对齐。 sign 可以是+，-或空格 width和precision 与%表达式中的类似 [,] 按千位分割符，见下 formatspec还可以包含嵌套的仅包含字段名称的{}格式字符串，来从参数列表动态的获取值12345678&gt;&gt;&gt; '&#123;0:.2f&#125;'.format(1 / 3.0) # Parameters hardcoded '0.33' &gt;&gt;&gt; '%.2f' % (1 / 3.0) # Ditto for expression '0.33' &gt;&gt;&gt; '&#123;0:.&#123;1&#125;f&#125;'.format(1 / 3.0, 4) # Take value from arguments '0.3333' &gt;&gt;&gt; '%.*f' % (4, 1 / 3.0) # Ditto for expression '0.3333' typecode 与格式化字符串中的code一样，format方法还支持%b用来显示十进制数字的二进制表示方法，%用于显示百分数，对于正数只有%d(i或u不在此使用)1234567891011121314'&#123;.platform:&gt;10&#125; = &#123;[kind]:&lt;10&#125;'.format(sys, dict(kind='laptop')) '&#123;0:f&#125;, &#123;1:.2f&#125;, &#123;2:06.2f&#125;'.format(3.14159, 3.14159, 3.14159) &gt;&gt;&gt; '&#123;0:.2f&#125;'.format(1.2345) # String method '1.23' &gt;&gt;&gt; format(1.2345, '.2f') # Built-in function '1.23' &gt;&gt;&gt; '%.2f' % 1.2345 # Expression '1.23' &gt;&gt;&gt; '&#123;0:d&#125;'.format(999999999999) '999999999999' &gt;&gt;&gt; '&#123;0:,d&#125;'.format(999999999999) '999,999,999,999' 格式化方法与%表达式的比较： 字符串格式化表达式比format方法更容易使用，更通用：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556print('%s=%s' % ('spam', 42)) # Format expression: in all 2.X/3.X print('&#123;0&#125;=&#123;1&#125;'.format('spam', 42)) # Format method: in 3.0+ and 2.6+ print('&#123;&#125;=&#123;&#125;'.format('spam', 42)) # With autonumbering: in 3.1+ and 2.7&gt;&gt;&gt; '%s, %s and %s' % (3.14, 42, [1, 2])'My %(kind)s runs %(platform)s' % &#123;'kind': 'laptop', 'platform': sys.platform&#125; 'My %(kind)s runs %(platform)s' % dict(kind='laptop', platform=sys.platform) '%(plat)10s = %(kind)-10s' % dict(plat=sys.platform, kind='laptop') 'My &#123;1[kind]:&lt;8&#125; runs &#123;0.platform:&gt;8&#125;'.format(sys, &#123;'kind': 'laptop'&#125;) 'My %(kind)-8s runs %(plat)8s' % dict(kind='laptop', plat=sys.platform)# Floating-point numbers &gt;&gt;&gt; '%e, %.3e, %g' % (3.14159, 3.14159, 3.14159) '3.141590e+00, 3.142e+00, 3.14159' &gt;&gt;&gt; '%f, %.2f, %06.2f' % (3.14159, 3.14159, 3.14159) '3.141590, 3.14, 003.14' # Hex and octal, but not binary (see ahead) &gt;&gt;&gt; '%x, %o' % (255, 255) 'ff, 377'# Hardcoded references in both &gt;&gt;&gt; import sys &gt;&gt;&gt; 'My &#123;1[kind]:&lt;8&#125; runs &#123;0.platform:&gt;8&#125;'.format(sys, &#123;'kind': 'laptop'&#125;) 'My laptop runs win32' &gt;&gt;&gt; 'My %(kind)-8s runs %(plat)8s' % dict(kind='laptop', plat=sys.platform) 'My laptop runs win32'# Building data ahead of time in both &gt;&gt;&gt; data = dict(platform=sys.platform, kind='laptop') &gt;&gt;&gt; 'My &#123;kind:&lt;8&#125; runs &#123;platform:&gt;8&#125;'.format(**data) #**用于将字典解包为关键字参数'My laptop runs win32' &gt;&gt;&gt; 'My %(kind)-8s runs %(platform)8s' % data 'My laptop runs win32'&gt;&gt;&gt; '&#123;:,d&#125;'.format(999999999999) '999,999,999,999' &gt;&gt;&gt; '&#123;:,d&#125; &#123;:,d&#125;'.format(9999999, 8888888) '9,999,999 8,888,888' &gt;&gt;&gt; '&#123;:,.2f&#125;'.format(296999.2567) '296,999.26'&gt;&gt;&gt; from formats import commas, money &gt;&gt;&gt; '%s' % commas(999999999999) '999,999,999,999' &gt;&gt;&gt; '%s %s' % (commas(9999999), commas(8888888))'9,999,999 8,888,888' &gt;&gt;&gt; '%s' % money(296999.2567) '$296,999.26'&gt;&gt;&gt; [commas(x) for x in (9999999, 8888888)] ['9,999,999', '8,888,888'] &gt;&gt;&gt; '%s %s' % tuple(commas(x) for x in (9999999, 8888888)) '9,999,999 8,888,888' &gt;&gt;&gt; ''.join(commas(x) for x in (9999999, 8888888)) '9,999,9998,888,888' 使用format方法的优点： 具有%表达式本身没有的一些特性 例如打印二进制的表示，使用format和表达式分别实现为：12345678910111213&gt;&gt;&gt; '&#123;0:b&#125;'.format((2 ** 16) ? 1) # Expression (only) binary format code '1111111111111111' &gt;&gt;&gt; '%b' % ((2 ** 16) ? 1) ValueError: unsupported format character 'b'... &gt;&gt;&gt; bin((2 ** 16) ? 1) # But other more general options work too '0b1111111111111111' &gt;&gt;&gt; '%s' % bin((2 ** 16) - 1) # Usable with both method and % expression '0b1111111111111111' &gt;&gt;&gt; '&#123;&#125;'.format(bin((2 ** 16) - 1)) # With 2.7/3.1+ relative numbering '0b1111111111111111' &gt;&gt;&gt; '%s' % bin((2 ** 16) - 1)[2:] # Slice off 0b to get exact equivalent '1111111111111111' 打印千分位符的数字分别实现：1234&gt;&gt;&gt; '&#123;:,d&#125;'.format(999999999999) # New str.format method feature in 3.1/2.7 '999,999,999,999' &gt;&gt;&gt; '%s' % commas(999999999999) # But % is same with simple 8-line function '999,999,999,999' 有更灵活的数值引用语法 123456789101112&gt;&gt;&gt; '&#123;name&#125; &#123;job&#125; &#123;name&#125;'.format(name='Bob', job='dev') 'Bob dev Bob' &gt;&gt;&gt; '%(name)s %(job)s %(name)s' % dict(name='Bob', job='dev') 'Bob dev Bob'&gt;&gt;&gt; D = dict(name='Bob', job='dev') &gt;&gt;&gt; '&#123;0[name]&#125; &#123;0[job]&#125; &#123;0[name]&#125;'.format(D) # Method, key references 'Bob dev Bob' &gt;&gt;&gt; '&#123;name&#125; &#123;job&#125; &#123;name&#125;'.format(**D) # Method, dict-to-args 'Bob dev Bob' &gt;&gt;&gt; '%(name)s %(job)s %(name)s' % D # Expression, key references 'Bob dev Bob' 更明确的值引用替换 12'\n%s&lt;Class %s, address %s:\n%s%s%s&gt;\n' % (...) # Expression '\n&#123;0&#125;&lt;Class &#123;1&#125;, address &#123;2&#125;:\n&#123;3&#125;&#123;4&#125;&#123;5&#125;&gt;\n'.format(...) # Method 注意各种形式使用的python版本：123456&gt;&gt;&gt; 'The &#123;0&#125; side &#123;1&#125; &#123;2&#125;'.format('bright', 'of', 'life') # Python 3.X, 2.6+ 'The bright side of life' &gt;&gt;&gt; 'The &#123;&#125; side &#123;&#125; &#123;&#125;'.format('bright', 'of', 'life') # Python 3.1+, 2.7+ 'The bright side of life' &gt;&gt;&gt; 'The %s side %s %s' % ('bright', 'of', 'life') # All Pythons 'The bright side of life' 对于浮点数的显示，格式化表达式会更简介：123456&gt;&gt;&gt; '&#123;0:f&#125;, &#123;1:.2f&#125;, &#123;2:05.2f&#125;'.format(3.14159, 3.14159, 3.14159) '3.141590, 3.14, 03.14' &gt;&gt;&gt; '&#123;:f&#125;, &#123;:.2f&#125;, &#123;:06.2f&#125;'.format(3.14159, 3.14159, 3.14159) '3.141590, 3.14, 003.14' &gt;&gt;&gt; '%f, %.2f, %06.2f' % (3.14159, 3.14159, 3.14159) '3.141590, 3.14, 003.14' 比%操作符更容易记的方法名称 单值和多值使用相同的语法 1234567891011121314151617&gt;&gt;&gt; '%.2f' % 1.2345 # Single value '1.23' &gt;&gt;&gt; '%.2f %s' % (1.2345, 99) # Multiple values tuple '1.23 99' &gt;&gt;&gt; '%s' % (1.23,) # Single value, in a tuple '1.23' &gt;&gt;&gt; '%s' % ((1.23,),) # Single value that is a tuple '(1.23,)'&gt;&gt;&gt; '&#123;0:.2f&#125;'.format(1.2345) # Single value '1.23' &gt;&gt;&gt; '&#123;0:.2f&#125; &#123;1&#125;'.format(1.2345, 99) # Multiple values '1.23 99' &gt;&gt;&gt; '&#123;0&#125;'.format(1.23) # Single value, by itself '1.23' &gt;&gt;&gt; '&#123;0&#125;'.format((1.23,)) # Single value that is a tuple '(1.23,)' 作为一个函数可以用在不能使用表达式的地方，例如作为函数参数 Python中类型分类 数字（整数，浮点，二进制，分数，小数） 支持加法乘法 序列（字符串，列表，元组） 支持索引，分片，合并等 映射（字典） 支持通过键的索引。 只有可变类型能在原处修改： 不可变类型（数字，字符串，元组，不可变集合） 可变类型（列表，字典，可变集合） 列表与字典其它对象的集合 列表有序对象集合，与字符串不同可以包含任何种类的对象，数字，字符串，其他列表等。 列表是可变对象，支持在原处修改的操作： 列表是任意对象的有序集合。 通过便宜读取。 可变长度，异构（可以包含任何类型的对象），任意嵌套。 属于可变序列的分类，支持原地修改，可以响应索引，分片及合并，返回新的列表。 列表是对象引用的数组，包含0个或多个其他对象的引用。 常用的列表操作123456789101112131415161718192021222324252627282930L = [] An empty list L = [123, &apos;abc&apos;, 1.23, &#123;&#125;] Four items: indexes 0..3 L = [&apos;Bob&apos;, 40.0, [&apos;dev&apos;, &apos;mgr&apos;]] Nested sublists L = list(&apos;spam&apos;) L = list(range(-4, 4)) List of an iterable’s items, list of successive integers L[i] L[i][j] L[i:j] len(L) Index, index of index, slice, length L1 + L2 Concatenate 生成新的列表L * 3 repeatfor x in L: print(x) 3 in L Iteration, membershipL.append(4) 在原地修改，返回值为noneL.extend([5,6,7]) L.insert(i, X) Methods: growingL.index(X) L.count(X) Methods: searchingL.sort() 原地修改，返回值为none。key参数给出一个单个参数的函数，返回排序中使用的值。reverse参数升序降序。L.reverse() 原地反转列表L.copy() L.clear() Methods: sorting, reversing, copying (3.3+), clearing (3.3+)L.pop(i) L.remove(X) del L[i] del L[i:j] L[i:j] = [] Methods, statements: shrinkingL[i] = 3 L[i:j] = [4,5,6] Index assignment, slice assignmentL = [x**2 for x in range(5)] list(map(ord, &apos;spam&apos;)) List comprehensions and maps 列表的操作：1234567891011&gt;&gt;&gt; [1, 2, 3] + [4, 5, 6] # Concatenation&gt;&gt;&gt; ['Ni!'] * 4 # Repetition&gt;&gt;&gt; str([1, 2]) + "34" # Same as "[1, 2]" + "34" '[1, 2]34' &gt;&gt;&gt; [1, 2] + list("34") # Same as [1, 2] + ["3", "4"] [1, 2, '3', '4']&gt;&gt;&gt; 3 in [1, 2, 3] # Membership True &gt;&gt;&gt; for x in [1, 2, 3]: ... print(x, end=' ') # Iteration (2.X uses: print x,) 列表解析123&gt;&gt;&gt; res = [c * 4 for c in 'SPAM'] # List comprehensions &gt;&gt;&gt; res ['SSSS', 'PPPP', 'AAAA', 'MMMM'] 等价于，但是列表解析会更快速 123&gt;&gt;&gt; res = [] &gt;&gt;&gt; for c in 'SPAM': # List comprehension equivalent ... res.append(c * 4) 1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt;&gt;&gt; list(map(abs, [?1, ?2, 0, 1, 2])) # Map a function across a sequence 对每个元素执行map中的函数[1, 2, 0, 1, 2]&gt;&gt;&gt; L = ['spam', 'Spam', 'SPAM!'] &gt;&gt;&gt; L[1] = 'eggs' #原地修改，索引赋值&gt;&gt;&gt; L[0:2] = ['eat', 'more'] # Slice assignment: delete+insert 分片赋值&gt;&gt;&gt; L # Replaces items 0,1 ['eat', 'more', 'SPAM!']&gt;&gt;&gt; L = [1, 2, 3] &gt;&gt;&gt; L[1:2] = [4, 5] # Replacement/insertion &gt;&gt;&gt; L [1, 4, 5, 3] &gt;&gt;&gt; L[1:1] = [6, 7] # Insertion (replace nothing) &gt;&gt;&gt; L [1, 6, 7, 4, 5, 3] &gt;&gt;&gt; L[1:2] = [] # Deletion (insert nothing) &gt;&gt;&gt; L [1, 7, 4, 5, 3]&gt;&gt;&gt; L = [1] &gt;&gt;&gt; L[:0] = [2, 3, 4] # Insert all at :0, an empty slice at front &gt;&gt;&gt; L [2, 3, 4, 1] &gt;&gt;&gt; L[len(L):] = [5, 6, 7] # Insert all at len(L):, an empty slice at end &gt;&gt;&gt; L [2, 3, 4, 1, 5, 6, 7] &gt;&gt;&gt; L.extend([8, 9, 10]) # Insert all at end, named method &gt;&gt;&gt; L [2, 3, 4, 1, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; L = ['eat', 'more', 'SPAM!'] &gt;&gt;&gt; L.append('please') # Append method call: add item at end &gt;&gt;&gt; L ['eat', 'more', 'SPAM!', 'please']&gt;&gt;&gt; L.sort() # Sort list items ('S' &lt; 'e') &gt;&gt;&gt; L ['SPAM!', 'eat', 'more', 'please'] 关于sort函数：1234567891011121314&gt;&gt;&gt; L = ['abc', 'ABD', 'aBe'] &gt;&gt;&gt; L.sort() # Sort with mixed case &gt;&gt;&gt; L ['ABD', 'aBe', 'abc'] &gt;&gt;&gt; L = ['abc', 'ABD', 'aBe'] &gt;&gt;&gt; L.sort(key=str.lower) # Normalize to lowercase &gt;&gt;&gt; L ['abc', 'ABD', 'aBe']&gt;&gt;&gt; L = ['abc', 'ABD', 'aBe'] &gt;&gt;&gt; L.sort(key=str.lower, reverse=True) # Change sort order &gt;&gt;&gt; L ['aBe', 'ABD', 'abc'] python2中不同类型的对象比较是可行的，语言根据类型的名称定义了固定的不同类型的顺序,int总是小于strpython3中不再能比较不同类型了，[1, 2, ‘spam’].sort()在python3中会报告异常。python3中也不再支持给sort传递任意的比较函数，使用reverse=True来改变顺序。 注意append和sort会在原地改变传入的列表，但是使用python内置的sort函数对任意集合则会返回排序后的列表：1234567&gt;&gt;&gt; L = ['abc', 'ABD', 'aBe'] &gt;&gt;&gt; sorted(L, key=str.lower, reverse=True) # Sorting built-in ['aBe', 'ABD', 'abc'] &gt;&gt;&gt; L = ['abc', 'ABD', 'aBe'] &gt;&gt;&gt; sorted([x.lower() for x in L], reverse=True) # Pretransform items: differs! ['abe', 'abd', 'abc'] #注意此时会输出转换为小写后的结果，而不是元列表中的元素。 python的内置函数sorted（）可以排序任何集合。12345678910111213&gt;&gt;&gt; L = [1, 2] &gt;&gt;&gt; L.extend([3, 4, 5]) # Add many items at end (like in-place +) &gt;&gt;&gt; L [1, 2, 3, 4, 5] &gt;&gt;&gt; L.pop() # Delete and return last item (by default: ?1) 5 &gt;&gt;&gt; L [1, 2, 3, 4] &gt;&gt;&gt; L.reverse() # In-place reversal method&gt;&gt;&gt; L [4, 3, 2, 1] &gt;&gt;&gt; list(reversed(L)) # Reversal built-in with a result (iterator) [1, 2, 3, 4] list(reversed(L)) reversed迭代器 pop() 和 append() 方法联合使用可以用来实现一个堆栈。pop()可以接受一个索引，默认为-11234567891011121314&gt;&gt;&gt; L = ['spam', 'eggs', 'ham'] &gt;&gt;&gt; L.index('eggs') # Index of an object (search/find) 1 &gt;&gt;&gt; L.insert(1, 'toast') # Insert at position &gt;&gt;&gt; L ['spam', 'toast', 'eggs', 'ham'] &gt;&gt;&gt; L.remove('eggs') # Delete by value &gt;&gt;&gt; L ['spam', 'toast', 'ham'] &gt;&gt;&gt; L.pop(1) # Delete by position 'toast' &gt;&gt;&gt; L ['spam', 'ham'] &gt;&gt;&gt; L.count('spam') # Number of occurrences 1 count和index不改变原列表内容，只返回信息。 另一种删除方法：1234567&gt;&gt;&gt; L = ['spam', 'eggs', 'ham', 'toast'] &gt;&gt;&gt; del L[0] # Delete one item &gt;&gt;&gt; L ['eggs', 'ham', 'toast'] &gt;&gt;&gt; del L[1:] # Delete an entire section &gt;&gt;&gt; L # Same as L[1:] = [] ['eggs'] L.copy()顶层拷贝 字典无序对象的集合，字典中的元素通过key来存取，而不是偏移，作为高度优化的内置类型，索引一个字典是非常快速的查找操作。 字典通过key而不是偏移读取数据。有时又叫做关联数组或者散列表。 任意对象的无序集合。 可变长度，异构，任意嵌套。 属于可变映射类型。 列表实际上是对象的引用表，散列表。采用最优化的散列算法来寻找key。 字典的常用操作123456789101112131415161718192021222324252627D = &#123;&#125; Empty dictionary D = &#123;'name': 'Bob', 'age': 40&#125; Two-item dictionary E = &#123;'cto': &#123;'name': 'Bob', 'age': 40&#125;&#125; Nesting D = dict(name='Bob', age=40) D = dict([('name', 'Bob'), ('age', 40)]) D = dict(zip(keyslist, valueslist)) D = dict.fromkeys(['name', 'age']) Alternative construction techniques: keywords, key/value pairs, zipped key/value pairs, key lists D['name'] E['cto']['age'] Indexing by key 'age' in D Membership: key present test D.keys() all keysD.values() all valuesD.items() all key+value tuplesD.copy() copy (top-level)D.clear() clear (remove all items)D.update(D2) merge by keysD.get(key, default?) fetch by key if absent default (or None)D.pop(key, default?) remove by key, if absent default (or error)D.setdefault(key, default?) fetch by key, if absent set default (or None)D.popitem() remove/return any (key, value) pair; etc. len(D) Length: number of stored entries D[key] = 42 Adding/changing keys del D[key] Deleting entries by key list(D.keys()) Dictionary views (Python 3.X)D1.keys() &amp; D2.keys() D.viewkeys(), D.viewvalues() Dictionary views (Python 2.7) D = &#123;x: x*2 for x in range(10)&#125; Dictionary comprehensions (Python 3.X, 2.7) 字典的操作：12345678&gt;&gt;&gt; D = &#123;'spam': 2, 'ham': 1, 'eggs': 3&#125; # Make a dictionary &gt;&gt;&gt; D['spam'] # Fetch a value by key&gt;&gt;&gt; len(D) # Number of entries in dictionary 3&gt;&gt;&gt; 'ham' in D # Key membership test alternative #字典实现了迭代器协议True &gt;&gt;&gt; list(D.keys()) # Create a new list of D's keys ['eggs', 'spam', 'ham'] python3中keys()方法返回的是一个迭代器对象，要显示转换为listpython2中keys()创建并返回一个列表。 123456789101112&gt;&gt;&gt; D &#123;'eggs': 3, 'spam': 2, 'ham': 1&#125; &gt;&gt;&gt; D['ham'] = ['grill', 'bake', 'fry'] # Change entry (value=list) 创建新项目&gt;&gt;&gt; D &#123;'eggs': 3, 'spam': 2, 'ham': ['grill', 'bake', 'fry']&#125;&gt;&gt;&gt; del D['eggs'] # Delete entry 删除&gt;&gt;&gt; D &#123;'spam': 2, 'ham': ['grill', 'bake', 'fry']&#125; &gt;&gt;&gt; D['brunch'] = 'Bacon' # Add new entry 新建&gt;&gt;&gt; D &#123;'brunch': 'Bacon', 'spam': 2, 'ham': ['grill', 'bake', 'fry']&#125; python3中与keys()一样values()与items()方法也都返回迭代器对象12345&gt;&gt;&gt; D = &#123;'spam': 2, 'ham': 1, 'eggs': 3&#125; &gt;&gt;&gt; list(D.values()) [3, 2, 1] &gt;&gt;&gt; list(D.items()) [('eggs', 3), ('spam', 2), ('ham', 1)] 实际使用中试图获取一个不存在的key会产生错误，可以使用get方法，对于不存在的key它返回一个None对象或传入的默认值。123456&gt;&gt;&gt; D.get('spam') # A key that is there 2 &gt;&gt;&gt; print(D.get('toast')) # A key that is missing None &gt;&gt;&gt; D.get('toast', 88) 88 update方法合并两个字典，如果已经存在某个key会被覆盖：12345&gt;&gt;&gt; D &#123;'eggs': 3, 'spam': 2, 'ham': 1&#125; &gt;&gt;&gt; D2 = &#123;'toast':4, 'muffin':5&#125; # Lots of delicious scrambled order here &gt;&gt;&gt; D.update(D2) &gt;&gt;&gt; D &#123;'eggs': 3, 'muffin': 5, 'toast': 4, 'spam': 2, 'ham': 1&#125; 字典的pop()方法删除一个key，返回被删除的key对应的值12345&gt;&gt;&gt; D.pop('muffin') 5 &gt;&gt;&gt; D.pop('toast') # Delete and return from a key 4 &gt;&gt;&gt; D &#123;'eggs': 3, 'spam': 2, 'ham': 1&#125; 遍历字典：for key in D: 与 key in D.keys()效果一样。 将值映射到keys：1234&gt;&gt;&gt; list(table.items()) # Value=&gt;Key (year=&gt;title) [('The Meaning of Life', '1983'), ('Holy Grail', '1975'), ('Life of Brian', '1979')] &gt;&gt;&gt; [title for (title, year) in table.items() if year == '1975'] ['Holy Grail'] 或者使用如下形式：12345&gt;&gt;&gt; V = '1975' &gt;&gt;&gt; [key for (key, value) in table.items() if value == V] # Value=&gt;Key ['Holy Grail'] &gt;&gt;&gt; [key for key in table.keys() if table[key] == V] # Ditto ['Holy Grail'] 注意 序列运算无效，包括有序合并，分片等。 对新索引赋值会添加项。 键不一定总是字符串，任何不可变对象都可以。 所以可以使用字典模拟灵活列表：列表必须按顺序插入，列表可以随意选择值插入 使用字典作为稀疏数组对象，用元组作为key：12345&gt;&gt;&gt; Matrix = &#123;&#125; &gt;&gt;&gt; Matrix[(2, 3, 4)] = 88 &gt;&gt;&gt; Matrix[(7, 8, 9)] = 99&gt;&gt;&gt; Matrix &#123;(2, 3, 4): 88, (7, 8, 9): 99&#125; 队列表超范围的索引赋值是非法的，但字典可以随意赋值。 避免键值不存在的错误： 使用key前先进行测试 1234&gt;&gt;&gt; if (2, 3, 6) in Matrix: # Check for key before fetch ... print(Matrix[(2, 3, 6)]) # See Chapters 10 and 12 for if/else ... else: ... print(0) 使用try语句捕获异常并恢复 1234&gt;&gt;&gt; try: ... print(Matrix[(2, 3, 6)]) # Try to index ... except KeyError: # Catch and recover ... print(0) # See Chapters 10 and 34 for try/except 使用字典的get方法，在不存在时提供一个默认值。 1234&gt;&gt;&gt; Matrix.get((2, 3, 4), 0) # Exists: fetch and return 88 &gt;&gt;&gt; Matrix.get((2, 3, 6), 0) # Doesn't exist: use default arg 0 字典中可以嵌套各种类型 其它创建字典的方法： 如果可以事先拼凑出整个字典，可以{&#39;name&#39;: &#39;Bob&#39;, &#39;age&#39;: 40} 如果需要一次动态的建立一个字典的一个字段： 123D = &#123;&#125;D['name'] = 'Bob'D['age'] = 40 dict(name=&#39;Bob&#39;, age=40)此方法键必须是字符串。 程序运行时把键和值逐步建成序列后统一用 dict([(&#39;name&#39;, &#39;Bob&#39;), (&#39;age&#39;, 40)]) zip函数使用键和值的列表构建对应字典： D = dict(zip([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [1, 2, 3])) 如果所有的键值都相同作为初始值： dict.fromkeys([&#39;a&#39;, &#39;b&#39;], 0) 在python3与python2.7中使用字典解析表达式创建 python3与python2.7中字典： 支持新的字典解析表达式 对D.keys, D.values, and D.items返回迭代器对象视图对象，而不再是列表。 由于上一条改变遍历方法需要使用不同的风格了 不再支持跨类型的比较操作 没有D.has_key方法了，使用in操作进行测试。 python3中的字典新特性 字典解析： 12345678910&gt;&gt;&gt; list(zip(['a', 'b', 'c'], [1, 2, 3])) # Zip together keys and values [('a', 1), ('b', 2), ('c', 3)] &gt;&gt;&gt; D = dict(zip(['a', 'b', 'c'], [1, 2, 3])) # Make a dict from zip result &gt;&gt;&gt; D &#123;'b': 2, 'c': 3, 'a': 1&#125;D = &#123;k: v for (k, v) in zip(['a', 'b', 'c'], [1, 2, 3])&#125; D = &#123;x: x ** 2 for x in [1, 2, 3, 4]&#125; D = &#123;c: c * 4 for c in 'SPAM'&#125; D = &#123;c.lower(): c + '!' for c in ['SPAM', 'EGGS', 'HAM']&#125; 初始化： 1234D = dict.fromkeys(['a', 'b', 'c'], 0) D = &#123;k:0 for k in ['a', 'b', 'c']&#125; D = dict.fromkeys('spam') D = &#123;k: None for k in 'spam'&#125; 字典视图： keys,values,items都返回视图对象。2.x中返回结果列表。 视图对象是可迭代的，要应用列表操作或显示值，需要使用list()函数。1234567&gt;&gt;&gt; D.items() dict_items([('b', 2), ('c', 3), ('a', 1)]) &gt;&gt;&gt; list(D.items()) [('b', 2), ('c', 3), ('a', 1)]&gt;&gt;&gt; for k in D.keys(): print(k) # Iterators used automatically in loops&gt;&gt;&gt; for key in D: print(key) # Still no need to call keys() to iterate 视图对象创建后依然能够动态的显示其字典对象的改变：1234567891011121314&gt;&gt;&gt; D = &#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; K = D.keys() &gt;&gt;&gt; V = D.values() &gt;&gt;&gt; list(K) # Views maintain same order as dictionary ['b', 'c', 'a'] &gt;&gt;&gt; list(V) [2, 3, 1]&gt;&gt;&gt; del D['b'] # Change the dictionary in place &gt;&gt;&gt; D &#123;'c': 3, 'a': 1&#125; &gt;&gt;&gt; list(K) # Reflected in any current view objects ['c', 'a'] &gt;&gt;&gt; list(V) # Not true in 2.X! - lists detached from dict [3, 1] 字典视图和集合相似。 keys()返回的视图对象支持集合的交集与并集操作。values()的不支持。12345678&gt;&gt;&gt; K, V (dict_keys(['c', 'a']), dict_values([3, 1])) &gt;&gt;&gt; K | &#123;'x': 4&#125; # Keys (and some items) views are set-like &#123;'c', 'x', 'a'&#125; &gt;&gt;&gt; V &amp; &#123;'x': 4&#125; TypeError: unsupported operand type(s) for &amp;: 'dict_values' and 'dict' &gt;&gt;&gt; V &amp; &#123;'x': 4&#125;.values() TypeError: unsupported operand type(s) for &amp;: 'dict_values' and 'dict_values' keys视图对象可以与其它的视图对象，集合，字典对象混合操作123456789&gt;&gt;&gt; D = &#123;'a': 1, 'b': 2, 'c': 3&#125; &gt;&gt;&gt; D.keys() &amp; D.keys() # Intersect keys views &#123;'b', 'c', 'a'&#125; &gt;&gt;&gt; D.keys() &amp; &#123;'b'&#125; # Intersect keys and set &#123;'b'&#125; &gt;&gt;&gt; D.keys() &amp; &#123;'b': 1&#125; # Intersect keys and dict &#123;'b'&#125;&gt;&gt;&gt; D.keys() | &#123;'b', 'c', 'd'&#125; # Union keys and set &#123;'b', 'c', 'a', 'd'&#125; 如果items()视图对象仅包含不可变对象那么它也具有以上特性。 python3对字典key的排序 不可以：123D = &#123;'a': 1, 'b': 2, 'c': 3&#125;Ks = D.keys()Ks.sort() 会返回错误，Ks是视图对象。 可以：1234Ks = list(Ks)Ks.sort()for k in Ks: print(k, D[k]) 也可以：123Ks = D.keys()for k in sorted(Ks): print(k, D[k]) 也可以：12for k in sorted(D): print(k, D[k]) 内建sorted函数接受任何可迭代类型。 不能比较字典的大小了 但是可以比较排序后keys的list的大小：1sorted(D1.items()) &lt; sorted(D2.items()) # Like 2.X D1 &lt; D2 取消has_key方法 可以使用12if 'c' in D: print('present', D['c']) 或12if D.get('c') != None: print('present', D['c']) 元组，文件及其他元组集合类型，由简单的对象组构成。与列表相似，只不过不能在原地修改，是不可变的。不支持任何方法调用，具有列表的大多数属性。 1. 任意对象的有序集合。 2. 通过索引访问，支持索引和分片。 3. 属于不可变序列类型。 4. 固定长度，异构（可以包含其它对象，列表，字典或其它元组等），任意嵌套。 5. 元组是一个对象引用的数组。元组内部的可变对象是可以修改的。 元组的常用操作：123456789101112131415161718() An empty tuple T = (0,) A one-item tuple (not an expression) T = (0, 'Ni', 1.2, 3) A four-item tuple T = 0, 'Ni', 1.2, 3 Another four-item tuple (same as prior line)T = ('Bob', ('dev', 'mgr')) Nested tuples T = tuple('spam') Tuple of items in an iterable T[i] T[i][j] T[i:j] len(T) Index, index of index, slice, length T1 + T2 T * 3 Concatenate, repeat for x in T: print(x) 'spam' in T [x ** 2 for x in T] Iteration, membership T.index('Ni') T.count('Ni') Methods in 2.6, 2.7, and 3.X: search, count namedtuple('Emp', ['name', 'jobs']) Named tuple extension type 元组的操作： 元组的特殊语法：逗号和圆括号，如果圆括号内的唯一对象是元组对象而不是表达式，则需要在元素后圆括号前加一个逗号。12y = (40,) #这样才是元组类型&gt;&gt;&gt; x = (40) #这样是整数类型 必须使用括号和逗号的情况： 括号：在进行函数调用时，或嵌套在一个更大的表达式中 逗号：嵌套在更大的数据结构中，例如列表或字典，或者在python2的print语句中。 对元组进行排序：1234567891011&gt;&gt;&gt; T = ('cc', 'aa', 'dd', 'bb') &gt;&gt;&gt; tmp = list(T) # Make a list from a tuple's items &gt;&gt;&gt; tmp.sort() # Sort the list &gt;&gt;&gt; tmp ['aa', 'bb', 'cc', 'dd'] &gt;&gt;&gt; T = tuple(tmp) # Make a tuple from the list's items &gt;&gt;&gt; T ('aa', 'bb', 'cc', 'dd') &gt;&gt;&gt; sorted(T) # Or use the sorted built-in, and save two steps ['aa', 'bb', 'cc', 'dd'] 对元组使用列表解析：（列表解析属于序列操作，结果也是也一个list，但是输入可以是任何序列或可迭代对象）1234&gt;&gt;&gt; T = (1, 2, 3, 4, 5) &gt;&gt;&gt; L = [x + 20 for x in T] &gt;&gt;&gt; L [21, 22, 23, 24, 25] 注意不可变数据类型的不可变性只影响到最顶层的元组自己，元组中的列表等可变类型仍然可以被正常修改：1234567&gt;&gt;&gt; T = (1, [2, 3], 4) &gt;&gt;&gt; T[1] = 'spam' # This fails: can't change tuple itself TypeError: object doesn't support item assignment &gt;&gt;&gt; T[1][0] = 'spam' # This works: can change mutables inside &gt;&gt;&gt; T (1, ['spam', 3], 4) 元组与列表的不同：元组的不可变性提供了完整性，可以确保在程序中不会被另一个引用修改，元组可以作为字典的key使用，而列表不可以。 命名元组 文件内建open命令打开一个文件 python中常见的文件运算：1234567891011121314151617output = open(r'C:\spam', 'w') Create output file ('w' means write) input = open('data', 'r') Create input file ('r' means read) input = open('data') Same as prior line ('r' is the default) aString = input.read() Read entire file into a single string aString = input.read(N) Read up to next N characters (or bytes) into a string aString = input.readline() Read next line (including \n newline) into a string aList = input.readlines() Read entire file into list of line strings (with \n) output.write(aString) Write a string of characters (or bytes) into file output.writelines(aList) Write all line strings in a list into file output.close() Manual close (done for you when file is collected) output.flush() Flush output buffer to disk without closing anyFile.seek(N) Change file position to offset N for next operation for line in open('data'): use line File iterators read line by line open('f.txt', encoding='latin-1') Python 3.X Unicode text files (str strings) open('f.bin', 'rb') Python 3.X bytes files (bytes strings) codecs.open('f.txt', encoding='utf8') Python 2.X Unicode text files (unicode strings) open('f.bin', 'rb') Python 2.X bytes files (str strings) 使用文件： 文件迭代器是最好的读取行的工具。 读写的内容只能是字符串，不是其他对象。 文件是缓冲的并且可查找，主动的调用close和flush可以强制立即将内存中的文件写到磁盘上。也可以使用open的选项关闭缓冲，但是可能会影响到性能。python的文件是可以根据字节偏移随机访问的，使用seek方法可以在文件内跳转，读写任意指定位置。 close是是可选的，python会自动close一个collection。调用文件的close方法会终止与文件的连接，释放系统资源，flush内存中的缓冲到磁盘上。python在一个对象不再被引用时会自动进行内存的回收操作，file对象被回收时python也会自动的关闭文件。所以python中手动关闭文件是一个好习惯,虽然不是必需的，尤其是对于长时间运行的系统，关闭释放操作系统资源清空缓冲区。 文件操作：12345678910111213141516171819&gt;&gt;&gt; myfile = open('myfile.txt', 'w') # Open for text output: create/empty &gt;&gt;&gt; myfile.write('hello text file\n') # Write a line of text: string #写操作会返回写入文件的字符数16&gt;&gt;&gt; myfile.write('goodbye text file\n') 18 &gt;&gt;&gt; myfile.close() # Flush output buffers to disk&gt;&gt;&gt; myfile = open('myfile.txt') # Open for text input: 'r' is default &gt;&gt;&gt; myfile.readline() # Read the lines back 'hello text file\n' &gt;&gt;&gt; myfile.readline() 'goodbye text file\n' &gt;&gt;&gt; myfile.readline() # Empty string: end-of-file ''&gt;&gt;&gt; open('myfile.txt').read() # Read all at once into string 'hello text file\ngoodbye text file\n'&gt;&gt;&gt; print(open('myfile.txt').read()) # User-friendly display 如果需要逐行遍历文件，最好使用文件迭代器，更容易使用，更好的内存利用，更快的运行速度：12345678910&gt;&gt;&gt; for line in open('myfile.txt'): # Use file iterators, not reads ... print(line, end='') windows上python可以使用斜线替代路径中的反斜线：&gt;&gt;&gt; open(r'C:\Python33\Lib\pdb.py').readline() '#! /usr/bin/env python3\n' &gt;&gt;&gt; open('C:/Python33/Lib/pdb.py').readline() '#! /usr/bin/env python3\n'&gt;&gt;&gt; open('C:\\Python33\\Lib\\pdb.py').readline() '#! /usr/bin/env python3\n' 文本与二进制文件python3与python2文件的模式都是由open的第二个参数决定的，如果包含’b’表示以二进制形式打开。python支持二进制模式和文本模式。 python3中这两种模式有些区别： 文本模式下表示内容是正常的str字符串类型，自动进行unicode编解码，默认进行end-of-line转换。 二进制模式下表示文件内容是tytes字符串类型，允许程序原封不动的访问文件内容。python2中文本文件可以处理8bit文本和二进制数据，unicode文本使用nicode字符串类型和codecs.open文件接口进行操作。 123456789&gt;&gt;&gt; data = open('data.bin', 'rb').read() # Open binary file: rb=read binary &gt;&gt;&gt; data # bytes string holds binary data b'\x00\x00\x00\x07spam\x00\x08' &gt;&gt;&gt; data[4:8] # Act like strings b'spam' &gt;&gt;&gt; data[4:8][0] # But really are small 8-bit integers 115&gt;&gt;&gt; bin(data[4:8][0]) # Python 3.X/2.6+ bin() function '0b1110011' 在文件中存储python对象。必须使用工具将对象转换成字符串。12345678910&gt;&gt;&gt; X, Y, Z = 43, 44, 45 # Native Python objects &gt;&gt;&gt; S = 'Spam' # Must be strings to store in file &gt;&gt;&gt; D = &#123;'a': 1, 'b': 2&#125; &gt;&gt;&gt; L = [1, 2, 3] &gt;&gt;&gt; F = open('datafile.txt', 'w') # Create output text file &gt;&gt;&gt; F.write(S + '\n') # Terminate lines with \n &gt;&gt;&gt; F.write('%s,%s,%s\n' % (X, Y, Z)) # Convert numbers to strings &gt;&gt;&gt; F.write(str(L) + '$' + str(D) + '\n') # Convert and separate with $ &gt;&gt;&gt; F.close() 读出查看存入文件的内容：123456&gt;&gt;&gt; chars = open('datafile.txt').read() # Raw string display &gt;&gt;&gt; chars "Spam\n43,44,45\n[1, 2, 3]$&#123;'a': 1, 'b': 2&#125;\n" &gt;&gt;&gt; print(chars) # User-friendly display Spam 43,44,45 [1, 2, 3]$&#123;'a': 1, 'b': 2&#125; 现在如果想恢复文件中的内容为python对象：使用工具将字符串转换为python对象12345678910111213&gt;&gt;&gt; F = open('datafile.txt') # Open again &gt;&gt;&gt; line = F.readline() # Read one line &gt;&gt;&gt; line 'Spam\n' &gt;&gt;&gt; line.rstrip() # Remove end-of-line 无论有无eol都可以使用。'Spam'&gt;&gt;&gt; line = F.readline() # Next line from file &gt;&gt;&gt; line # It's a string here '43,44,45\n' &gt;&gt;&gt; parts = line.split(',') # Split (parse) on commas &gt;&gt;&gt; parts ['43', '44', '45\n'] 转换类型：1234567891011121314151617&gt;&gt;&gt; int(parts[1]) # Convert from string to int 44 &gt;&gt;&gt; numbers = [int(P) for P in parts] # Convert all in list at once &gt;&gt;&gt; numbers [43, 44, 45]&gt;&gt;&gt; line = F.readline() &gt;&gt;&gt; line "[1, 2, 3]$&#123;'a': 1, 'b': 2&#125;\n" &gt;&gt;&gt; parts = line.split('$') # Split (parse) on $ &gt;&gt;&gt; parts ['[1, 2, 3]', "&#123;'a': 1, 'b': 2&#125;\n"] &gt;&gt;&gt; eval(parts[0]) # Convert to any object type [1, 2, 3] &gt;&gt;&gt; objects = [eval(P) for P in parts] # Do same for all in list&gt;&gt;&gt; objects [[1, 2, 3], &#123;'a': 1, 'b': 2&#125;] 使用pickle存储python的原生对象。pickle.dump(D, F) 使用eval将字符串转换为对象是一个强大的工具，实际上，eval可以运行任何python表达式，如果给表达式足够的权限它甚至能删除计算机上的所有文件。 python提供了一个标准库pickle模块用作存储python原生对象：12345&gt;&gt;&gt; D = &#123;'a': 1, 'b': 2&#125; &gt;&gt;&gt; F = open('datafile.pkl', 'wb') &gt;&gt;&gt; import pickle &gt;&gt;&gt; pickle.dump(D, F) # Pickle any object to file &gt;&gt;&gt; F.close() 加载恢复：1234&gt;&gt;&gt; F = open('datafile.pkl', 'rb') &gt;&gt;&gt; E = pickle.load(F) # Load any object from file &gt;&gt;&gt; E &#123;'a': 1, 'b': 2&#125; pickle模块会执行对象序列化的转换操作，存入或读出bytes字符串，pickle可以从这个格式重构出对象：12&gt;&gt;&gt; open('datafile.pkl', 'rb').read() # Format is prone to change! b'\x80\x03&#125;q\x00(X\x01\x00\x00\x00bq\x01K\x02X\x01\x00\x00\x00aq\x02K\x01u.' shelve模块使用pickle将对象存储在access-by-key文件系统中。使用JSON格式存储python对象123456789101112131415161718192021222324252627&gt;&gt;&gt; name = dict(first='Bob', last='Smith') &gt;&gt;&gt; rec = dict(name=name, job=['dev', 'mgr'], age=40.5) &gt;&gt;&gt; rec &#123;'job': ['dev', 'mgr'], 'name': &#123;'last': 'Smith', 'first': 'Bob'&#125;, 'age': 40.5&#125;&gt;&gt;&gt; import json &gt;&gt;&gt; json.dumps(rec) '&#123;"job": ["dev", "mgr"], "name": &#123;"last": "Smith", "first": "Bob"&#125;, "age": 40.5&#125;' &gt;&gt;&gt; S = json.dumps(rec) &gt;&gt;&gt; S'&#123;"job": ["dev", "mgr"], "name": &#123;"last": "Smith", "first": "Bob"&#125;, "age": 40.5&#125;' &gt;&gt;&gt; O = json.loads(S) &gt;&gt;&gt; O &#123;'job': ['dev', 'mgr'], 'name': &#123;'last': 'Smith', 'first': 'Bob'&#125;, 'age': 40.5&#125; &gt;&gt;&gt; O == rec True&gt;&gt;&gt; json.dump(rec, fp=open('testjson.txt', 'w'), indent=4) &gt;&gt;&gt; print(open('testjson.txt').read()) &#123; "job": [ "dev", "mgr" ], "name": &#123; "last": "Smith", "first": "Bob" &#125;, "age": 40.5 &#125; &gt;&gt;&gt; P = json.load(open('testjson.txt')) &gt;&gt;&gt; P &#123;'job': ['dev', 'mgr'], 'name': &#123;'last': 'Smith', 'first': 'Bob'&#125;, 'age': 40.5&#125; JSON中的字符串都是unicode，python2中会看到json字符串是以u开头的，python3中是普通字符串。所以再将非ASCII文本写入文件或从文件读出时会有不同。 二进制数据包的存储与解析python的struct模块用来处理来自网络或其他语言创建的二进制数据包，可以创建或解析数据包，可以看作是另一种在解释文件中二进制数据的方法使用struct创建一个二进制数据包文件：12345678&gt;&gt;&gt; F = open('data.bin', 'wb') # Open binary output file &gt;&gt;&gt; import struct &gt;&gt;&gt; data = struct.pack('&gt;i4sh', 7, b'spam', 8) # Make packed binary data #此处使用了一个格式化字符串'&gt;i4sh'，表示一个4字节整数，一个4字符字符串，一个2字节整数。&gt;&gt;&gt; data b'\x00\x00\x00\x07spam\x00\x08' &gt;&gt;&gt; F.write(data) # Write byte string &gt;&gt;&gt; F.close() 将文件中的二进制数据包解析为python对象：1234567&gt;&gt;&gt; F = open('data.bin', 'rb') &gt;&gt;&gt; data = F.read() # Get packed binary data &gt;&gt;&gt; data b'\x00\x00\x00\x07spam\x00\x08' &gt;&gt;&gt; values = struct.unpack('&gt;i4sh', data) # Convert to Python objects &gt;&gt;&gt; values (7, b'spam', 8) 文件上下文管理器python3与python2.6以后，允许把文件的处理包裹到逻辑层中，确保退出后可自动关闭。123with open(r'C:\code\data.txt') as myfile: for line in myfile: ...use line here... 等价于：123456myfile = open(r'C:\code\data.txt') try: for line in myfile: ...use line here... finally: myfile.close() 其它文件工具 标准流，sys模块中预先打开的文件对象，sys.stdout os模块中的描述符文件，支持文件锁等低级工具。 sockets、pipes和FIFO文件 进程同步和网络通信 通过key来存取的文件。 shell命令流 os.popen和subprocess.popen等工具。 类型分类复习 对象根据分类共享操作。 只有可变对象(列表，字典，集合)和在原处修改，不可变对象（数字，字符串，元组）不能修改。 文件类型只导出了方法，所以可变性不适用于文件类型 对象 列表，字典和元组可以存储任何类型的对象 集合只能包含不可变类型的对象 列表，字典和元组可以随意的嵌套 列表，字典和集合可以动态的增长和收缩 注意引用与拷贝需要明确拷贝时： 分片L[:] 只能顶层拷贝 字典，集合和列表的x.copy()方法。 只能顶层拷贝 内置函数list(L)，dict(D),set(S)能生成拷贝 copy标准库能生成完整拷贝。 能进行深层拷贝X=copy.deepcopy(Y) 比较 “==” 操作符测试对象值的相等性 “is” 表达式测试对象的一致性，是否是同一对象。1234567891011121314&gt;&gt;&gt; L1 = [1, ('a', 3)] # Same value, unique objects &gt;&gt;&gt; L2 = [1, ('a', 3)]&gt;&gt;&gt; L1 == L2, L1 is L2 # Equivalent? Same object? (True, False)&gt;&gt;&gt; S1 = 'spam' &gt;&gt;&gt; S2 = 'spam' &gt;&gt;&gt; S1 == S2, S1 is S2 (True, True)&gt;&gt;&gt; S1 = 'a longer string' &gt;&gt;&gt; S2 = 'a longer string' &gt;&gt;&gt; S1 == S2, S1 is S2 (True, False) 比较大小 数字通过大小比较，转换到需要的最高类型 字符串按照字典顺序（根据字符集的码点值，ord的返回值），逐字符比较直到发现不匹配 列表和元组从左到右对每元素内容进行比较，直到结尾或发现第一个不匹配的值 如果两个集合包含相同的元素则说他们是相等的 字典，在python2中通过排序后（key,value）列表比较，python3中不允许测试字典的相对大小 非数值的混合大小比较，python3中发生错误，python2中根据类型名称的第一个字符进行比较 python中的真假 数字如果非零则为真 其它对象如果非空则为真 ， 测试对象本身的值而不是与空对象比较。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&gt;&gt;&gt; L = [1, 2, 3] &gt;&gt;&gt; M = ['X', L, 'Y'] # Embed a reference to L &gt;&gt;&gt; M ['X', [1, 2, 3], 'Y']&gt;&gt;&gt; L[1] = 0 # Changes M too &gt;&gt;&gt; M ['X', [1, 0, 3], 'Y']&gt;&gt;&gt; L = [1, 2, 3] &gt;&gt;&gt; M = ['X', L[:], 'Y'] # Embed a copy of L (or list(L), or L.copy()) &gt;&gt;&gt; L[1] = 0 # Changes only L, not M &gt;&gt;&gt; L [1, 0, 3] &gt;&gt;&gt; M ['X', [1, 2, 3], 'Y']&gt;&gt;&gt; L = [4, 5, 6] &gt;&gt;&gt; X = L * 4 # Like [4, 5, 6] + [4, 5, 6] + ... &gt;&gt;&gt; Y = [L] * 4 # [L] + [L] + ... = [L, L,...] &gt;&gt;&gt; X [4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6] &gt;&gt;&gt; Y [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]&gt;&gt;&gt; L[1] = 0 # Impacts Y but not X &gt;&gt;&gt; X [4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6] &gt;&gt;&gt; Y [[4, 0, 6], [4, 0, 6], [4, 0, 6], [4, 0, 6]]&gt;&gt;&gt; L = [4, 5, 6] &gt;&gt;&gt; Y = [list(L)] * 4 # Embed a (shared) copy of L &gt;&gt;&gt; L[1] = 0 &gt;&gt;&gt; Y [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]&gt;&gt;&gt; Y[0][1] = 99 # All four copies are still the same &gt;&gt;&gt; Y [[4, 99, 6], [4, 99, 6], [4, 99, 6], [4, 99, 6]] &gt;&gt;&gt; L = [4, 5, 6] &gt;&gt;&gt; Y = [list(L) for i in range(4)] &gt;&gt;&gt; Y [[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]] &gt;&gt;&gt; Y[0][1] = 99 &gt;&gt;&gt; Y [[4, 99, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]] python语句1234567891011121314151617181920212223242526272829303132333435363738394041424344454647赋值 创建引用 a, b = &apos;good&apos;, &apos;bad&apos; 调用其它表达式 运行函数 log.write(&quot;spam, ham&quot;) 打印语句 打印对象 print(&apos;The Killer&apos;, joke) if/elif/else 条件 if &quot;python&quot; in text: print(text) for/else 迭代 for x in mylist: print(x) while/else 一般循环 while X &gt; Y: print(&apos;hello&apos;) pass 空语句 while True: pass break 循环退出 while True: if exittest(): break continue 下一循环 while True: if skiptest(): continue def 函数和方法 def f(a, b, c=1, *d): print(a+b+c+d[0]) return 返回函数结果 def f(a, b, c=1, *d): return a+b+c+d[0] yield 生成器函数 def gen(n): for i in n: yield i*2 global 命名空间 x = &apos;old&apos; def function(): global x, y; x = &apos;new&apos; nonlocal 命名空间 def outer(): x = &apos;old&apos; def function(): nonlocal x; x = &apos;new&apos; import 模块访问 import sys from 属性访问 from sys import stdin class 创建对象 class Subclass(Superclass): staticData = [] def method(self): pass try/except/ finally 异常捕获 try: action() except: print(&apos;action error&apos;) raise 触发异常 raise EndSearch(location) assert 调试检查 assert X &gt; Y, &apos;X too small&apos; with/as 环境管理器 with open(&apos;data&apos;) as myfile: process(myfile) del 删除引用 del data[k] del data[i:j] del obj.attr del variable 所有的python复合语句首行以冒号结尾，接下来的block缩进。 位于测试两侧的括号是可选的 if (x &lt; y): 与 if x &lt; y:一样 ，python的风格就是在此不使用() 语句末尾的；要省略， x = 1; 与 x = 1 都可工作，但python的风格是不使用分号 嵌套代码块的开头结尾的大括号。python使用缩进，缩进结束代码块结束。 python中一行中挤进多个语句时要用分号分隔。a = 1; b = 2; print(a + b) 如果想让一个语句跨越多行，需要使用一对括号把语句括起来，() [] {} 任选。 \换行在python中过时了 简单的复合语句可以这样 if x &gt; y: print(x) ， 单行if，单行循环 python2中nonlocal不可用python2中print是一个语句，python3中print是一个内建函数python2中exec是一个语句，python3中exec是一个内建函数python2.5中try/except和try/finally语句被合并为try/except/finallypython2.5中with/as语句是可选的，需要明确的打开才能使用：from future import with_statement python中所有的复合语句的第一行都以冒号结尾： 12Header line: Nested statement block python中圆括号是可选的 12if (x &lt; y) #C语言的语法if x &lt; y #python中的语法 但是python中任何表达式都可以使用圆括号包围，增加圆括号并不会破坏python代码，不会产生错误。但是不建议使用括号的写法，python的方法就是省略括号。 赋值表达式和打印 赋值语句 赋值语句总是建立对象引用值 变量名在首次赋值时会被创建 变量名在引用前必须先赋值 执行隐式赋值的一些操作，模块导入，函数和类的定义，for循环变量，函数参数都是隐式赋值。 赋值语句的形式。1234567spam = 'Spam' 基本形式spam, ham = 'yum', 'YUM' 元组赋值运算（位置性） [spam, ham] = ['yum', 'YUM'] 列表赋值运算（位置性）a, b, c, d = 'spam' 序列赋值，通用性，可以接受右侧任何类型的可迭代实例。a, *b = 'spam' 扩展序列解包spam = ham = 'lunch' 多目标赋值运算spams += 42 增强赋值运算。等于 spams = spams + 42 元组和列表的解包赋值：=左边是元组或列表时，python会根据位置从左到右将右边的对象与左边的目标配对 序列赋值：任何名称的序列可以被赋予任何值的序列，python根据位置一次一个的赋值，=两边的序列类型何以混用。12345678&gt;&gt;&gt; nudge = 1 # Basic assignment &gt;&gt;&gt; wink = 2 &gt;&gt;&gt; A, B = nudge, wink # Tuple assignment&gt;&gt;&gt; A, B # Like A = nudge; B = wink (1, 2) &gt;&gt;&gt; [C, D] = [nudge, wink] # List assignment &gt;&gt;&gt; C, D (1, 2) 使用序列赋值进行变量交换123456789101112&gt;&gt;&gt; nudge = 1 &gt;&gt;&gt; wink = 2 &gt;&gt;&gt; nudge, wink = wink, nudge # Tuples: swaps values &gt;&gt;&gt; nudge, wink # Like T = nudge; nudge = wink; wink = T (2, 1)&gt;&gt;&gt; [a, b, c] = (1, 2, 3) # Assign tuple of values to list of names &gt;&gt;&gt; a, c (1, 3) &gt;&gt;&gt; (a, b, c) = "ABC" # Assign string of characters to tuple &gt;&gt;&gt; a, c ('A', 'C') 实际上序列赋值=号右边不仅仅支持序列，可以支持任何可迭代对象。 扩展序列解包python3中支持一个新的序列赋值语句，如a, *b = ‘spam’中，a获得s,b获得剩余所有的。 多目标赋值，相当于引用到同一个对象。 高级赋值形式： 虽然在=两侧可以混合相匹配的序列类型。右边的元素数目还是要和左边变量的数目相等。123456&gt;&gt;&gt; string = 'SPAM' &gt;&gt;&gt; a, b, c, d = string # Same number on both sides &gt;&gt;&gt; a, d ('S', 'M') &gt;&gt;&gt; a, b, c = string # Error if not ..error text omitted... ValueError: too many values to unpack (expected 3) 为了能更柔性的处理：12345678910111213141516171819&gt;&gt;&gt; a, b, c = string[0], string[1], string[2:] # Index and slice &gt;&gt;&gt; a, b, c ('S', 'P', 'AM')&gt;&gt;&gt; a, b, c = list(string[:2]) + [string[2:]] # Slice and concatenate &gt;&gt;&gt; a, b, c ('S', 'P', 'AM') &gt;&gt;&gt; a, b = string[:2] # Same, but simpler &gt;&gt;&gt; c = string[2:] &gt;&gt;&gt; a, b, c ('S', 'P', 'AM') &gt;&gt;&gt; (a, b), c = string[:2], string[2:] # Nested sequences &gt;&gt;&gt; a, b, c ('S', 'P', 'AM')&gt;&gt;&gt; ((a, b), c) = ('SP', 'AM') # Paired by shape and position 、&gt;&gt;&gt; a, b, c ('S', 'P', 'AM') 用于循环:12for (a, b, c) in [(1, 2, 3), (4, 5, 6)]: ... # Simple tuple assignment for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: ... # Nested tuple assignment 用于函数：12def f(((a, b), c)): ... # For arguments too in Python 2.X, but not 3.X f(((1, 2), 3)) python3中的扩展序列解包实际应用：*X星号开头的变量会收集所有剩余未分配给其他变量的值1234567891011121314151617181920212223242526&gt;&gt;&gt; seq = [1, 2, 3, 4] &gt;&gt;&gt; a, b, c, d = seq &gt;&gt;&gt; print(a, b, c, d) 1 2 3 4 &gt;&gt;&gt; a, b = seq ValueError: too many values to unpack (expected 2)&gt;&gt;&gt; a, *b = seq &gt;&gt;&gt; a 1 &gt;&gt;&gt; b [2, 3, 4]&gt;&gt;&gt; *a, b = seq &gt;&gt;&gt; a [1, 2, 3] &gt;&gt;&gt; b 4&gt;&gt;&gt; a, *b, c = seq &gt;&gt;&gt; a 1 &gt;&gt;&gt; b [2, 3] &gt;&gt;&gt; c 4 当使用带星号的名称的时候，左边目标中的项数不需要与主体序列的长度匹配。带星号的名称可以出现在目标中的任何地方。123456789&gt;&gt;&gt; a, *b = 'spam' &gt;&gt;&gt; a, b ('s', ['p', 'a', 'm']) &gt;&gt;&gt; a, *b, c = 'spam' &gt;&gt;&gt; a, b, c ('s', ['p', 'a'], 'm') &gt;&gt;&gt; a, *b, c = range(4) &gt;&gt;&gt; a, b, c (0, [1, 2], 3) 一个序列解包总是返回多个匹配项的一个列表，分片总是返回相同对象的序列。如果没有剩下的内容可以匹配带星号的名称，会赋值一个空的列表。1234567891011&gt;&gt;&gt; seq = [1, 2, 3, 4]&gt;&gt;&gt; a, b, c, *d = seq &gt;&gt;&gt; print(a, b, c, d) 1 2 3 [4] #*d总是返回列表类型&gt;&gt;&gt; a, b, c, d, *e = seq &gt;&gt;&gt; print(a, b, c, d, e) 1 2 3 4 [] &gt;&gt;&gt; a, b, *e, c, d = seq &gt;&gt;&gt; print(a, b, c, d, e) 1 2 3 4 [] #如果没有剩余值，也会返回一个空列表。 如果有多个带星号的名称或者值少了没有带星号的名称，或者带星号的名称自身没有编写到一个列表中，都会引发错误。1234567891011&gt;&gt;&gt; a, *b, c, *d = seq SyntaxError: two starred expressions in assignment &gt;&gt;&gt; a, b = seq ValueError: too many values to unpack (expected 2) &gt;&gt;&gt; *a = seq SyntaxError: starred assignment target must be in a list or tuple&gt;&gt;&gt; *a, = seq &gt;&gt;&gt; a [1, 2, 3, 4] 注意扩展序列解包只是一个便利工具，我们可以使用分片和索引达到所有效果，python2中没有扩展解包的支持只能使用索引和分片。1234567&gt;&gt;&gt; *a, b = seq # Rest, last &gt;&gt;&gt; a, b ([1, 2, 3], 4) &gt;&gt;&gt; a, b = seq[:-1], seq[-1] # Rest, last: traditional &gt;&gt;&gt; a, b ([1, 2, 3], 4) 序列解包用于for循环1234for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]：python2中： for all in [(1, 2, 3, 4), (5, 6, 7, 8)]: a, b, c = all[0], all[1:3], all[3] 多目标赋值语句：多个变量都指向同一个对象引用。123&gt;&gt;&gt; a = b = c = 'spam' &gt;&gt;&gt; a, b, c ('spam', 'spam', 'spam') 等价于123&gt;&gt;&gt; c = 'spam' &gt;&gt;&gt; b = c &gt;&gt;&gt; a = b 对于不可变对象通常不会有副作用，但对于可变对象：123456789101112&gt;&gt;&gt; a = b = [] &gt;&gt;&gt; b.append(42) &gt;&gt;&gt; a, b ([42], [42])&gt;&gt;&gt; a = [] &gt;&gt;&gt; b = [] # a and b do not share the same object &gt;&gt;&gt; b.append(42) &gt;&gt;&gt; a, b ([], [42])&gt;&gt;&gt; a, b = [], [] # a and b do not share the same object 参数赋值语句：123456789101112X += Y X &amp;= Y X ?= Y X |= Y X *= Y X ^= Y X /= Y X &gt;&gt;= Y X %= Y X &lt;&lt;= Y X **= Y X //= Y 优点： 程序员减少输入 左侧只需计算一次（它可以是一个复杂的表达式） 对于支持原处修改的对象而言这种形式会自动修改运算，而不是复制。 所以参数赋值对于列表来说是原处修改：12345678910111213141516171819202122232425&gt;&gt;&gt; L = [1, 2] &gt;&gt;&gt; L = L + [3] # 连接操作，创建一个新列表，速度较慢&gt;&gt;&gt; L [1, 2, 3] &gt;&gt;&gt; L.append(4) # 速度较快，原地修改&gt;&gt;&gt; L [1, 2, 3, 4]&gt;&gt;&gt; L = L + [5, 6] # Concatenate: slower &gt;&gt;&gt; L [1, 2, 3, 4, 5, 6] &gt;&gt;&gt; L.extend([7, 8]) # Faster, but in place &gt;&gt;&gt; L [1, 2, 3, 4, 5, 6, 7, 8]&gt;&gt;&gt; L += [9, 10] # python会自动调用速度更快的 L.extend([9, 10]) &gt;&gt;&gt; L [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; L = [] &gt;&gt;&gt; L += 'spam' # += and extend 允许对任意序列进行操作, but + 不能混用类型&gt;&gt;&gt; L ['s', 'p', 'a', 'm']&gt;&gt;&gt; L = L + 'spam' TypeError: can only concatenate list (not "str") to list 注意参数赋值时的引用：1234567891011&gt;&gt;&gt; L = [1, 2] &gt;&gt;&gt; M = L # L and M reference the same object &gt;&gt;&gt; L = L + [3, 4] # 连接运算产生一个新的对象，不改变原对象 &gt;&gt;&gt; L, M # Changes L but not M ([1, 2, 3, 4], [1, 2]) &gt;&gt;&gt; L = [1, 2] &gt;&gt;&gt; M = L &gt;&gt;&gt; L += [3, 4] # But += 在原地修改原对象内容&gt;&gt;&gt; L, M # M sees the in-place change too! ([1, 2, 3, 4], [1, 2, 3, 4]) 变量的命名规则 语法 ：（下划线或字母）+（任意数目的字母，数字或下划线），变量名必须以下划线或字母开头，后面接任意数目的字母下划线或数字 区分大小写。 禁止使用保留字。 python3中的保留字：1False class finally is return None continue for lambda try True def from nonlocal while and del global not with as elif if or yield assert else import pass break except in raise python2.x中：print, exec是一个保留字，不是内置函数，nonlocal不是保留字。 import语句中的模块变量名会变成脚本中的变量，and.py和my-code.py这样的文件名是无法导入的，保留字是禁区，中横线不可以，下划线可以。 命名惯例 以单一下划线开头的变量名（_X）不会被from module import * 语句导入。 前后都有两个下划线的变量名(X)是系统定义的变量名，对解释器有特殊意义。 以两个下划线开头，但结尾没有两个下划线的变量名是类的本地变量(__X) 交互模式运行时，只有单个下划线的变量名(_X)会保存最后表达式的结果。 以上是解释器惯例，还有一些程序员惯例： 类变量名通常以一个大写字母开头，模块名以小写字母开头。 self虽然不是保留字，但在类中一般有特殊的角色。 变量名没有类型，但对象有类型。 表达式语句1.调用函数和方法2.交互模式的提示符下打印值 打印操作文件对象方法，print把对象转换为字符串表示打印到stdout流，添加一些自动的格式化，将结果发送到标准输出流或其他文件相似的流。 标准输出流，程序文本输出的默认的地方，加上标准错误和标准输入，脚本启动时创建的3种连接的一种。 3.0中print内置函数，不会返回我们关心的任何值，返回None。1print([object, ...][, sep=' '][, end='\n'][, file=sys.stdout][, flush=False]) 其中方括号中的项是可选的，可以省略，=后面的值都给出了参数的默认值。print函数把字符串sep所分隔开的一个或多个对象的文本表示，后面跟着的字符串end，都打印到流file中。 sep，end和file部分给出的话，需要使用name=value的语法，根据名称而不是位置传递参数。 sep是在每个对象的文本之间插入一个字符串，如果没有传递的话，默认是一个空格，传递一个空字符串会抑制分隔符。 end是添加在打印文本末尾的一个字符串，如果没有传递的话默认是一个换行符\n，传递一个空字符串将会避免在打印的文本末尾移动到下一个输入行，下一个print会添加到当前行的末尾。 file指定了文本将要发送到的文件，标准流或者其他类似文件的对象。如果没有传递，默认是sys.stdout。带有类似文件的write（string）方法的任何对象都可以传递，真正的文件应该已经为了输出而打开。 要打印的每个对象的文本表示，通过把该对象传递给str内置函数调用而获得。完全没有参数的时候，print函数直接打印一个空行。123456789101112131415161718192021222324&gt;&gt;&gt; print(x, y, z, sep='') # Suppress separator spam99['eggs'] &gt;&gt;&gt; print(x, y, z, sep=', ') # Custom separator spam, 99, ['eggs']&gt;&gt;&gt; print(x, y, z, end='') # Suppress line break spam 99 ['eggs']&gt;&gt;&gt; &gt;&gt;&gt; print(x, y, z, end=''); print(x, y, z) # Two prints, same output line spam 99 ['eggs']spam 99 ['eggs'] &gt;&gt;&gt; print(x, y, z, end='...\n') # Custom line end spam 99 ['eggs']... &gt;&gt;&gt;&gt;&gt;&gt; print(x, y, z, sep='...', end='!\n') # Multiple keywords spam...99...['eggs']! &gt;&gt;&gt; print(x, y, z, end='!\n', sep='...') # Order doesn't matter spam...99...['eggs']!&gt;&gt;&gt; print(x, y, z, sep='...', file=open('data.txt', 'w')) # Print to a file &gt;&gt;&gt; print(x, y, z) # Back to stdout spam 99 ['eggs'] &gt;&gt;&gt; print(open('data.txt').read()) # Display file text spam...99...['eggs'] 2.x 与 3.0的print比较12342.x 3.xprint x, y print(x, y) 把对象的文本形式打印到 sys.stdout; 并在各项之间添加一个空格，在末尾添加一个行末。 print x, y, print(x, y, end=&apos;&apos;) 同上，但不会在末尾添加行末 print &gt;&gt; afile, x, y print(x, y, file=afile) 文本发送到afile.write, 而不是sys.stdout.write。 要注意python2.x和3.0的print不同。 print语句只是将文本传递给sys.stdout.write方法。1234567&gt;&gt;&gt; print('hello world') # Print a string object in 3.X hello world &gt;&gt;&gt; print 'hello world' # Print a string object in 2.X hello world&gt;&gt;&gt; import sys # Printing the hard way &gt;&gt;&gt; sys.stdout.write('hello world\n') hello world 手工重定向流1234567891011import sys sys.stdout = open('log.txt', 'a') # Redirects prints to a file ... print(x, y, x) # Shows up in log.txt#### 自动重定向流log = open('log.txt', 'a') # 3.X print(x, y, z, file=log) # Print to a file-like object print(a, b, c) # Print to original stdout log = open('log.txt', 'a') # 2.X print &gt;&gt; log, x, y, z # Print to a file-like object print a, b, c # Print to original stdout 同时写到文件与标准输出123456789&gt;&gt;&gt; log = open('log.txt', 'w') &gt;&gt;&gt; print(1, 2, 3, file=log) # For 2.X: print &gt;&gt; log, 1, 2, 3 &gt;&gt;&gt; print(4, 5, 6, file=log) &gt;&gt;&gt; log.close() &gt;&gt;&gt; print(7, 8, 9) # For 2.X: print 7, 8, 97 8 9 &gt;&gt;&gt; print(open('log.txt').read()) 1 2 3 4 5 6 python2与python3的版本中立的打印：1231. 2to3 converter2. Importing from __future__ from __future__ import print_function #使python2支持python3的打印语句 if测试和与语法规则 通用格式： 123456if test1: # if test statements1 # Associated block elif test2: # Optional elifs statements2else: # Optional else statements3 python中没有switch/case语句，多路分支写成一系列的if elif 测试或者对字典进行索引运算或搜索 123456choice = 'ham'print(&#123;'spam': 1.25, 'ham': 1.99, 'eggs': 0.99, 'bacon': 1.10&#125;[choice]) 1.99 字典默认值能编码到has_key测试，get方法调用或异常捕捉中。1234567branch = &#123;'spam': 1.25, 'ham': 1.99, 'eggs': 0.99&#125;print(branch.get('spam', 'Bad choice')) 1.25print(branch.get('bacon', 'Bad choice')) Bad choice 使用字典处理更复杂的操作（函数字典）：123456def function(): ... def default(): ... branch = &#123;'spam': lambda: ..., # A table of callable function objects 'ham': function, 'eggs': lambda: ...&#125; branch.get(choice, default)() python语法规则 语句是逐个运行的，除非你不这样编写。python一般会按照次序从头到尾执行文件中嵌套块中的语句。 块和语句的边界会自动检测，使用缩进组合嵌套语句，一行的末尾就是语句的结尾。 复合语句=首行+‘:’+缩进语句。 空白行，空格及注释通常都会忽略。 文档字符串会被忽略，但会保存起来由工具显示。 块分隔符:缩进规则 python会自动根据行缩进探测块边界，具有相同缩进的语句属于同一个代码块，当遇到文件结束或更少缩进的行则认为一个代码块结束 最顶层的代码必须从第一列开始 嵌套代码块可以从任意列开始，缩进可以包含任意数目的空格和tab，但相同代码块内的所有语句必须有相同的缩进。 避免混合使用tab和空格，python3中会检查这种错误。 语句分隔符：python的语句一般都是放在所在行的末尾结束，不过当语句太长，难以放在一行时也可放在多行： 如果使用语法括号对，语句就可横跨多行。() [] {}中的代码均可跨行。 如果语句以反斜线结尾就可横跨数行。 字符串常量有特殊的规则，三重引号字符串块可以横跨数行。 其它规则，可以使用分号来终止语句，有时可以用于把一个以上的简单语句挤进单个行中。注释和空白行能出现在文件的任意之处。 一些特殊case: 括号内的内容可以跨多行 123L = [ "Good", "Bad", "Ugly"] # 括号内是可以跨多行的，圆括号（表达式，函数参数，函数头，元组和生成器表达式），花括号（字典，集合，字典与集合解析）等都适用 使用反斜线可以继续一行123if a == b and c == d and \ d == e and f == g: print('olde') # Backslashes allow continuations... 由于任何表达式可以被包含在括号内，还有另一种方式：123if (a == b and c == d and d == e and e == f): print('new') # But parentheses usually do too, and are obvious 但是使用\时要注意，有些情况丢掉\并不会出错但是会改变程序：12x = 1 + 2 + 3 \ # Omitting the \ makes this very different! +4 多行语句在同一行： 1x = 1; y = 2; print(x) # More than one simple statement 三引号内的字符串文本是可以跨多行的。两个相邻的字符串会自动连接，就像使用了+操作符一样。 123456789101112S = """ aaaa bbbb cccc""" &gt;&gt; S'\naaaa\nbbbb \ncccc'S = ('aaaa' 'bbbb' # Comments here are ignored 'cccc')&gt;&gt; S'aaaabbbbcccc' 简单语句的headerline 1if 1: print('hello') # Simple statement on header line 真值测试 所有对象都有一个固有的布尔值，或真或假。 python中任何非零数字或非空对象都为真。 数字0，空对象及特殊对象None都为假。 比较和相等测试会递归的应用在数据结构中。 比较和相等测试会返回True或False 布尔and和or运算符会返回真或假的操作对象。 布尔操作符在结果确定时立即停止（短路操作） 比较运算符会返回True或False作为结果：12&gt;&gt;&gt; 2 &lt; 3, 3 &lt; 2 # Less than: return True or False (1 or 0) (True, False) and或or操作符会返回一个对象，不是运算符左侧的对象就是运算符右侧的对象，而不是简单的true或false。 or操作符，python会由左至右计算操作对象，然后返回第一个为真的操作对象，并且在找到第一个为真的操作数的地方停止，不去执行后面的操作，这叫做短路计算。1234567&gt;&gt;&gt; 2 or 3, 3 or 2 # Return left operand if true (2, 3) # Else, return right operand (true or false)&gt;&gt;&gt; [] or 3 3 &gt;&gt;&gt; [] or &#123;&#125; &#123;&#125; and操作符，python由左至右计算操作数，并停止在第一个为假的对象上。123456&gt;&gt;&gt; 2 and 3, 3 and 2 # Return left operand if false (3, 2) # Else, return right operand (true or false) &gt;&gt;&gt; [] and &#123;&#125; [] &gt;&gt;&gt; 3 and [] [] if/else三元表达式A = Y if X else Z 只有当X为真时python才会执行Y，X为假时才会执行Z，这也是短路运算。 A = ((X and Y) or Z) 另一种方法：A = [Z, Y][bool(X)] bool会将X转换成对应的整数1或0，然后作为索引选定某元素，不同的是，他不会进行短路运算，无论X真假，都会执行Y和Z。 注意布尔值123456X = A or B or C or None X会被设置为A，B和C中第一个非空的对象，如果都为空，则设为None。X = A or default A为假时使用defaultif f1() or f2(): ... 如果f1返回真，python将不再会执行f2.tmp1, tmp2 = f1(), f2() 要保证两个函数都执行，要在or之前调用他们。if tmp1 or tmp2: ... while和for循环while循环python中最通用的迭代结构1234while test: # Loop test statements # Loop body else: # Optional else statements # Run if didn't exit loop with break 可选的else，控制权离开while循环有没有碰到break语句时会执行。 模拟do until循环： 123while True: ...loop body... if exitTest(): break break, continue, pass, 和循环else 1234break 跳出最近所在的循环。continue 跳到最近所在循环的开头处pass 什么都不做，空占位符循环else 只有当循环正常离开时才会执行（没有碰到break语句）。 一般循环格式： 123456while test: statements if test: break # Exit loop now, skip else if present if test: continue # Go to top of loop now, to test1 else: statements # Run if we didn't hit a 'break' pass语句：无操作的占位符 1234567def func1(): pass ``` python3.x中可以使用：```pythondef func1(): ... 或者1def func1(): ... continue break 循环的else子句12345678x = y // 2 # For some y &gt; 1 while x &gt; 1: if y % x == 0: # Remainder print(y, 'has factor', x) break # Skip else x -= 1 else: # Normal exit print(y, 'is prime') 等效版本：123456789101112131415161718found = False while x and not found: if match(x[0]): # Value at front? print('Ni') found = True else: x = x[1:] # Slice off front and repeat if not found: print('not found') 等效于：while x: # Exit when x empty if match(x[0]): print('Ni') break # Exit, go around else x = x[1:] else: print('Not found') # Only here if exhausted x for循环通用的序列迭代器，可以遍历任何有序的序列对象内的元素。可用于字符串，列表，元组，其它内置可迭代对象，以及我们能通过类所创建的新对象。 一般格式：1234for target in object: # Assign object items to target statements # Repeated loop body: use target else: # Optional else part statements # If we didn't hit a 'break' python运行for循环时，会逐个将序列object中的元素赋值给target变量，然后为每个元素执行循环主体。循环主体一般使用target来引用序列中的当前元素。 完整格式：123456for target in object: # Assign object items to target statements if test: break # Exit loop now, skip else if test: continue # Go to top of loop now else: statements # If we didn't hit a 'break' 其中else块像在while中一样工作，如果循环离开时没有碰到break就会被执行。例：1234567891011&gt;&gt;&gt; for x in ["spam", "eggs", "ham"]: ... print(x, end=' ') ... spam eggs ham&gt;&gt;&gt; sum = 0 &gt;&gt;&gt; for x in [1, 2, 3, 4]: ... sum = sum + x&gt;&gt;&gt; prod = 1 &gt;&gt;&gt; for item in [1, 2, 3, 4]: prod *= item 1234S = "lumberjack" T = ("and", "I'm", "okay")for x in S: print(x, end=' ') for x in T: print(x, end=' ') 12T = [(1, 2), (3, 4), (5, 6)] for (a, b) in T: print(a, b) 这种形式通常和zip调用一起使用，以实现并行遍历。 python它通常还和sql数据库一起使用。 遍历字典12345D = &#123;'a': 1, 'b': 2, 'c': 3&#125; for key in D: print(key, '=&gt;', D[key]) list(D.items()) 会返回一个列表，其中每项是一个元组：[('a', 1), ('c', 3), ('b', 2)] 所以123456789for (key, value) in D.items(): print(key, '=&gt;', value)&gt;&gt;&gt; T [(1, 2), (3, 4), (5, 6)] &gt;&gt;&gt; for both in T: ... a, b = both # Manual assignment equivalent ... print(a, b) # 2.X: prints with enclosing tuple "()"&gt;&gt;&gt; for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: print(a, b, c) python3的扩展序列赋值用于for循环123456789101112&gt;&gt;&gt; for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]: ... print(a, b, c) ... 1 [2, 3] 4 5 [6, 7] 8&gt;&gt;&gt; for all in [(1, 2, 3, 4), (5, 6, 7, 8)]: # Manual slicing in 2.X ... a, b, c = all[0], all[1:3], all[3] ... print(a, b, c) ... 1 (2, 3) 4 5 (6, 7) 8 嵌套for循环123456789items = ["aaa", 111, (4, 5), 2.01] tests = [(4, 5), 3.14] for key in tests: for item in items: if item == key: print(key, "was found") break else: print(key, "not found!") 等价于：12345for key in tests: if key in items: print(key, "was found") else: print(key, "not found!") in操作符会进行隐形的1列表扫描，找到匹配。 一般来说基于简洁和性能考虑，让python尽可能的多做一点工作是一个好主意。1234567&gt;&gt;&gt; seq1 = "spam" &gt;&gt;&gt; seq2 = "scam" &gt;&gt;&gt; &gt;&gt;&gt; res = [] # Start empty &gt;&gt;&gt; for x in seq1: # Scan first sequence ... if x in seq2: # Common item? ... res.append(x) # Add to result end 使用列表解析实现相同的功能：12&gt;&gt;&gt; [x for x in seq1 if x in seq2] # Let Python collect results ['s', 'a', 'm'] 文件的扫描 文件内容一次加载至字符串： 12file = open('test.txt', 'r') print(file.read()) 分块加载：按字节 12345678file = open('test.txt') while True: char = file.read(1) # Read by character if not char: break # Empty string means end-of-file print(char) for char in open('test.txt').read(): print(char) 按行或块加载： 1234567891011file = open('test.txt') while True: line = file.readline() # Read line by line if not line: break print(line.rstrip()) # Line already has a \nfile = open('test.txt', 'rb') while True: chunk = file.read(10) # Read byte chunks: up to 10 bytes if not chunk: break print(chunk) 逐行读取文件时，for是最容易编写的： 12345for line in open('test.txt').readlines(): #一次性读入所有的行，存储在一个list中 print(line.rstrip()) for line in open('test.txt'): # Use iterators: best for text input 使用文件的迭代器，一次一行的读入。 print(line.rstrip()) 这是最好的方式处理文件，可以处理任意大小的文件，不会一次性加载整个文件到内存。也是最快速的方式。 适合使用readlines的情况：例如进行文件行的倒序输出1for line in reversed(open('test.txt').readlines()): ... 编写循环的技巧for循环包括多数计数器式的循环，一般来说for比while容易，执行也比较快。所以当需要遍历序列或其他可迭代类型时首选。 python提供两个内置函数，在for循环内定制迭代： 内置函数range返回一系列连续增加的整数，可作为for的索引。 内置函数zip返回并行元素的元组列表，可用于在for内遍历整个序列。 内置函数enumerate产生元素的值和索引的可迭代类型，所以我们不需要手动计数。 python2的内置的map函数与zip有相同的作用。 因为for循环一般都比while计数器循环运行的更快，可能的话尽量使用能用的工具获得优势。 循环计数器while和rangerange是通用工具，可用在各种环境下，任何需要整数列表的地方。python2中range创建一个列表，python3.x中range是一个迭代器，可根据需要返回元素，需要将其包含到一个list调用中以一次性显示其结果：12list(range(5)), list(range(2, 5)), list(range(0, 10, 2)) ([0, 1, 2, 3, 4], [2, 3, 4], [0, 2, 4, 6, 8]) 一个参数时，显示从零算起的整数列表，不包括参数值。0 到 n-1两个参数，第一个是开始边界，第二个是结束，不包括第二个参数。三个参数，第三个提供步进值。range也可以是非正数或非递增的：12345678&gt;&gt;&gt; list(range(?5, 5)) [?5, ?4, ?3, ?2, ?1, 0, 1, 2, 3, 4] &gt;&gt;&gt; list(range(5, ?5, ?1)) [5, 4, 3, 2, 1, 0, ?1, ?2, ?3, ?4]for i in range(3): print(i, 'Pythons') 遍历序列12&gt;&gt;&gt; X = 'spam' &gt;&gt;&gt; for item in X: print(item, end=' ') # Simple iteration 或，非要用手动进行索引时：1234&gt;&gt;&gt; i = 0 &gt;&gt;&gt; while i &lt; len(X): # while loop iteration ... print(X[i], end=' ') ... i += 1 或1&gt;&gt;&gt; for i in range(len(X)): print(X[i], end=' ') # Manual range/len iteration range/len组合的形式虽然能满足要求，但是可能会运行的更慢，更多的开销，所以如果没有特定需要索引输出的时候最好选用这种简单的for循环形式：1&gt;&gt;&gt; for item in X: print(item, end=' ') # Use simple iteration if you can 可能的情况下使用for替代while，不要在for循环内部试用range。 非完备遍历:range和分片12S = 'abcdefghijk' for i in range(0, len(S), 2): print(S[i], end=' ') 也可以使用分片：1for c in S[::2]: print(c, end=' ') 序列重排:range和len12345678910111213&gt;&gt;&gt; S = 'spam' &gt;&gt;&gt; for i in range(len(S)): # For repeat counts 0..3 ... S = S[1:] + S[:1] # Move front item to end ... print(S, end=' ')&gt;&gt;&gt; for i in range(len(S)): # For positions 0..3 ... X = S[i:] + S[:i] # Rear part + front part ... print(X, end=' ')&gt;&gt;&gt; L = [1, 2, 3] &gt;&gt;&gt; for i in range(len(L)): ... X = L[i:] + L[:i] # Works on any sequence type ... print(X, end=' ') 排除某些元素的遍历：range 和 slices1234567891011&gt;&gt;&gt; S = 'abcdefghijk' &gt;&gt;&gt; list(range(0, len(S), 2)) [0, 2, 4, 6, 8, 10] &gt;&gt;&gt; for i in range(0, len(S), 2): print(S[i], end=' ') ... a c e g i k或&gt;&gt;&gt; S = 'abcdefghijk' &gt;&gt;&gt; for c in S[::2]: print(c, end=' ') ... a c e g i k 遍历列表进行修改：range12L = [1, 2, 3, 4, 5]for x in L: x += 1 这并不会修改原列表中的值。 真的要在遍历列表时对其进行修改需要使用索引：1for i in range(len(L)): L[i] += 1 或1234i = 0 while i &lt; len(L): L[i] += 1 i += 1 下面简单的列表解析表达式也能做相同的工作：1[x + 1 for x in L] 但是并不是在原处修改，而是把表达式产生的新列表对象赋给了L 并行遍历：zip和mapzip内置函数让我们用for循环来并行使用多个序列。zip会取得一个或多个序列为参数，返回元组列表，将这些序列中并排的元素配成对。例：1234567L1 = [1,2,3,4] L2 = [5,6,7,8] zip(L1, L2) list(zip(L1, L2)) [(1, 5), (2, 6), (3, 7), (4, 8)] for (x, y) in zip(L1, L2): print(x, y, '--', x+y) zip函数可以接受任何类型的序列（任何可迭代的对象，包括文件），并且可以有两个以上的参数。123T1, T2, T3 = (1,2,3), (4,5,6), (7,8,9) list(zip(T1, T2, T3)) [(1, 4, 7), (2, 5, 8), (3, 6, 9)] 当参数长度不同时，zip会以最短的序列长度为准来截断所得到的元组。1234S1 = 'abc' S2 = 'xyz123' list(zip(S1, S2)) [('a', 'x'), ('b', 'y'), ('c', 'z')] python2.x中的map的等价形式：python3不再支持.1234567S1 = 'abc' S2 = 'xyz123'map(None, S1, S2) #使用None将短的list补足[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None,'3')]list(map(ord, 'spam')) [115, 112, 97, 109] 相当于：12res = []for c in 'spam': res.append(ord(c)) 使用zip构造字典12345keys = ['spam', 'eggs', 'toast']vals = [1, 3, 5] list(zip(keys, vals)) D2 = &#123;&#125; for (k, v) in zip(keys, vals): D2[k] = v 或者跳过for：12D3 = dict(zip(keys, vals))&#123;k: v for (k, v) in zip(keys, vals)&#125; 或使用解析的格式：12&gt;&gt;&gt; &#123;k: v for (k, v) in zip(keys, vals)&#125; &#123;'eggs': 3, 'toast': 5, 'spam': 1&#125; 同时产生偏移和元素的值enumeraterange可以产生偏移，而不是偏移位置的元素。有些程序中我们两者都需要。12345&gt;&gt;&gt; S = 'spam' &gt;&gt;&gt; offset = 0 &gt;&gt;&gt; for item in S: ... print(item, 'appears at offset', offset) ... offset += 1 enumerate函数返回一个生成器对象，支持迭代协议。对象有一个next方法，由next()内置函数调用它。每次返回一个(index,value)元组。123[c * i for (i, c) in enumerate(S)] &gt;&gt;&gt; for (i, l) in enumerate(open('test.txt')): ... print('%s) %s' % (i, l.rstrip())) shell命令python的os.popen也提供了一种类似文件的接口，用于读取子shell命令的输出：123456789101112131415&gt;&gt;&gt; for line in os.popen('dir'): # File line iterator loop ... print(line.rstrip())&gt;&gt;&gt; for line in os.popen('systeminfo'): print(line.rstrip())&gt;&gt;&gt; for (i, line) in enumerate(os.popen('systeminfo')): ... if i == 4: break ... print('%05d) %s' % (i, line.rstrip()))# Parse for specific lines, case neutral &gt;&gt;&gt; for line in os.popen('systeminfo'): ... parts = line.split(':') ... if parts and parts[0].lower() == 'system type': ... print(parts[1].strip())... x64-based PC123&gt;&gt;&gt; from urllib.request import urlopen &gt;&gt;&gt; for line in urlopen('http://home.rmi.net/~lutz'): ... print(line) 迭代器和解析for循环可用于任何可迭代对象，字符串，元组，列表等。python中所有会从左至右扫描对象的迭代工具包括如for循环，列表解析，in成员关系测试，map内置函数等。 可迭代对象：如果对象是实际保存的序列，或者可在迭代工具环境中一次产生一个结果的对象。某种意义上说即物理序列和根据需求计算的虚拟序列。 文件迭代器12f = open('script2.py') f.readline() 每次调用都会前进到下一行，到达末尾时返回空字符串。 所以python3中文件也有一个方法__next__（python2中是next）,每次调用返回文件中的下一行。到达文件末尾时next会引发内置的stopiteration异常。 这个接口就是python中的迭代协议：有next方法的对象,调用时会前进到下一结果，而在到达一系列结果的末尾时，会引发StopIteration异常。 python中任何这类对象都认为是可迭代的，都能以for循环或其它迭代工具遍历，所有迭代工具内部都是在每次迭代中调用next,并捕捉StopIteration异常来确定何时离开。 所以，逐行读取文本的最佳方法就是根本不要去读取，让for循环在每轮自动调用next前进到下一行：12for line in open('script2.py'):print(line.upper(), end='') 这种方式是最佳方式：写法简单，运行快速，内存使用情况最好，避免一次读入造成内存不够。1for line in open('script2.py').readlines(): 将文件所有行全部一次性读入内存，做成行字符串的列表，依然能用，但不是最好方法了。 即使逐行读入：1234while True: ... line = f.readline() ... if not line: break ... print(line.upper(), end='') 这种方法比迭代器运行的更慢，因为迭代器在python中是以C语言的速度运行的，而while循环是通过python虚拟机运行字节码的。 手动迭代:iter和nextpython3.x中提供了内置函数next会自动调用一个对象的next方法，给定一个可迭代对象X，next(X)等同于X.next()（python2中会自动调用X.next()）1234567891011&gt;&gt;&gt; f = open('script2.py') &gt;&gt;&gt; f.__next__() # Call iteration method directly 'import sys\n' &gt;&gt;&gt; f.__next__() 'print(sys.path)\n' &gt;&gt;&gt; f = open('script2.py') &gt;&gt;&gt; next(f) # The next(f) built-in calls f.__next__() in 3.X 'import sys\n' &gt;&gt;&gt; next(f) # next(f) =&gt; [3.X: f.__next__()], [2.X: f.next()] 'print(sys.path)\n' 从技术上将，迭代协议需要注意的一点：当for循环开始时，会通过它传给iter内置函数，以便从可迭代对象中获得一个迭代器，返回的对象内含有需要的next方法： 完整的迭代协议 基于两个对象： 请求对其迭代的可迭代对象，此对象的iter方法会被iter函数调用，这个方法生成一个迭代器 由可迭代对象返回的迭代器对象，迭代器对象在迭代过程中实际产生值，它的next方法被next函数调用，当完成值生成后发起StopIteration异常。 有些对象既是迭代上下文工具（执行迭代操作）又是一个可迭代对象（结果是可迭代的），包括生成器表达式，python3中的map和zip。python3中越来越多的工具变成了可迭代的，包括map,zip,range和一些字典的方法，来避免一次性在内存中产生结果列表。 for循环工具内部是这样处理内建序列类型的： 1234567891011&gt;&gt;&gt; L = [1, 2, 3] &gt;&gt;&gt; I = iter(L) # Obtain an iterator object from an iterable &gt;&gt;&gt; I.__next__() # Call iterator's next to advance to next item1&gt;&gt;&gt; I.__next__() # Or use I.next() in 2.X, next(I) in either line 2&gt;&gt;&gt; I.__next__() 3 &gt;&gt;&gt; I.__next__() ...error text omitted... StopIteration 对于文件来说第一步转换为迭代器是不需要的，文件对象本身就是一个迭代器：12345&gt;&gt;&gt; f = open('script2.py') &gt;&gt;&gt; iter(f) is f True &gt;&gt;&gt; iter(f) is f.__iter__() True &gt;&gt;&gt; f.__next__() 'import sys\n' List和许多其它内建对象自己并不是迭代器，这是为了让他们支持多个迭代并行，这些迭代可能会在不同的位置上，迭代器负责每个迭代的位置维护：12345678910&gt;&gt;&gt; L = [1, 2, 3] &gt;&gt;&gt; iter(L) is L False &gt;&gt;&gt; L.__next__() AttributeError: 'list' object has no attribute '__next__' &gt;&gt;&gt; I = iter(L) &gt;&gt;&gt; I.__next__() 1 &gt;&gt;&gt; next(I) # Same as I.__next__() 2 手动迭代与自动迭代的不同：1234567891011&gt;&gt;&gt; L = [1, 2, 3] &gt;&gt;&gt; for X in L: # Automatic iteration ... print(X ** 2, end=' ') # Obtains iter, calls __next__, catches exceptions&gt;&gt;&gt; I = iter(L) # Manual iteration: what for loops usually do &gt;&gt;&gt; while True: ... try: # try statement catches exceptions ... X = next(I) # Or call I.__next__ in 3.X ... except StopIteration: ... break ... print(X ** 2, end=' ') 其他内置类型的迭代器： 遍历字典，经典方法是：123&gt;&gt;&gt; D = &#123;'a':1, 'b':2, 'c':3&#125; &gt;&gt;&gt; for key in D.keys(): ... print(key, D[key]) 但是新的python实现中，字典是带有迭代器的可迭代对象，每次迭代会自动返回一个key，所以不需要在调用keys()方法：12&gt;&gt;&gt; for key in D: ... print(key, D[key]) 其它支持迭代协议的python对象：shelves 和 os.popen的结果也是可迭代的123456789101112131415&gt;&gt;&gt; import os &gt;&gt;&gt; P = os.popen('dir') &gt;&gt;&gt; P.__next__() ' Volume in drive C has no label.\n' &gt;&gt;&gt; P.__next__() ' Volume Serial Number is D093-D1F7\n' &gt;&gt;&gt; next(P) TypeError: _wrap_close object is not an iterator&gt;&gt;&gt; P = os.popen('dir') &gt;&gt;&gt; I = iter(P) &gt;&gt;&gt; next(I) ' Volume in drive C has no label.\n' &gt;&gt;&gt; I.__next__() ' Volume Serial Number is D093-D1F7\n' os.walk也具有相似的可迭代性12345678910&gt;&gt;&gt; R = range(5) &gt;&gt;&gt; R # Ranges are iterables in 3.X range(0, 5) &gt;&gt;&gt; I = iter(R) # Use iteration protocol to produce results&gt;&gt;&gt; next(I) 0 &gt;&gt;&gt; next(I) 1 &gt;&gt;&gt; list(range(5)) # Or use list to collect all results at once #python2中是不需要list的，因为python2的range产生一个物理列表[0, 1, 2, 3, 4] 我们要想一次看到所有的元素，就要讲可迭代对象包装到list（）内，返回一个列表 列表解析：对集合中的每个元素应用一个操作：L = [x + 10 for x in L] ，代码更少，运行更快，运行结束产生一个新列表 列表解析一般可以用一个for循环手动的构建相同功能：for x in L: ... res.append(x + 10) 上面的例子在列表解析内部是这样实现的：123&gt;&gt;&gt; res = [] &gt;&gt;&gt; for x in L: ... res.append(x + 10) 但是列表解析更加精简，比手动for语句更快，是在解释器内部以C语言的速度执行的，特别是对于较大的集合。 在文件上使用列表解析123456lines = [line.rstrip() for line in open('script2.py')] 读入每一行并去掉空白[line.upper() for line in open('script2.py')] [line.rstrip().upper() for line in open('script2.py')] [line.split() for line in open('script2.py')] [line.replace(' ', '!') for line in open('script2.py')][('sys' in line, line[:5]) for line in open('script2.py')] 扩展列表解析语法过滤从句:if表达式中嵌套的for循环可以有一个if子句，来过滤那些不为真的结果项。例如： 只收集以p开头的行：1lines = [line.rstrip() for line in open('script2.py') if line[0] == 'p'] 等效但是更慢的for循环：占用了更多行，且运行起来可能更慢1234&gt;&gt;&gt; res = [] &gt;&gt;&gt; for line in open('script2.py'): ... if line[0] == 'p': ... res.append(line.rstrip()) 只收集以数字结尾的行：1&gt;&gt;&gt; [line.rstrip() for line in open('script2.py') if line.rstrip()[-1].isdigit()] 过滤空行：12345&gt;&gt;&gt; fname = r'd:\books\5e\lp5e\draft1typos.txt' &gt;&gt;&gt; len(open(fname).readlines()) # All lines 263 &gt;&gt;&gt; len([line for line in open(fname) if line.strip() != '']) # Nonblank lines 185 嵌套for循环如果需要列表解析可以嵌套包含任意数目的for循环子句，每个子句有一个可选的if子句：例如：12[x + y for x in 'abc' for y in 'lmn']['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn'] 等价于：123456&gt;&gt;&gt; res = [] &gt;&gt;&gt; for x in 'abc': ... for y in 'lmn': ... res.append(x + y)&gt;&gt;&gt; res ['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn'] 其它迭代环境用户自己定义的类也可以实现迭代协议。 文件对象，列表解析，in成员关系测试，map内置函数，sorted和zip内置函数都使用了迭代协议12345678910for line in open('script2.py'):uppers = [line.upper() for line in open('script2.py')] map(str.upper, open('script2.py')) &gt;&gt;&gt; list(map(str.upper, open('script2.py'))) ['IMPORT SYS\n', 'PRINT(SYS.PATH)\n', 'X = 2\n', 'PRINT(X ** 32)\n']sorted(open('script2.py'))['import sys\n', 'print(sys.path)\n', 'print(x ** 32)\n', 'x = 2\n'] 与其他工具不同，python3中sorted返回的是一个新的排序后的列表，而不是可迭代对象，可以在任何可迭代对象上运行。12345678list(zip(open('script2.py'), open('script2.py'))) list(enumerate(open('script2.py')))list(filter(bool, open('script2.py')))import functools, operatorfunctools.reduce(operator.add, open('script2.py')) 本质上所有的python内置工具集都会使用迭代协议从左至右的扫描对象，包括list,tuple,join等生成列表 list(open(&#39;script2.py&#39;))生成元组 tuple(open(&#39;script2.py&#39;))1'&amp;&amp;'.join(open('script2.py')) 还有一些其它的工具也会自动使用迭代协议： 12345序列赋值： a, b, c, d = open('script2.py') 扩展序列赋值： a, *b = open('script2.py') in关系判断： 'x = 2\n' in open('script2.py') 分片赋值： L[1:3] = open('script2.py') 列表的extend: L.extend(open('script2.py')) 但是列表的append不使用迭代协议:123456&gt;&gt;&gt; L = [11] &gt;&gt;&gt; L.append(open('script2.py')) # list.append does not iterate &gt;&gt;&gt; L [11, &lt;_io.TextIOWrapper name='script2.py' mode='r' encoding='cp1252'&gt;] &gt;&gt;&gt; list(L[1]) ['import sys\n', 'print(sys.path)\n', 'x = 2\n', 'print(x ** 32)\n'] 生成集合12set(open('script2.py'))&#123;line for line in open('script2.py')&#125; 生成字典123&#123;ix: line for ix, line in enumerate(open('script2.py'))&#125; &#123;line for line in open('script2.py') if line[0] == 'p'&#125; &#123;ix: line for (ix, line) in enumerate(open('script2.py')) if line[0] == 'p'&#125; 使用生成器表达式：1list(line.upper() for line in open('script2.py')) 其它支持迭代协议的内建函数，如: sum: 计算可迭代对象中所有数字之和 any和all：内建函数在可迭代对象中某个或所有元素都为True时返回True max和min：返回可迭代对象的所有元素中的最大，最小值1234567891011121314&gt;&gt;&gt; sum([3, 2, 4, 1, 5, 0]) # sum expects numbers only 15 &gt;&gt;&gt; any(['spam', '', 'ni']) True &gt;&gt;&gt; all(['spam', '', 'ni']) False &gt;&gt;&gt; max([3, 2, 5, 1, 4]) 5 &gt;&gt;&gt; min([3, 2, 5, 1, 4]) 1&gt;&gt;&gt; max(open('script2.py')) # Line with max/min string value 'x = 2\n'&gt;&gt;&gt; min(open('script2.py')) 'import sys\n' 函数中的*arg形式的参数也支持可迭代对象123456789101112&gt;&gt;&gt; def f(a, b, c, d): print(a, b, c, d, sep='&amp;') ... &gt;&gt;&gt; f(1, 2, 3, 4) 1&amp;2&amp;3&amp;4 &gt;&gt;&gt; f(*[1, 2, 3, 4]) # Unpacks into arguments 1&amp;2&amp;3&amp;4 &gt;&gt;&gt; &gt;&gt;&gt; f(*open('script2.py')) # Iterates by lines too! import sys &amp;print(sys.path) &amp;x = 2 &amp;print(x ** 32) 使用这种参数的方法可以让zip再次zip过的元组：1234567891011&gt;&gt;&gt; X = (1, 2) &gt;&gt;&gt; Y = (3, 4) &gt;&gt;&gt; &gt;&gt;&gt; list(zip(X, Y)) # Zip tuples: returns an iterable [(1, 3), (2, 4)]&gt;&gt;&gt; A, B = zip(*zip(X, Y)) # Unzip a zip! 将*zip(X, Y)作为一个参数列表再次zip&gt;&gt;&gt; A (1, 2) &gt;&gt;&gt; B (3, 4) range内建函数和字典视图对象也都返回可迭代对象 python3.x中新的可迭代对象python3与python2的一个基本区别就是python3更注重迭代器的重要性 除了与内建类型如文件和字典关联的迭代器外，字典的方法keys,values,items在python3中与内建函数range,map,zip,filter一样也都返回可迭代类型,根据需要返回结果。 对python2代码的影响 需要一次性显示所有结果时使用list()包装起来12&gt;&gt;&gt; list(zip('abc', 'xyz')) # Force list of results in 3.X to display [('a', 'x'), ('b', 'y'), ('c', 'z')] 对可迭代对象应用列表或序列操作时，索引，分片，连接， python2中这些工具的结果可直接运用这些操作123&gt;&gt;&gt; Z = zip((1, 2), (3, 4)) # Unlike 2.X lists, cannot index, etc. &gt;&gt;&gt; Z[0] TypeError: 'zip' object is not subscriptable 要想在可迭代工具(例如map和zip)产生的结果集上进行多次迭代也需要进行list转换，python3中这些结果集在一次遍历后就会被消耗光，而不像python2中的list格式123456789&gt;&gt;&gt; M = map(lambda x: 2 ** x, range(3)) &gt;&gt;&gt; for i in M: print(i) ... 1 2 4 &gt;&gt;&gt; for i in M: print(i) # 再次调用迭代时没有结果，M代表这个可迭代对象 ... &gt;&gt;&gt; 而在python2中M实际上是一个list，可以直接多次对其遍历具有相同的值。 python3中range内建工具也返回一个可迭代对象，用于生成需求范围内的数字。 在需要列表的地方使用list(range(…))强制返回一个列表123456789101112131415161718192021&gt;&gt;&gt; list(range(10)) # To force a list if required [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]python3中range对象只支持迭代，索引和len函数，不支持其它序列操作：&gt;&gt;&gt; R = range(10) # range returns an iterable, not a list &gt;&gt;&gt; R range(0, 10) &gt;&gt;&gt; I = iter(R) # Make an iterator from the range iterable &gt;&gt;&gt; next(I) # Advance to next result 0 # What happens in for loops, comprehensions, etc. &gt;&gt;&gt; next(I) 1&gt;&gt;&gt; len(R) # range also does len and indexing, but no others 10 &gt;&gt;&gt; R[0] 0&gt;&gt;&gt; R[-1] 9 &gt;&gt;&gt; next(I) # Continue taking from iterator, where left off 2 &gt;&gt;&gt; I.__next__() # .next() becomes .__next__(), but use new next() 3 python2的内建函数xrange和python3的range相同，可根据请求产生结果。python3中不再保留xrange同样python2的file.xreadlines()在python3中也被删除了。 map/zip/filter在python3中也都是可迭代对象： 这几个函数可以接受可迭代对象最为参数，同时也返回可迭代类型的对象，他们是自己的迭代器，在遍历后会消耗光内容。1234567891011121314151617181920212223&gt;&gt;&gt; M = map(abs, (-1, 0, 1)) # map returns an iterable, not a list &gt;&gt;&gt; M &lt;map object at 0x00000000029B75C0&gt; &gt;&gt;&gt; next(M) # Use iterator manually: exhausts results 1 # These do not support len() or indexing &gt;&gt;&gt; next(M) 0 &gt;&gt;&gt; next(M) 1 &gt;&gt;&gt; next(M) StopIteration &gt;&gt;&gt; for x in M: print(x) # map iterator is now empty: one pass only ... &gt;&gt;&gt; M = map(abs, (-1, 0, 1)) # Make a new iterable/iterator to scan again &gt;&gt;&gt; for x in M: print(x) # Iteration contexts auto call next()... 1 0 1 &gt;&gt;&gt; list(map(abs, (-1, 0, 1))) # Can force a real list if needed [1, 0, 1] zip也以同样的方式工作：1234567&gt;&gt;&gt; Z = zip((1, 2, 3), (10, 20, 30)) # zip is the same: a one-pass iterator &gt;&gt;&gt; Z &lt;zip object at 0x0000000002951108&gt; &gt;&gt;&gt; list(Z) [(1, 10), (2, 20), (3, 30)] &gt;&gt;&gt; for pair in Z: print(pair) # Exhausted after one pass ... filter内建函数，同样也可以接受可迭代对象也返回可迭代对象：1234&gt;&gt;&gt; filter(bool, ['spam', '', 'ni']) &lt;filter object at 0x00000000029B7B70&gt; &gt;&gt;&gt; list(filter(bool, ['spam', '', 'ni'])) ['spam', 'ni'] 可以用列表解析的方法模拟相同的功能：1234&gt;&gt;&gt; [x for x in ['spam', '', 'ni'] if bool(x)] ['spam', 'ni'] &gt;&gt;&gt; [x for x in ['spam', '', 'ni'] if x] ['spam', 'ni'] 多次迭代器VS单次迭代器 range支持len和索引，它不是自己的迭代器，它支持自己结果上的多个迭代器，迭代器间互不影响： 12345678910111213&gt;&gt;&gt; R = range(3) # range allows multiple iterators&gt;&gt;&gt; next(R) TypeError: range object is not an iterator &gt;&gt;&gt; I1 = iter(R) &gt;&gt;&gt; next(I1) 0 &gt;&gt;&gt; next(I1) 1 &gt;&gt;&gt; I2 = iter(R) # Two iterators on one range &gt;&gt;&gt; next(I2) 0 &gt;&gt;&gt; next(I1) # I1 is at a different spot than I2 2 zip/map/filter不支持相同结果上的多个活跃迭代器，所以iter调用是可有可无的，他们的iter返回他们自己。 1234567891011121314151617181920212223&gt;&gt;&gt; Z = zip((1, 2, 3), (10, 11, 12)) &gt;&gt;&gt; I1 = iter(Z) &gt;&gt;&gt; I2 = iter(Z) # Two iterators on one zip &gt;&gt;&gt; next(I1) (1, 10) &gt;&gt;&gt; next(I1) (2, 11) &gt;&gt;&gt; next(I2) # (3.X) I2 is at same spot as I1! (3, 12) &gt;&gt;&gt; M = map(abs, (-1, 0, 1)) # Ditto for map (and filter) &gt;&gt;&gt; I1 = iter(M); I2 = iter(M) &gt;&gt;&gt; print(next(I1), next(I1), next(I1)) 1 0 1 &gt;&gt;&gt; next(I2) # (3.X) Single scan is exhausted! StopIteration &gt;&gt;&gt; R = range(3) # But range allows many iterators &gt;&gt;&gt; I1, I2 = iter(R), iter(R) &gt;&gt;&gt; [next(I1), next(I1), next(I1)] [0 1 2] &gt;&gt;&gt; next(I2) # Multiple active scans, like 2.X lists 0 所以多次迭代器是通过用iter调用返回新对象的方式支持的，而单次迭代器意味着一个对象的iter返回它自己。在之后的内容中，生成器函数和生成器表达式的行为类似map和zip而像range 字典视图迭代器python3.x中字典的keys,values,items方法返回可迭代视图对象，一次返回一个值，而不是所有值的列表，视图在python2.7中也可用，只不过使用了不同的方法名称避免影响现有代码。 视图条目维护与底层字典对象相同的顺序，并且可以反映底层字典的更改:1234567891011121314151617&gt;&gt;&gt; D = dict(a=1, b=2, c=3) &gt;&gt;&gt; D &#123;'a': 1, 'b': 2, 'c': 3&#125; &gt;&gt;&gt; K = D.keys() # A view object in 3.X, not a list &gt;&gt;&gt; K dict_keys(['a', 'b', 'c']) &gt;&gt;&gt; next(K) # Views are not iterators themselves TypeError: dict_keys object is not an iterator &gt;&gt;&gt; I = iter(K) # View iterables have an iterator, &gt;&gt;&gt; next(I) # which can be used manually, 'a' # but does not support len(), index &gt;&gt;&gt; next(I) 'b' &gt;&gt;&gt; for k in D.keys(): print(k, end=' ') # All iteration contexts use auto ... a b c python3中的字典是它自己的迭代器，它的迭代器返回相邻的keys，所以不一定非要直接调用keys()也可以使用字典自己的迭代器：1234567891011121314151617181920&gt;&gt;&gt; D # Dictionaries still produce an iterator &#123;'a': 1, 'b': 2, 'c': 3&#125; # Returns next key on each iteration &gt;&gt;&gt; I = iter(D) &gt;&gt;&gt; next(I) 'a' &gt;&gt;&gt; next(I) 'b' &gt;&gt;&gt; for key in D: print(key, end=' ') # Still no need to call keys() to iterate ... # But keys is an iterable in 3.X too! a b c&gt;&gt;&gt; D &#123;'a': 1, 'b': 2, 'c': 3&#125; &gt;&gt;&gt; for k in sorted(D.keys()): print(k, D[k], end=' ') ... a 1 b 2 c 3 &gt;&gt;&gt; for k in sorted(D): print(k, D[k], end=' ') # "Best practice" key sorting ... a 1 b 2 c 3 其它可迭代对象 用户自定义的函数可以使用yield语句转变为可迭代生成器函数。 列表解析被包含在圆括号中时转变为可迭代生成器表达式。 用户自定义的类可以使用iter or getitem操作符重载定义为可迭代的。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo安装，配置]]></title>
    <url>%2F2019%2F01%2F05%2Fhexo-install-config%2F</url>
    <content type="text"><![CDATA[前言在网络上游荡20几年，没有一个稳定的博客空间，很多自己的总结/随笔都是以文本文件的形式存储在本地，主要因为下面几个原因： 感觉大部分的博客空间都随时有消失的可能，免费空间大都有各种限制，没有安全感，不想自己多年的心血白费 大部分博客中的内容的富文本格式不可移植，不能很方便的同步在多个空间 我懒，本地存储虽然low但是使用、搜索、编辑起来还是很方便的 不过如今的网络文章写作已经很不同了，Markdown的流行甚至成了一种标准，主流的博客平台基本都开始支持Markdown格式，这让一次写作多处发布成为了可能，而且Markdown格式的文本在本地也很容易存储、编辑、解析后更已读、能够方便的导出为html,pdf等多种格式分享。很大程度上减轻了维护一个甚至多个博客空间的工作量。 支持Markdown写作的博客有多种选择，比如 在线的：简书，github，博客园，SegmentFault，开源中国，图灵社区等 blog建站系统：hexo，jekyII，wordpress，Ghost，gitblog，CMD Markdown，startblog等 我自己目前的需求是以本地为中心，能够方便的生成静态页面或直接上传Markdown文档后进行多位置的部署，又不想受各博客空间的模板限制，又想稳定方便，所以，自己搭搭建可以说是个很好的选择。在这里，我将介绍我当前博客的搭建方法：使用自己的虚拟主机+Github Page同步发布，基于Hexo框架，采用nexT模板。下面就把自己搭建，配置过程和使用方法进行一个记录。 我自己的博客环境的需求： 能在多台电脑随时写作更新，能在本地查看格式化后内容，能根据内容搜索。 博客空间位于两个位置：自己的虚拟主机和github.io ，可以同步更新。 对于文章可以有选择地复制到其它在线空间。 Hexo安装配置什么是Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。Hexo基于Node.js，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub上，是搭建博客的首选框架。 最好的介绍还是上官网链接：https://hexo.io/zh-cn/ 安装我的安装环境是一个刚刚在本地重装好的centos7虚拟机，首先我会用这台主机作为初始空间配置的生成，并运行独立的http服务器。 安装gitHexo, node.js, Hexo主题，后续空间的发布，配置及文章的同步都需要git作为工具。 Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Linux (Ubuntu, Debian)：sudo apt-get install git-core Windows：下载并安装 git. Mac：使用Homebrew, MacPorts：brew install git ;或下载安装程序安装。 由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。 安装Node.js安装 Node.js 的最佳方式是使用nvm。 cURL: 1$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh Wget: 1$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装Node.js： 1$ nvm install stable 或者您也可以下载安装程序来安装。 对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 配置以上Hexo最基本的组件已经全部安装完成，后续可能还会需要其它的依赖组件，在配置过程中用到时再随时安装。 创建一个Hexo运行目录Hexo系统需要一个目录用来初始化生成博客空间所需要的全部文件，我选择在自己home目录下的hexo文件夹： 1$ mkdir ~/hexo 初始化运行目录请执行下列命令，Hexo将会在指定文件夹中新建所需要的文件。 123$ hexo init ~/hexo$ cd ~/hexo$ npm install 新建完成后，文件夹hexo内的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 其中各文件和目录的作用： _config.yml: 网站的 配置 信息，您可以在此配置大部分的参数。 package.json: 应用程序的信息。一般无需更改。 scaffolds: 模版 文件夹。当新建文章时，Hexo 会根据scaffold来建立文件。Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source: 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes: 主题 文件夹。Hexo 会根据主题来生成静态页面。 执行完初始化，就可以预览一下hexo的初始样貌了，可以在~/hexo目录下执行如下命令: 12$ hexo generate$ hexo server 执行完毕后可以通过浏览器访问http://server-ip:4000/来访问 配置hexo安装nexT主题我个人很喜欢hexo的NexT主题，所以配置过程中一起安装这个主题。NexT主题是托管在github上的，其新的主页地址：https://github.com/theme-next/hexo-theme-next/原地址，此代码库已停止更新：https://github.com/iissnan/hexo-theme-next 安装方法： 12cd ~/hexogit clone https://github.com/theme-next/hexo-theme-next themes/next 修改hexo站点基本配置~/hexo/_config.yml可以在 _config.yml 中修改大部分的配置。以下是我修改的内容： 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述。主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。 author 您的名字，用于显示文章的作者。 language 网站使用的语言，简体中文应设置为zh-Hans，支持的语言列表可参看所用主题的目录：themes/next/languages/ timezone 网站时区。Hexo默认使用您电脑的时区。为增加移植性设定为北京时间：Asia/Shanghai ，参考时区列表。 url 网址，填http://自己网站域名 root 网站根目录，本blog在网站中的目录 theme 当前主题名称，即themes目录下主题目录的名称。我安装了NexT主题，这里设置为 next deploy 部署部分的设置，将在下面章节详述 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 下列参数是可能会用到的，我目前保留了默认值： 参数 描述 默认值 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 default_category 默认分类 uncategorized date_format 日期格式 Hexo 使用 Moment.js 来解析和显示时间。 YYYY-MM-DD time_format 时间格式 H:mm:ss per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 修改NexT主题配置~/hexo/themes/next/_config.yml关于NexT主题的全部详细配置方法见官网：https://theme-next.org/原官网地址，已停止更新：https://theme-next.iissnan.com 我自己对NexT主题配置文件的修改如下： 显示在菜单导航栏中的项目1234567menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive about: /about/ || user sitemap: /sitemap.xml || sitemap categories和tags页面将在后面使用hexo命令创建 主题显示布局，默认为Muse，更改为更简洁的Mist1234#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 修改社交媒体及联系方式123social: GitHub: https://github.com/redfuture || github E-Mail: mailto:redfuture@hotmail.com || envelope 其中第一部分为显示的文字名称，第二部分为链接，第三部分为显示的图标对应的fontawesome icons的名称 添加站点建立时间12footer: since: 2019 添加背景动画1canvas_nest: true 使用night风格的代码高亮显示1highlight_theme: night 至此hexo站点与next主题基本配置完毕。接下来使用hexo命令创建categories和tags页面，并新建一个新的文章。 使用hexo我希望在站点首页的导航菜单栏里添加两个链接： 分类：显示所有文章分类的页面，点击分类后显示这个分类下的所有文章 标签：所有文章使用过的标签页面，点击相应标签可以查看所有有此标签的文章 创建categories和tags页面hexo中创建页面的方式是相同的，使用以下命令：123$ hexo new page categories$ hexo new page tags$ hexo new page about 我同时还创建了一个关于页面，可以添加个人的简历，这个些可以和NexT主题配置文件中menu下面的子项相对应。命令执行后的结果就是在~/hexo/source/目录下分别生成了三个目录：categories，tags，about。每个目录中都有一个index.md。 修改post模板我们有了categories页面及tags页面，希望在以后发布的每篇博客都指定一个分类（Hexo仅支持一篇文章属于一个分类，不能属于多个分类），并设置多个标签。那么可以修改scaffolds/post.md文件，这个文件中的内容在以后每次用命令行创建新文章时会自动复制到新文章的md文件中。将其内容修改成：123456789---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories:- defaulttags:- default1- default2--- 发布新文章现在所有都已经准备就绪，可以发布自己的第一篇文章了：1$ hexo new post "title" 命令执行后创建~/hexo/source/_post/title.md ,随后就可以使用熟悉的编辑器编辑title.md了 或者可以先创建一个草稿：1$ hexo new draft "title" 会生成~/hexo/source/_post/title.md，编辑完成后执行1$ hexo publish post "title" 会将文件移动到~/hexo/source/_post/title.md 生成静态页面并部署文章写作完成后可以执行如下命令生成静态页面：12345678$ hexo generate (hexo g) 由当前目录下的配置和文章生成新的博客静态页面$ hexo server (hexo s) 启动本地http server服务，默认在4000端口$ hexo deploy (hexo d) 提交到远程仓库$ hexo new page "xx"(hexo n page) 创建页面 $ hexo new "xx" (hexo n "") 创建文章$ hexo d -g 生成静态并提交到远程仓库$ hexo s -g 生成静态文件并启动本地预览$ hexo clean 如果修改了配置文件，建议先执行这个步骤，将public下的文件全部清除，重新生成 之后就可以在http://localhost:4000/看到刚才发布的文章了。至此hexo基础环境已经搭建完成。 将静态页面部署到github.iogithub为每个用户提供了一个无限容量的静态页面空间：your-github-username.github.io hexo也提供了方便的将自己的博客部署到github.io的功能： 登录自己github，确认已经存在username.github.io代码库，没有的话创建一个（必须以.github.io做后缀）。 生成一对RSA key, 命令如下： 1$ ssh-keygen -t rsa -b 4096 -C "自己的标识" 一路回车，会在~/.ssh/目录下生成两个文件：id_rsa和id_rsa.pub ，id_rsa自己保留好这是私钥。 将上面生成的id_rsa.pub配置到github账户，以便可以免密从自己的代码库check in/out代码。具体参见github帮助文档：Adding a new SSH key to your GitHub account 验证是否添加key成功： 1$ ssh -T git@github.com 修改站点配置文件：~/hexo/_config.yml 1234deploy: type: git repo: git@github.com:username.github.io.git branch: master 安装hexo的git插件 1$ npm install hexo-deployer-git --save 运行命令进行部署： 12$ hexo g$ hexo d 之后就可以在 http://username.github.io 看到自己的博客了。 写作环境博客基本成形了，同时发布在了github.io。但是有一个问题，如何能方便的在任意电脑上都能随时随地的码字更新，修改配置呢？ 建立个性化内容的代码库分析Hexo的文档结构后发现会被我们使用的配置文件和存储文章md文件的目录其实很集中，那么我们可以把这些可能被改变的文件提取出来，单独存放在一个github的代码库，这样每当需要修改配置，或添加新文章时就可以先去代码库checkout，修改，然后checkin了。只要电脑有git客户端和一个markdown编辑器就够了。 在github建立一个新代码库，假设名称为：myblog_site 将本地hexo运行目录中需要保存到github的易变内容提取出来： 12345$ mkdir ~/myblog_site$ mkdir -p ~/myblog_site/themes/next$ cd ~/hexo/$ cp -a _config.yml scaffolds source ~/myblog_site/ #拷贝站点配置，模板，文章目录至代码库目录$ cp themes/next/_config.yml ~/myblog_site/themes/next/ #拷贝NexT主题配置文件至代码库相同路径下 将~/myblog_site/ 初始化为git目录，并于新建立的代码库myblog_site关联，checkin 123456$ cd ~/myblog_site$ git init$ git add *$ git commit -a -m "init blog raw data."$ git remote add origin git@github.com:username/myblog_site.git$ git push -u origin master #将本地代码推送到远程代码库 至此博客的数据代码库建立完成。 在虚拟主机上建立相同的站点 登录虚拟主机，按照上面的步骤完成安装，假设仍然将hexo工作目录放在~/hexo/。 checkout博客的配置和文章数据： 12345678910$ cd$ scp id_rsa.pub ~/.ssh/ #将上面生成的私钥放置在虚拟主机服务器上$ git clone git@github.com:username/myblog_site.git #将配置/文章代码库克隆到本地$ cd ~/hexo/ #进入安装初始化好的博客工作目录$ rm -rf _config.yml scaffolds source themes/next/_config.yml$ ln -s ~/myblog_site/_config.yml # 如下分别将文件链接到代码库中的相同文件/目录$ ln -s ~/myblog_site/scaffolds$ ln -s ~/myblog_site/source$ cd themes/next/$ ln -s ~/myblog_site/themes/next/_config.yml 在虚拟主机上执行静态页面生成与部署： 123$ hexo g$ hexo d$ hexo s &amp; 后续写作过程 在一台新的工作电脑上（已安装git），将myblog_site克隆到本地目录。 使用任意markdown编辑器，编辑/添加文章到相应目录，或修改配置文件。 发布时先checkin到github: 12$ git commit -a -m "comments"$ git push origin master 登录到自己的虚拟主机执行myblog_site的checkout，然后执行静态页面的生成与部署到github.io，同时主机上启动服务。 关于markdown编辑器目前有多种编辑器可供使用,比如markdownpad, 在线的简书编辑器等，我自己更喜欢一些开源，免费，简单可移植的工具。工作中一直在用notepad++这个工具觉得很不错。notepad++也有第三方的plugin可以进行简单的markdown解析预览，虽然效果不是特别好，但是对于日常的文章写作足够用。 notepad++ notepad++ markdown预览插件：MarkdownViewerPlusPlus notepad++ markdown语法高亮插件：Markdown Syntax Highlighting for Notepad++ 以上所有部件均为纯绿色版本，存进自己的U盘，随身携带，即插即用。 完善博客功能添加搜索 进入到站点根目录：cd ~/hexo/ 安装：npm install –save hexo-generator-searchdb 配置： 编辑站点配置文件~/hexo/_config.yml，确保下列内容存在： 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件~/hexo/theme/next/_config.yml，启用本地搜索功能： 123# Local searchlocal_search: enable: true 重新生成。 添加站点地图 进入到站点根目录：cd ~/hexo/ 分别用下面两个命令来安装针对谷歌和百度的插件： 12$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 在站点配置文件中~/hexo/_config.yml中添加如下代码 12345678Plugins:- hexo-generator-baidu-sitemap- hexo-generator-sitemapbaidusitemap: path: baidusitemap.xmlsitemap: path: sitemap.xml 在你的博客根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了 优化SEO最简单的 添加RSS添加fork me on github 在GitHub Ribbons或GitHub Corners选择一款你喜欢的挂饰，拷贝方框内的代码。 将刚刚复制的挂饰代码，添加到hexo/themes/next/layout/_layout.swig文件中，放在下方。 12&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;&lt;a href=&quot;https://github.com/redfuture/&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 添加公益404页面设置阅读全文方式设置侧栏头像文章中使用图片添加评论功能添加访问量统计 静态网页最快接入计算访问量插件:不蒜子 接入方式很简单只需要将如下代码加入到页面中想要显示的位置:123456&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;span id="busuanzi_container_site_pv"&gt;本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次本站访客数&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人次本文总阅读量&lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt;次&lt;/span&gt; 在hexo的next主题中已经集成了不蒜子，使用起来更为方便，只需修改next的主题的配置文件：themes/next/_config.yml123456789101112131415busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; page_pv_footer: 由于不蒜子的域名改变，如果使用了旧版本的next主题，还需修改next主题中不蒜子的地址，位于文件themes/next/layout/_third-party/analytics/busuanzi-counter.swig。 1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>skills</tag>
        <tag>github.io</tag>
      </tags>
  </entry>
</search>
